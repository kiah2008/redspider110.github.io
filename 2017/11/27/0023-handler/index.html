<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android,Asynchronous,">










<meta name="description" content="Handler 机制是 Android 系统处理同一进程不同线程间通信的机制，基于 Linux 系统的 epoll 机制实现。">
<meta name="keywords" content="Android,Asynchronous">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Handler 机制">
<meta property="og:url" content="http://redspider110.github.io/2017/11/27/0023-handler/index.html">
<meta property="og:site_name" content="Earth Guardian">
<meta property="og:description" content="Handler 机制是 Android 系统处理同一进程不同线程间通信的机制，基于 Linux 系统的 epoll 机制实现。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-messagequeue-equeuemessage.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-messagequeue-next.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-sequence-diag.png">
<meta property="og:updated_time" content="2019-09-18T09:30:13.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Handler 机制">
<meta name="twitter:description" content="Handler 机制是 Android 系统处理同一进程不同线程间通信的机制，基于 Linux 系统的 epoll 机制实现。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-messagequeue-equeuemessage.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://redspider110.github.io/2017/11/27/0023-handler/">





  <title>Android Handler 机制 | Earth Guardian</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?faa79b658398065f8158bf82b6221b6d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Earth Guardian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">You are not LATE!You are not EARLY!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://redspider110.github.io/2017/11/27/0023-handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="redspider110">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earth Guardian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android Handler 机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T14:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i> 阅读次数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>Handler</code> 机制是 <code>Android</code> 系统处理同一进程不同线程间通信的机制，基于 <code>Linux</code> 系统的 <code>epoll</code> 机制实现。  </p>
<a id="more"></a>

<p><code>Android</code> 两大机制：<code>Binder</code> 机制用于处理进程间通信；<code>Handler</code> 机制用于处理进程内的线程间通信，线程间交互。  </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><code>Message</code><br>意为消息，发送到 <code>Handler</code> 进行处理的对象，携带描述信息和任意数据。  </li>
<li><code>MessageQueue</code><br>意为消息队列，<code>Message</code> 的集合。  </li>
<li><code>Looper</code><br>消息泵，用来从 <code>MessageQueue</code> 中抽取 <code>Message</code>，发送给 <code>Handler</code> 进行处理。 </li>
<li><code>Handler</code><br>处理 <code>Looper</code> 抽取出来的 <code>Message</code>。  </li>
</ul>
<p>也就是说所有的消息处理都是<strong>串行执行</strong>的。  </p>
<p>他们之间的关系：  </p>
<ul>
<li>每个 <code>Thread</code> 只对应一个 <code>Looper</code>  </li>
<li>每个 <code>Looper</code> 只对应一个 <code>MessageQueue</code>  </li>
<li>每个 <code>MessageQueue</code> 中有 <code>N</code> 个 <code>Message</code>  </li>
<li>每个 <code>Message</code> 最多指定一个 <code>Handler</code> 来处理事件  </li>
<li>每个 <code>Thread</code> 可以对应多个 <code>Handler</code>  </li>
</ul>
<p>在如下操作中都是基于 <code>UI</code> 主线程，在异步任务中使用 <code>Handler</code> 机制更新 <code>UI</code> 必须用 <code>new Handler();</code> 来初始化。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用 UI 主线程的 Looper</span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="源码目录及类对应文件"><a href="#源码目录及类对应文件" class="headerlink" title="源码目录及类对应文件"></a>源码目录及类对应文件</h2><h3 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Framework Java</span></span><br><span class="line">frameworks/base/core/java/android/os/</span><br><span class="line">    Message.java</span><br><span class="line">    MessageQueue.java</span><br><span class="line">    Looper.java</span><br><span class="line">    Handler.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// Framework JNI</span></span><br><span class="line">frameworks/base/core/jni/</span><br><span class="line">    android_os_MessageQueue.h</span><br><span class="line">    android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">// System Native</span></span><br><span class="line">system/core/libutils/include/utils/Looper.h</span><br><span class="line">system/core/libutils/Looper.cpp</span><br></pre></td></tr></table></figure>

<h3 id="类或接口对应文件"><a href="#类或接口对应文件" class="headerlink" title="类或接口对应文件"></a>类或接口对应文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message.java: Message</span><br><span class="line">MessageQueue.java: MessageQueue</span><br><span class="line">Looper.java: Looper</span><br><span class="line">Handler.java: Handler</span><br><span class="line">Looper.h: Message, MessageHandler, WeakMessageHandler, LooperCallback, </span><br><span class="line">          SimpleLooperCallback, Looper</span><br><span class="line">android_os_MessageQueue.h: MessageQueue</span><br><span class="line">android_os_MessageQueue.cpp: NativeMessageQueue</span><br></pre></td></tr></table></figure>

<h2 id="Message-详解"><a href="#Message-详解" class="headerlink" title="Message 详解"></a><code>Message</code> 详解</h2><p><code>Message</code> 是 <code>Handler</code> 机制中的数据容器，和 <code>Binder</code> 机制中的 <code>Parcel</code> 功能一样。<code>Message</code> 数据结构特点：    </p>
<ul>
<li>链表<br><code>Message</code> 是单链表数据结构，成员变量 <code>next</code> 保存下一条消息，而当前消息是链表的头结点。<code>Message</code> 中的消息池 <code>Message sPool</code> 利用链表头结点特性实现栈，快速存取消息；<code>MessageQueue</code> 中的成员变量 <code>Message mMessages</code> 利用链表结构实现先进先出队列，确保先进入的消息先被处理。  </li>
<li>存储简单数据<br>成员变量 <code>arg1, arg2</code> 用来存储简单整型数据。  </li>
<li>存储复杂数据<br>成员变量 <code>Object obj, Bundle data</code> 用来存储复杂数据，其中 <code>Bundle</code> 能够存放键值对。  </li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息唯一标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="comment">// 存储简单数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="comment">// Messenger 用于跨进程通信</span></span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储复杂数据，可以通过 get/set Data 来设置</span></span><br><span class="line">    <span class="comment">/*package*/</span> Bundle data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bundle <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> Bundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bundle <span class="title">peekData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Bundle data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息池是单向链表，最大长度为 50</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，但是强烈推荐使用 Obtain 来获取</span></span><br><span class="line">    <span class="comment">// Obtain 会通过消息池来重复使用 Message</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息回收，重置当前消息，并进入消息池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>; arg1 = <span class="number">0</span>; arg2 = <span class="number">0</span>; obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>; sendingUid = -<span class="number">1</span>; when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>; callback = <span class="keyword">null</span>; data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息投递的绝对时间</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">long</span> when;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWhen</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> when;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// target 通常保存处理该消息的 Handler</span></span><br><span class="line">    <span class="comment">/*package*/</span> Handler target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果消息中定义了 callback</span></span><br><span class="line">    <span class="comment">// Handler 在处理消息时，直接回调该 callback，不会再执行 handleMessage</span></span><br><span class="line">    <span class="comment">/*package*/</span> Runnable callback;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">getCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息标识</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// 是否正在使用</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="function"><span class="keyword">void</span> <span class="title">markInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flags |= FLAG_IN_USE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否为异步消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span> <span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息对象浅拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span> <span class="params">(Message o)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// Parcelable 相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Message&gt; CREATOR</span><br><span class="line">            = <span class="keyword">new</span> Parcelable.Creator&lt;Message&gt;() &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速查看 <a href="https://developer.android.com/reference/android/os/Message" target="_blank" rel="noopener">Message API</a> 。  </p>
<h3 id="消息池-sPool"><a href="#消息池-sPool" class="headerlink" title="消息池 sPool"></a>消息池 <code>sPool</code></h3><p><code>Message</code> 中使用了单向链表结构的消息池，<code>sPool</code> 总是指向链表顶部，所以这个链表模拟的是栈结构，即消息池的数据结构为链表实现的栈。  </p>
<ul>
<li>消息池的创建<br>源码中可以看出，消息在被回收后 <code>recycleUnchecked()</code>，将当前消息加入到消息池链表中，即消息池才开始有可以重复利用的 <code>Message</code> ；创建消息池使用了 <code>synchronized</code> 关键字，确保线程池的操作是同步的。如果系统中，同时有很多消息在被传递，当一部分消息使用结束后都会被回收，此时消息池会积蓄的越来越多。  </li>
<li>消息的重复利用<br>创建消息时推荐使用 <code>Message.obtain()</code> 方式，因为每次 <code>obtain</code> 时，都会判断消息池中是否有可以循环利用的消息，如果存在则取出并清空消息标记，否则才新建一个消息。  </li>
</ul>
<blockquote>
<p>实例化一个消息，请使用 <code>Message.obtain()</code> ，充分利用消息池循环利用的特点。  </p>
</blockquote>
<h3 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h3><ul>
<li><code>long when</code><br>消息投递的绝对时间（投递时当前时间+设置的延迟时间），在 <code>Handler</code> 发送消息或发布任务时，指定具体的值。<code>MessageQueue</code> 在消息加入队列时，会根据 <code>when</code> 值决定消息在队列中的顺序。  </li>
<li><code>Handler target</code><br>保存处理该消息的 <code>Handler</code> ，在 <code>Handler.enqueueMessage()</code> 中将 <code>Message</code> 和对应处理该消息的 <code>Handler</code> 关联起来。  </li>
<li><code>Runnable callback</code><br>在 <code>Handler.java</code> 的分析中得出结论：消息的处理有三个优先级，可以直接使用 <code>Message.callback</code> 来进行消息处理。  </li>
</ul>
<h3 id="消息标识-flags"><a href="#消息标识-flags" class="headerlink" title="消息标识 flags"></a>消息标识 <code>flags</code></h3><p>成员变量 <code>flags</code> 有如下四个值：  </p>
<ul>
<li>0<br>消息标识清除。表示该消息被创建 <code>new Message()</code>、或者是从消息池中新取出的 <code>Message.obtain()</code>。可以理解是一个新消息，能修改当前消息内容。  </li>
<li><code>FLAG_IN_USE</code><br>消息正在被使用。表示消息进入了消息池栈 <code>sPool</code>中、或者进入了消息队列 <code>MessageQueue</code> 中。在消息池中，表示被回收了的消息正在被消息池管理，可以被取出循环利用；在消息队列中，表示消息被投递，正等待被取出处理。  </li>
<li><code>FLAG_ASYNCHRONOUS</code><br>表示异步消息；消息默认都是同步的，只能在 <code>Message</code> 和 <code>Handler</code> 构造方法中，特别指定为异步消息。如果设置了同步屏障，异步消息优先级将高于同步消息；消息队列 <code>MessageQueue.next()</code> 在取出消息时，遇到同步屏障会暂停所有的同步消息，将异步消息取出并处理，直到移除同步屏障。所以异步消息通常和同步屏障配合使用，同步屏障详细分析见 <code>MessageQueue</code> 中的分析。  </li>
<li><code>FLAGS_TO_CLEAR_ON_COPY_FROM</code><br>它的值和 <code>FLAG_IN_USE</code> 一样，只有在 <code>copyFrom()</code> 方法中会用到。  </li>
</ul>
<h3 id="Messenger-相关"><a href="#Messenger-相关" class="headerlink" title="Messenger 相关"></a><code>Messenger</code> 相关</h3><p><code>Message</code> 包含具体的数据信息，<code>Messenger</code> 是一名信差，用于进程间发送指定的 <code>Message</code> 。实质上 <code>Messenger</code> 使用 <code>AIDL</code> 和 <code>Handler</code> 机制来实现进程间的异步通信。详细参考<a href="https://redspider110.github.io/2017/11/29/0034-messenger/">Messenger 详解</a> 。    </p>
<ul>
<li><code>Messenger replyTo</code><br>回复此消息的回调信差，跨进程时通信时，可以利用 <code>Message</code> 中携带的信差，完成消息回复。  </li>
<li><code>sendingUid</code><br>跨进程发送异步消息的进程 <code>ID</code> 。  </li>
</ul>
<h2 id="Looper-详解"><a href="#Looper-详解" class="headerlink" title="Looper 详解"></a><code>Looper</code> 详解</h2><p><code>Looper</code> 类设计原则：此类包含基于 <code>MessageQueue</code> 设置和管理事件循环所需的代码。影响队列状态的 <code>API</code> 应该在 <code>MessageQueue, Handler</code> 上定义，而不是在 <code>Looper</code> 本身上定义。例如在队列上定义 <code>idle handlers</code> 和 <code>sync barriers</code>，而在 <code>Looper</code> 上定义准备线程，循环和退出。<br><code>Looper</code> 类的主要功能：  </p>
<ul>
<li>提供线程上下文环境，创建与线程绑定的 <code>Looper</code>  </li>
<li>创建 <code>MessageQueue</code>  </li>
<li><code>loop</code> 循环从 <code>MessageQueue</code> 中获取下一条消息（若无消息线程阻塞等待），指派 <code>Handler</code> 处理消息并回收消息  </li>
<li>提供 <code>loop</code> 循环退出方法  </li>
</ul>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Looper</code> 类中大部分都是 <code>static</code> 的变量和方法，不能直接实例化，通常都是固定格式来初始化。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Looper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal=<span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">    ...    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Returns the application's main looper, </span></span><br><span class="line">    <span class="comment">// which lives in the main thread of the application.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> <span class="function">MessageQueue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myLooper().mQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"..."</span>);&#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 线程会阻塞</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            ...</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            ...</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速查看 <a href="https://developer.android.com/reference/android/os/Looper" target="_blank" rel="noopener">Looper API</a> 。  </p>
<h3 id="重要成员变量-1"><a href="#重要成员变量-1" class="headerlink" title="重要成员变量"></a>重要成员变量</h3><ul>
<li><code>sThreadLocal</code><br>结论：一个线程只能对应一个 <code>Looper</code> 。从源码中可以看到，静态变量 <code>sThreadLocal</code> 存储了所有线程对应的 <code>Looper</code> ，而 <code>ThreadLocal</code> 中数据存储的数据结构是一个定制的哈希表，其 <code>key</code> 值是当前线程。  </li>
<li><code>sMainLooper</code><br>当前应用主线程对应的 <code>Looper</code> ，在应用对应的主线程 <code>ActivityThread.main()</code> 中初始化。通常我们在 <code>Activity</code> 中获取到的主线程 <code>Looper</code> 对应的就是 <code>sMainLooper</code> 。  </li>
</ul>
<h3 id="Looper-的初始化"><a href="#Looper-的初始化" class="headerlink" title="Looper 的初始化"></a><code>Looper</code> 的初始化</h3><p>代码中可以看到，<code>Looper</code> 的构造方法是私有的，客户端通常使用 <code>Looper.prepare(...)</code> 来实例化，并初始化应用场景。而 <code>Looper.prepareMainLooper()</code> 是用来初始化主线程环境的，整个 <code>Android Framework</code> 中只有 <code>ActivityThread, SystemServer</code> 这两个带有 <code>main()</code> 方法的类调用过，而这两个类分别用来开启应用主线程和系统主线程。<br><code>Looper</code> 的构造方法中，初始化了 <code>mQueue</code> 和 <code>mThread</code> ：  </p>
<ul>
<li><code>mQueue</code><br><code>Handler</code> 机制的消息队列 <code>MessageQueue</code> 就是在 <code>Looper</code> 的构造方法中实例化的。  </li>
<li><code>mThread</code><br>赋值的是当前线程：可以是主线程或者工作线程。  </li>
</ul>
<h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a><code>Looper.loop()</code></h3><p>流程非常简单，进入无限循环并不停的从消息队列中获取消息，而获取消息的过程可能会阻塞。 <code>Looper</code> 线程拿到消息后，执行消息处理 <code>Handler.dispatchMessage()</code> 并回收已经处理过的消息 <code>Message.recycleUnchecked()</code> 。  </p>
<h3 id="Looper-退出"><a href="#Looper-退出" class="headerlink" title="Looper 退出"></a><code>Looper</code> 退出</h3><p><code>Looper</code> 通常是通过 <code>Looper.loop()</code> 进入无线循环，从消息队列中取出消息并处理。<code>Handler</code> 机制为工作线程提供了退出方法 <code>quit/quitSafely</code> ，调用 <code>MessageQueue.quit()</code> 来结束并退出。只要调用了 <code>quit/quitSafely</code>，不管是正在退出还是已经退出，<code>Looper</code> 就不再接收新的消息。<code>Handler</code> 发送的消息，在 <code>MessageQueue.enqueueMessage</code> 中直接返回 <code>false</code>，不做任何处理。  </p>
<blockquote>
<p>主线程的 <code>Looper</code> 是不允许退出的，在 <code>MessageQueue</code> 的构造方法中设定。<code>prepareMainLooper</code> 调用的是 <code>prepare(false)</code>，即不能退出。  </p>
</blockquote>
<h3 id="典型工作线程流程"><a href="#典型工作线程流程" class="headerlink" title="典型工作线程流程"></a>典型工作线程流程</h3><p><code>Looper</code> 线程典型的实现示例如下，将 <code>prepare()</code> 和 <code>loop()</code> 的分离，来创建一个与 <code>Looper</code> 通信的 <code>Handler</code>。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Handler-详解"><a href="#Handler-详解" class="headerlink" title="Handler 详解"></a><code>Handler</code> 详解</h2><p><code>Handler</code> 子类必须是 <code>static</code> 的，避免潜在的内存泄露，在构造方法中可以打开开关做检测。<br><code>Handler</code> 类将 <code>Message, Looper, MessageQueue</code> 串起来，给外部提供完整的接口，发送并处理消息。它管理的消息队列 <code>MessageQueue</code> 是 <code>Looper</code> 的成员变量；而 <code>Looper</code> 可以是主线程，也可以是工作线程，在 <code>Handler</code> 初始化时指定。主要功能包含：  </p>
<ul>
<li>初始化一个消息  </li>
<li>发布任务或者发送消息  </li>
<li>回到 <code>Looper</code> 所在线程处理消息  </li>
<li>移除消息或其回调  </li>
</ul>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Looper mLooper;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Callback mCallback;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Subclasses must implement this to receive messages.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息处理入口，三个优先级：</span></span><br><span class="line">    <span class="comment">// 1. 如果 Message 中定义了 Callback，直接处理</span></span><br><span class="line">    <span class="comment">// 2. 否则如果 Handler 中定义了 Callback，调用处理</span></span><br><span class="line">    <span class="comment">// 3. 最后才是子类重写的 handleMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法，最终都是初始化 4 个成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;<span class="keyword">this</span>(callback, <span class="keyword">false</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;<span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;<span class="keyword">this</span>(<span class="keyword">null</span>, async);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查子类实例化时，是否存在内存泄露</span></span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() </span><br><span class="line">                    || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static "</span> + </span><br><span class="line">                    <span class="string">"or leaks might occur: "</span> + klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside "</span> + </span><br><span class="line">                <span class="string">" thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成对应的消息 Message，但都是对 Message.obtain 的封装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2, obj);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.obj = token;</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布任务，最终都是调用的 enqueueMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what,<span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what,<span class="keyword">long</span> uptimeMillis)</span></span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis()+delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Message 和 Handler 关联</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            <span class="comment">// 设置异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除 Message 和 Messa.callback，最终都是在 MessageQueue 中移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">        mQueue.removeMessages(<span class="keyword">this</span>, r, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r, Object token)</span></span>&#123;</span><br><span class="line">        mQueue.removeMessages(<span class="keyword">this</span>, r, token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">        mQueue.removeMessages(<span class="keyword">this</span>, what, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">        mQueue.removeMessages(<span class="keyword">this</span>, what, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span> </span>&#123;</span><br><span class="line">        mQueue.removeCallbacksAndMessages(<span class="keyword">this</span>, token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Messenger 相关</span></span><br><span class="line">    IMessenger mMessenger;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mMessenger;</span><br><span class="line">            &#125;</span><br><span class="line">            mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">            Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻塞，同步执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"runnable must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"timeout must be non-negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">        <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mDone;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlockingRunnable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mTask.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mDone = <span class="keyword">true</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis()</span><br><span class="line">                        + timeout;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">long</span> delay = expirationTime </span><br><span class="line">                            - SystemClock.uptimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(delay);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速查看 <a href="https://developer.android.com/reference/android/os/Handler" target="_blank" rel="noopener">Handler API</a> 。  </p>
<h3 id="构造方法及成员变量"><a href="#构造方法及成员变量" class="headerlink" title="构造方法及成员变量"></a>构造方法及成员变量</h3><p>从 <code>Handler</code> 的构造方法可以看出来，实例化时主要对 <code>Looper, MessageQueue, Callback, mAsynchronous</code> 四个成员变量的赋值。</p>
<ul>
<li><code>Looper</code><br><code>Looper</code> 如果来自于主线程，则不需要通过构造方法赋值；如果来自于工作线程，需要先执行 <code>Looper.prepare</code> 初始化 <code>Looper</code> 使用环境，并作为参数传递到构造方法中。  </li>
<li><code>MessageQueue</code><br><code>Looper</code> 值确定后，消息队列即为其成员变量 <code>mQueue</code> 。  </li>
<li><code>Callback</code><br>可以直接通过 <code>Callback</code> 处理消息事件；特别是不需要自定义 <code>Handler</code> 子类来重写 <code>handleMessage</code> 时，默认为 <code>null</code>。  </li>
<li><code>mAsynchronous</code><br>是否允许异步执行，默认值为 <code>false</code> 即是同步执行的。它最终会被设置到对应的 <code>Message.flags = FLAG_ASYNCHRONOUS</code>，在 <code>Handler</code> 中被没有其他作用。   </li>
</ul>
<p>自定义 <code>Handler</code> 的子类在实例化时，为了避免内存泄露，通常将子类设置为 <code>static</code> 类型，也就是避免内部类引用当前 <code>Activity</code> 对象。  </p>
<h3 id="生成消息"><a href="#生成消息" class="headerlink" title="生成消息"></a>生成消息</h3><p><code>Handler</code> 提供了生成消息的方法，但都是对 <code>Message.obtain</code> 的封装，所以在使用消息前，推荐直接使用 <code>Message</code> 类来生成。  </p>
<h3 id="任务发布"><a href="#任务发布" class="headerlink" title="任务发布"></a>任务发布</h3><p>不管是通过 <code>post***()</code> 还是 <code>send***()</code> 方法来发布任务或者消息，最终都是调用的 <code>enqueueMessage()</code>，即将 <code>Message</code> 加入到消息队列中 <code>MessageQueue</code> 。<code>enqueueMessage()</code> 的两个重要动作：  </p>
<ul>
<li><code>Handler</code> 和 <code>Message</code> 的关联<br><code>Message</code> 的成员变量 <code>target</code> 存储了处理该消息的 <code>Handler</code> ，在消息入队时，将两者关联起来。  </li>
<li>设置异步消息<br><code>Handler.mAsynchronous</code> 成员变量，在入队时将对应的 <code>Message</code> 设置为异步。  </li>
</ul>
<h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p><code>dispatchMessage</code> 是 <code>Handler</code> 消息处理的入口方法，有三个优先级来处理消息：  </p>
<ul>
<li>优先：如果 <code>Message</code> 中定义了 <code>Callback</code>  </li>
<li>其次：如果 <code>Handler</code> 中定义了 <code>Callback</code>  </li>
<li>最后：才是调用子类重写的 <code>handleMessage</code>  </li>
</ul>
<p>如果是自定义 <code>Handler</code> 子类，必须重写 <code>handleMessage</code> 来实现消息处理。而消息处理是在 <code>Looper</code> 所在线程来处理的，<code>Looper</code> 如果来自于主线程则在主线程中处理消息；如果来自于工作线程则在工作线程中处理消息。  </p>
<h3 id="移除消息"><a href="#移除消息" class="headerlink" title="移除消息"></a>移除消息</h3><p><code>remove***()</code> 系列的方法，是指移除 <code>Message</code> 或者 <code>Message.callback</code>；最终调用的是从 <code>MessageQueue</code> 中移除对应消息。  </p>
<h3 id="Messenger-相关-1"><a href="#Messenger-相关-1" class="headerlink" title="Messenger 相关"></a><code>Messenger</code> 相关</h3><p><code>Handler</code> 中实现了 <code>Messenger</code> 用于进程间异步通信的代码。源码中可以看出 <code>Messenger</code> 通过 <code>AIDL</code> 来实现的进程间通信的；而通过 <code>Handler.sendMessage</code> 来实现异步通信。详细参考<a href="https://redspider110.github.io/2017/11/29/0034-messenger/">Messenger 详解</a> 。  </p>
<h3 id="BlockingRunnable-阻塞并同步执行任务"><a href="#BlockingRunnable-阻塞并同步执行任务" class="headerlink" title="BlockingRunnable 阻塞并同步执行任务"></a><code>BlockingRunnable</code> 阻塞并同步执行任务</h3><p><code>BlockingRunnable</code> 同步等待指定任务执行完成才会返回，通过 <code>Object.wait/notify</code> 实现同步阻塞功能。<code>Handler.runWithScissors</code> 方法是具体的实现，它是一个 <code>@hide</code> 方法，客户端 <code>App</code> 并不能直接调用若。该方法是如果调用线程与 <code>Looper</code> 所在线程如果在同一个线程，直接执行完后退出；如果不是同一线程，可以简单的实现 <code>timeout</code>，方法调用以后会阻塞，直到传入的 <code>runnable</code> 结束或者是 <code>timeout</code> 。  </p>
<h2 id="MessageQueue-详解"><a href="#MessageQueue-详解" class="headerlink" title="MessageQueue 详解"></a><code>MessageQueue</code> 详解</h2><p><code>MessageQueue</code> 的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。采用单链表的数据结构来存储消息列表，按照消息发生的绝对时间 <code>Message.when</code> 排序。所以消息队列并不是绝对的先进先出队列，是按照消息发生时间先进先出。<code>Looper.loop</code> 会进入无限循环，而它会调用 <code>MessageQueue.next</code> 方法取出下一条消息；当有消息时，取出交给 <code>Handler</code> 处理；当没有消息时，当前线程便会阻塞在 <code>next()</code> 方法的 <code>nativePollOnce()</code> 中，当线程便会释放 <code>CPU</code> 资源进入休眠状态，直到下个消息到达或者有事务发生时，唤醒当前线程；这里的线程休眠唤醒，涉及到 <code>Linux epoll</code> 机制，后面会详细介绍。<br><code>MessageQueue</code> 是在多线程环境下操作，所以绝大部分的方法都使用了 <code>synchronized(this)</code> 关键字；是 <code>Handler</code> 机制的核心类，<code>native</code> 代码在 <code>android_os_MessageQueue.cpp</code> 中实现；<code>MessageQueue</code> 还能监听文件描述符，当发生变化时做出相应事件处理，但是 <code>Handler</code> 机制中并没有使用该功能，本文不做介绍。<br><code>MessageQueue</code> 主要功能：  </p>
<ul>
<li>初始化 <code>native</code> 环境  </li>
<li>将 <code>Message</code> 加入队列  </li>
<li>调用 <code>native</code> 方法，当前线程阻塞等待，直到从队列中取出 <code>Message</code>  </li>
<li>多线程环境中维护消息队列入队、出队、销毁  </li>
</ul>
<h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// True if the message queue can be quit.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mQuitting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    Message mMessages;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers </span><br><span class="line">        = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">    <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicates whether next() is blocked waiting </span></span><br><span class="line">    <span class="comment">// in pollOnce() with a non-zero timeout.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed = quitAllowed;</span><br><span class="line">        mPtr = nativeInit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Must only be called on the looper thread or the finalizer.</span></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeDestroy(mPtr);</span><br><span class="line">            mPtr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程 Idle 状态时，相关方法和接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> mMessages == <span class="keyword">null</span> || now &lt; mMessages.when;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't add a null IdleHandler"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.add(handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程是否在轮询获取下条消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPolling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPollingLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPollingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the loop is quitting then it must not be idling.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">return</span> !mQuitting &amp;&amp; nativeIsPolling(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否存在指定条件的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.target == h &amp;&amp; p.what == what &amp;&amp; </span><br><span class="line">                    (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMessages</span><span class="params">(Handler h, Runnable r, Object object)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除指定消息或整个消息队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all messages at front.</span></span><br><span class="line">            <span class="comment">// 如果消息队列头结点或者头部几个节点，就是目标消息</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">                   &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                mMessages = n;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all messages after front.</span></span><br><span class="line">            <span class="comment">// 遍历整个队列，找到目标消息移出队列并回收</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                        &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                        Message nn = n.next;</span><br><span class="line">                        n.recycleUnchecked();</span><br><span class="line">                        p.next = nn;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, Runnable r, Object object)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Handler h, Object object)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllMessagesLocked</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllFutureMessagesLocked</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息队列退出循环</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否允许退出？主线程 Looper 是不允许退出的，工作线程可以</span></span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经正在退出了返回</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是安全退出，只移除没有投递和处理的消息</span></span><br><span class="line">            <span class="comment">// 已经投递的等待处理完毕</span></span><br><span class="line">            <span class="comment">// 非安全退出，移除所有消息</span></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//We can assume mPtr!=0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置和移除同步屏障</span></span><br><span class="line">    <span class="comment">// The next barrier token.</span></span><br><span class="line">    <span class="comment">// Barriers are indicated by messages with a null target </span></span><br><span class="line">    <span class="comment">// whose arg1 field carries the token.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNextBarrierToken;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">        <span class="comment">// We don't need to wake the queue </span></span><br><span class="line">        <span class="comment">// because the purpose of a barrier is to stall it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">            <span class="comment">// 同步屏障消息 target 为空，arg1 保存令牌</span></span><br><span class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="comment">// 同步屏障消息是插入到队列头部的，优先级高</span></span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"The specified message queue synchronization barrier token"</span></span><br><span class="line">                + <span class="string">" has not been posted or has already been removed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 移除同步屏障</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回收同步屏障</span></span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息入队  </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 为空，表示是同步屏障；不能直接入队，需要通过 postSyncBarrie 插入队列头部</span></span><br><span class="line">      <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// FLAG_IN_USE，表示消息已经在消息池或者消息队列中</span></span><br><span class="line">      <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + </span><br><span class="line">              <span class="string">" This message is already in use."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果消息队列正在退出，直接回收当前消息并返回</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">          IllegalStateException e = <span class="keyword">new</span> IllegalStateException(msg.target</span><br><span class="line">                + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">          <span class="comment">// 消息队列为空，或者没有设置消息绝对时间</span></span><br><span class="line">          <span class="comment">// 或者新消息绝对时间最小：将当前消息插入到队首</span></span><br><span class="line">          <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">          msg.next = p;</span><br><span class="line">          mMessages = msg;</span><br><span class="line">          needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 消息队列阻塞情况下，并且队首为同步屏障</span></span><br><span class="line">          <span class="comment">// 并且当前消息为异步消息，则唤醒队列</span></span><br><span class="line">          needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">          Message prev;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              prev = p;</span><br><span class="line">              p = p.next;</span><br><span class="line">              <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 消息队列中还存在其他异步消息，不唤醒</span></span><br><span class="line">              <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                  needWake = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 按照消息绝对时间排序，插入到指定位置</span></span><br><span class="line">          msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">          prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 唤醒消息队列</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出消息</span></span><br><span class="line">    <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// native 变量地址为空，直接返回</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">      <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 无限循环等待</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 线程阻塞前写入所有命令</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待 nextPollTimeoutMillis 时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">          Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">          Message msg = mMessages;</span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 消息队列队首为同步屏障，挂起所有同步消息</span></span><br><span class="line">              <span class="comment">// 循环取出所有异步消息</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  prevMsg = msg;</span><br><span class="line">                  msg = msg.next;</span><br><span class="line">              &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">          &#125;          </span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                  <span class="comment">// 下一条消息时间还没到</span></span><br><span class="line">                  <span class="comment">// 设置 nextPollTimeoutMillis 为消息延迟时间</span></span><br><span class="line">                  nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when </span><br><span class="line">                      - now, Integer.MAX_VALUE);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// Got a message. 获取一条消息并返回</span></span><br><span class="line">                  mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      prevMsg.next = msg.next;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      mMessages = msg.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  msg.next = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                  msg.markInUse();</span><br><span class="line">                  <span class="keyword">return</span> msg;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// No more messages. 消息队列为空</span></span><br><span class="line">              nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 消息队列正在退出，释放资源并返回空</span></span><br><span class="line">          <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">              dispose();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 没有空闲处理器 IdleHandler，初始化计数</span></span><br><span class="line">          <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                  &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">              pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 还是没有空闲处理器 IdleHandler，</span></span><br><span class="line">          <span class="comment">// 标记消息队列阻塞，进入下一次循环</span></span><br><span class="line">          <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              mBlocked = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 初始化并设置 IdleHandler</span></span><br><span class="line">          <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">              mPendingIdleHandlers = </span><br><span class="line">                <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">          &#125;</span><br><span class="line">          mPendingIdleHandlers=mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用这段空闲时间，线程处理 IdleHandler 任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">          mPendingIdleHandlers[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              keep = idler.queueIdle();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                  mIdleHandlers.remove(idler);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置空闲任务计数和阻塞超时时间</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPolling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPollingLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPollingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !mQuitting &amp;&amp; nativeIsPolling(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听文件描述符相关，本文不做介绍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOnFileDescriptorEventListener</span><span class="params">(@NonNull FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">            @OnFileDescriptorEventListener.Events <span class="keyword">int</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull OnFileDescriptorEventListener listener)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOnFileDescriptorEventListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull FileDescriptor fd)</span> </span>&#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateOnFileDescriptorEventListenerLocked</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> events, OnFileDescriptorEventListener listener)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// Called from native code.处理文件描述事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dispatchEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnFileDescriptorEventListener</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@Events</span> <span class="function"><span class="keyword">int</span> <span class="title">onFileDescriptorEvents</span><span class="params">(@NonNull FileDescriptor fd, </span></span></span><br><span class="line"><span class="function"><span class="params">            @Events <span class="keyword">int</span> events)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptorRecord</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// native 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">     <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速查看 <a href="https://developer.android.com/reference/android/os/MessageQueue" target="_blank" rel="noopener">MessageQueue API</a>  </p>
<h3 id="重要成员变量-2"><a href="#重要成员变量-2" class="headerlink" title="重要成员变量"></a>重要成员变量</h3><ul>
<li><code>mMessages</code><br>用于存储消息，利用 <code>Message</code> 链表结构实现先进先出队列，确保先进入或者时间最近的消息先被处理。  </li>
<li><code>ArrayList mIdleHandlers</code><br>记录消息队列中有多少个 <code>IdleHandler</code> 。  </li>
<li><code>IdleHandler[] mPendingIdleHandlers</code><br>由 <code>mIdleHandlers</code> 转换为对应的数组。  </li>
<li><code>mBlocked</code><br>当 <code>next</code> 方法在等待 <code>pollOnce</code> ，<code>mBlocked</code> 记录 <code>next</code> 是否处于阻塞状态。  </li>
<li><code>mQuitting</code><br>记录当前消息队列是否正在退出。  </li>
<li><code>mNextBarrierToken</code><br>同步屏障令牌，同步屏障 <code>Barriers</code> 表示一个没有指定 <code>Handler</code> 的 <code>Message</code>，它的 <code>arg1</code> 参数记录了这个令牌。  </li>
<li><code>mFileDescriptorRecords</code><br>存储被监听文件描述符的表，<code>Handler</code> 机制中消息发送并没有使用文件描述符监功能，暂时不做介绍。<code>AOSP</code> 系统源码中仅 <code>frameworks/base/core/java/android/os/ParcelFileDescriptor.java</code> 用到了。  </li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>Handler</code> 机制中，<code>MessageQueue</code> 的实例化是在 <code>Looper</code> 的构造方法中实现的，赋值两个成员变量：  </p>
<ul>
<li><code>mQuitAllowed</code><br>是否运行消息队列退出。主线程的消息队列是不允许退出的，工作线程可以。  </li>
<li><code>mPtr</code><br>执行 <code>nativeInit</code> 方法，并将 <code>native</code> 层的 <code>NativeMessageQueue</code> 类对象地址赋值给 <code>Java</code> 层的成员变量 <code>mPtr</code> 。通过这种方式将 <code>Java</code> 层的对象与 <code>native</code> 层的对象关联在了一起。这种在 <code>Java</code> 层保存 <code>native</code> 层对象引用地址来实现关联的方式，在 <code>Android</code> 源代码中能经常看到。  </li>
</ul>
<h3 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h3><p>同步屏障 <code>SyncBarrier</code> 是一个特殊的消息 <code>Message</code> ，有两个重要特点：  </p>
<ul>
<li><code>Handler target</code> 为空  </li>
<li><code>arg1</code> 记录同步屏障令牌<br>同步屏障消息的 <code>what</code> 为空，也就是不能通过 <code>what</code> 来标记消息了，而通过 <code>arg1</code> 记录同步令牌来做为消息标记。令牌非常重要，移除同步屏障时需要指定具体的令牌。  </li>
</ul>
<p>如果设置了同步屏障，消息队列所有的同步消息都会被暂停，<code>next()</code> 只会取出异步消息处理，直到移除同步屏障。如果没有正确移除同步屏障，整个消息队列将会挂起，同时也不再循环取出同步消息执行。  </p>
<ul>
<li>设置同步屏障<br><code>postSyncBarrier()</code> 设置同步屏障时，将它加入到消息队列，并将同步屏障消息设为头结点。也就是同步屏障是插入到队列的头部的，优先级很高，消息通过 <code>enqueueMessage</code> 加入队列都是插入队尾的。设置同步屏障并不会唤醒队列。  </li>
<li>移除同步屏障<br><code>removeSyncBarrier(int token)</code> 根据令牌移除同步屏障，遍历消息队列。如果同步屏障位于头结点，且下一条消息为同步消息，表示队列没有被被挂起，唤醒队列。移除同步屏障后，消息队列恢复正常，循环取出消息。  </li>
</ul>
<p>同步屏障相关方法都是 <code>@hide</code> 的，也就是说只会在 <code>Android Framework</code> 内部使用，客户端 <code>App</code> 并不能应用这些功能。并且同步屏障和异步消息在 <code>Android Framework</code> 中使用的也很少，比如搜索到的应用如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">xmt<span class="meta">@server</span>005:~/android$ grep -irsn postSyncBarrier frameworks/</span><br><span class="line">frameworks/base/cmds/hid/src/com/android/commands/hid/Device.java:<span class="number">143</span>:        </span><br><span class="line">mBarrierToken = getLooper().myQueue().postSyncBarrie ();</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/view/ViewRootImpl.java:<span class="number">1225</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(InputEvent event, </span></span></span><br><span class="line"><span class="function"><span class="params">    InputEventReceiver receiver)</span> </span>&#123;</span><br><span class="line">    SomeArgs args = SomeArgs.obtain();</span><br><span class="line">    args.arg1 = event;</span><br><span class="line">    args.arg2 = receiver;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args);</span><br><span class="line">    <span class="comment">// 设置为异步消息</span></span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">    mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 设置同步屏障</span></span><br><span class="line">    mTraversalBarrier=mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">    mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">        scheduleConsumeBatchedInput();</span><br><span class="line">    &#125;</span><br><span class="line">    notifyRendererOfFramePending();</span><br><span class="line">    pokeDrawLockIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android</code> 系统的屏幕点击事件，就是一个异步消息；<code>View</code> 请求启动绘制生命周期 <code>ViewRootImpl.scheduleTraversals</code> 会设置同步屏障，优先处理异步消息。  </p>
<h3 id="消息入队-enqueueMessage"><a href="#消息入队-enqueueMessage" class="headerlink" title="消息入队 enqueueMessage"></a>消息入队 <code>enqueueMessage</code></h3><p>后台线程完成耗时操作后，通过对象 <code>Handler.post***/send***</code> 发送消息，最终会进入到 <code>MessageQueue.enqueueMessage</code> ，而 <code>enqueueMessage</code> 仅仅是将消息按照 <code>when</code> 顺序插入到消息队列中。后台线程不会被阻塞，执行完毕可以退出。  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-messagequeue-equeuemessage.png" alt="0023-handler-messagequeue-equeuemessage.png"></p>
<ul>
<li>入队顺序 <code>Message.when</code><br>按照消息的绝对时间 <code>Message.when</code> 排序，插入到队列中，如果时间相同就按照入队先后顺序。确保消息投递的绝对时间 <code>when</code> 越小，越早出队。  </li>
<li>唤醒队列 <code>needWake</code><br>如果消息队列处于阻塞状态 <code>mBlocked=true</code> 时，插入消息时才需要唤醒队列。但是当消息队列队首为同步屏障，并且新消息本身为异步消息，同时当消息队列中还存在其他异步消息时，此时不会唤醒，具体看上面的流程图。消息插入消息队列，正常情况下不会唤醒，除了图中的几个特殊情况。    </li>
<li>消息队列正在退出 <code>mQuitting</code><br>如果消息队列调用了 <code>quit()</code> 方法，表示消息队列正在退出；当消息队列正在退出时，直接回收当前准备入队的消息，并返回 <code>false</code> ，入队失败。  </li>
</ul>
<h3 id="消息队列存储顺序"><a href="#消息队列存储顺序" class="headerlink" title="消息队列存储顺序"></a>消息队列存储顺序</h3><p>消息队列中，首先按照 <code>msg.when</code> 排序，结合同步屏障，异步消息，后期补一个图。  </p>
<h3 id="消息出队-next"><a href="#消息出队-next" class="headerlink" title="消息出队 next"></a>消息出队 <code>next</code></h3><p>主线程的 <code>Looper.loop()</code> 会无限循环，不停的调用 <code>MessageQueue.next()</code> 获取下一条消息，交给 <code>Handler</code> 处理。而 <code>next</code> 通过 <code>nativePollOnce</code> 方法实现线程的阻塞，阻塞时间为消息的延迟时间。当时间到了后，唤醒主线程取出这个消息；即后台线程发布的消息，回到主线程来处理。    </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-messagequeue-next.png" alt="0023-handler-messagequeue-next.png"></p>
<ul>
<li>阻塞时间 <code>nextPollTimeoutMillis</code><br>表示阻塞时间，通常为消息的延迟时间。如果为 0 ，表示不阻塞，直接返回；如果为 -1 ，表示一直阻塞。当消息队列中没有消息时，<code>nextPollTimeoutMillis=-1</code> 使得 <code>next</code> 会一直阻塞，直到有消息进来，更新这个值。  </li>
<li>阻塞状态 <code>mBlocked</code><br><code>next</code> 中的 <code>for</code> 循环取到消息后，<code>next</code> 返回这个消息并退出，消息队列阻塞状态为 <code>false</code> ；<code>for</code> 循环没有取到消息，如果存在 <code>IdleHandler</code> 时，利用这段时间处理空闲任务；否则设置消息队列为阻塞状态 <code>true</code>；重新进入循环继续阻塞等待取消息。  </li>
<li>消息出队顺序<br>同步消息都是按照 <code>msg.when</code> 即插入顺序先进先出的；当消息队列队首为同步屏障时，挂起队列中所有同步消息，循环取出队列中所有的异步消息，直到移除同步屏障。  </li>
<li>消息队列正在退出 <code>mQuitting</code><br>如果消息队列调用了 <code>quit()</code> 方法，表示消息队列正在退出；当消息队列正在退出时，调用 <code>dispose()</code> 方法，销毁 <code>native</code> 环境，跳出 <code>Looper.loop</code> 循环，退出整个机制。  </li>
<li>空闲线程 <code>IdleHandler</code><br>当消息队列为空，或者消息投递时间没到时；如果添加了空闲线程处理器 <code>IdleHandler</code> ，此时会利用线程空闲时间执行这些任务。  </li>
</ul>
<h3 id="消息轮询状态"><a href="#消息轮询状态" class="headerlink" title="消息轮询状态"></a>消息轮询状态</h3><p><code>isPolling/isPollingLocked</code> 方法主要是否返回当前线程轮询状态，即当前线程是否处于 <code>epoll_wait</code> 阻塞等待中，该方法在 <code>Android Framework</code> 中使用的也很少：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/Watchdog.java:<span class="number">121</span>: </span><br><span class="line"><span class="keyword">if</span> (mMonitors.size() == <span class="number">0</span> &amp;&amp; mHandler.getLooper().getQueue().isPolling()) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><code>MessageQueue.mBlocked</code> 也是记录的阻塞状态，和 <code>isPolling/isPollingLocked</code> 功能差不多，只是没有 <code>isPolling/isPollingLocked</code> 方法返回的状态更精细、更准确。  </p>
<h3 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a>删除消息</h3><ul>
<li>删除指定消息<br>符合指定消息的可能并不止一个，所以需要遍历整个队列，找到这些符合条件的消息。删除时分两种情况：如果指定消息是头结点，或者头部几个节点都是指定消息，删除指定消息后，重新指定头结点；如果头结点或者新的头结点不是指定消息，依次遍历整个队列，找到目标消息移出队列并回收。  </li>
<li>删除所有消息<br>从头结点开始遍历队列，移出队列中所有消息并删除。  </li>
<li>删除延迟消息<br>从头结点开始遍历队列，对比当前时间和 <code>Message.when</code> ，找出延迟消息，删除掉这些还没来得及投递处理的消息。  </li>
</ul>
<h3 id="消息队列退出"><a href="#消息队列退出" class="headerlink" title="消息队列退出"></a>消息队列退出</h3><p><code>MessageQueue.quit()</code> 方法中有如下几个判断：  </p>
<ul>
<li>是否运行退出 <code>mQuitAllowed</code><br>主线程的 <code>Looper</code> 循环是不允许退出的，这在主线程初始化时，构造 <code>MessageQueue</code> 决定的；工作线程可以退出。  </li>
<li>是否正在退出 <code>mQuitting</code><br>因为是多线程环境，所以使用了 <code>synchronized</code> 关键字来确保并发正确。  </li>
<li>是否安全移除 <code>safe</code><br>是否安全移除，主要区别在于移除哪些消息。如果不安全退出，直接移除队列中所有消息；如果安全退出，对比当前时间和 <code>Message.when</code> ，只移除延迟消息。  </li>
</ul>
<p><code>MessageQueue.quit()</code> 方法主要是移除消息队列中对应的消息，并设置了 <code>mQuitting=true</code> ；调用 <code>nativeWake()</code> 方法唤醒 <code>next()</code> 方法，如果是安全退出，则取出剩余的消息并返回给 <code>Handler</code> 处理；<code>next</code> 方法中如果取不到消息，当 <code>mQuitting=true</code> 时，释放资源并退出整个 <code>Looper.loop()</code> 循环机制。  </p>
<h3 id="IdleHandler-接口"><a href="#IdleHandler-接口" class="headerlink" title="IdleHandler 接口"></a><code>IdleHandler</code> 接口</h3><p>一个回调接口，在<strong>消息队列阻塞等待前</strong>，当前线程可以利用这段时间做别的事情。  </p>
<ul>
<li><code>MessageQueue.addIdleHandler()</code><br>添加回调接口。  </li>
<li><code>MessageQueue.removeIdleHandler()</code><br>移除回调接口。  </li>
<li>示例<br>比如 <code>ActivityThread</code> 中，利用这个空闲时间，添加了 <code>GcIdle</code> 回收内存和 <code>Idler</code> 释放 <code>AMS</code> 相关资源。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.内存回收</span></span><br><span class="line">Looper.myQueue().addIdleHandler(mGcIdler);</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GcIdler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doGcIfNeeded();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doGcIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mGcIdlerScheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//Slog.i(TAG, "**** WE MIGHT WANT TO GC: then=" + </span></span><br><span class="line">    <span class="comment">//       Binder.getLastGcTime() + "m now=" + now);</span></span><br><span class="line">    <span class="keyword">if</span> ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) &lt; now) &#123;</span><br><span class="line">        <span class="comment">//Slog.i(TAG, "**** WE DO, WE DO WANT TO GC!");</span></span><br><span class="line">        BinderInternal.forceGc(<span class="string">"bg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. AMS 释放相关资源，调用 activityIdle</span></span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord a = mNewActivities;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">      IActivityManager am = ActivityManagerNative.getDefault();</span><br><span class="line">      ActivityClientRecord prev;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">              a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          prev = a;</span><br><span class="line">          a = a.nextIdle;</span><br><span class="line">          prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="native-方法"><a href="#native-方法" class="headerlink" title="native 方法"></a><code>native</code> 方法</h3><p>简要描述几个 <code>native</code> 方法的作用：  </p>
<ul>
<li><code>private native static long nativeInit();</code> ：初始化 <code>native</code> 对象，绑定 <code>Looper</code> 和线程等  </li>
<li><code>private native static void nativeDestroy(long ptr);</code> 销毁 <code>native</code> 对象  </li>
<li><code>private native void nativePollOnce(long ptr, int timeoutMillis);</code><br>唯一的非静态方法，也就是说这个方法是属于对象的；当前线程阻塞最多等待 <code>timeoutMillis</code> 时间（类似 <code>Object.wait(timeout)</code>），这段时间内可能会被 <code>nativeWake</code> 唤醒。  </li>
<li><code>private native static void nativeWake(long ptr);</code> 唤醒 <code>nativePollOnce</code> 函数  </li>
<li><code>private native static boolean nativeIsPolling(long ptr);</code> 查询 <code>nativePollOnce</code> 是否正处于阻塞状态  </li>
<li><code>private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</code> 添加文件描述符监听事件  </li>
</ul>
<h2 id="Native-JNI-层"><a href="#Native-JNI-层" class="headerlink" title="Native JNI 层"></a><code>Native JNI</code> 层</h2><p><code>Native JNI</code> 层起到一个连接的作用，<code>Handler</code> 机制中使用的 <code>epoll</code> 等功能都是在系统层实现的，<code>JNI</code> 对这些功能调用做一个封装，相当于外观模式中的外观类。注意：<code>Android Framework</code> 中还有一个 <code>ALooper</code> 类，也是实现的消息机制，它主要是用于多媒体相关，代码路径 <code>frameworks/av/media/</code> ，和本文介绍的消息机制没有任何关系。<br>如下根据 <code>MessageQueue</code> 中的 6 个 <code>native</code> 方法逐一展开分析，具体对应的 <code>JNI</code> 类为 <code>Android_os_MessageQueue.cpp</code> ：  </p>
<h3 id="环境初始化-nativeInit"><a href="#环境初始化-nativeInit" class="headerlink" title="环境初始化 nativeInit"></a>环境初始化 <code>nativeInit</code></h3><p><code>nativeInit</code> 函数主要是初始化所有 <code>native</code> 需要使用的类对象，变量等，主要就是 <code>Looper.cpp</code> 相关资源的初始化；函数的返回值是一个 <code>nativeMessageQueue</code> 对象，它是对 <code>Looper.cpp</code> 相关功能的一个封装。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NativeMessageQueue 对象实例化</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Looper 对象初始化，及线程绑定和相关环境初始化</span></span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// TLS 保存当前线程的 Looper 对象</span></span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMessageQueue</span> :</span> <span class="keyword">public</span> MessageQueue, <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NativeMessageQueue();</span><br><span class="line">    <span class="keyword">virtual</span> ~NativeMessageQueue();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">raiseException</span><span class="params">(JNIEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span>* msg, jthrowable exceptionObj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pollOnce</span><span class="params">(JNIEnv* env, jobject obj, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFileDescriptorEvents</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    JNIEnv* mPollEnv;</span><br><span class="line">    jobject mPollObj;</span><br><span class="line">    jthrowable mExceptionObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="销毁-nativeDestroy"><a href="#销毁-nativeDestroy" class="headerlink" title="销毁 nativeDestroy"></a>销毁 <code>nativeDestroy</code></h3><p><code>native</code> 中的几个关键对象，都使用了智能指针管理，所以销毁时减少引用计数，如果引用不存在自动销毁。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeDestroy</span><span class="params">(JNIEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">        jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = </span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    nativeMessageQueue-&gt;decStrong(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数是空的</span></span><br><span class="line">NativeMessageQueue::~NativeMessageQueue() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="轮询-nativePollOnce"><a href="#轮询-nativePollOnce" class="headerlink" title="轮询 nativePollOnce"></a>轮询 <code>nativePollOnce</code></h3><p>唯一的非静态方法，也就是说这个方法是属于对象的，因为每个对象可以处理自己的回调。<code>Handler</code> 机制的核心，<code>nativePollOnce</code> 调用了 <code>epoll</code> 中的 <code>epoll_wait</code> 方法，<strong>当前线程阻塞等待：文件描述符事件（本文主要是唤醒事件）更新或者超时。</strong>阻塞等待时当前线程会释放 <code>CPU</code> 资源进入休眠状态，直到被唤醒，这个功能是 <code>Linux epoll</code> 机制实现。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env,jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = </span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法非常简单，调用 Looper.pollOnce</span></span><br><span class="line"><span class="comment">// pollObj 是当前对象，所以该方法不能为是静态的</span></span><br><span class="line"><span class="comment">// Looper.pollOnce 会回调 pollObj 对象的 dispatchEvents 方法</span></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, </span><br><span class="line">        <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Looper::pollInner 中会掉用 handleEvent ，这个方法是处理</span></span><br><span class="line"><span class="comment">// 监听的文件描述符事件更新，这里是对 java 方法的回调</span></span><br><span class="line"><span class="keyword">int</span> NativeMessageQueue::handleEvent(<span class="keyword">int</span> fd,<span class="keyword">int</span> looperEvents,<span class="keyword">void</span>* data)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> newWatchedEvents = mPollEnv-&gt;CallIntMethod(mPollObj,</span><br><span class="line">            gMessageQueueClassInfo.dispatchEvents, fd, events);</span><br><span class="line">    <span class="keyword">if</span> (!newWatchedEvents) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// unregister the fd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newWatchedEvents != oldWatchedEvents) &#123;</span><br><span class="line">        setFileDescriptorEvents(fd, newWatchedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    jfieldID mPtr;   <span class="comment">// native object attached to the DVM MessageQueue</span></span><br><span class="line">    jmethodID dispatchEvents;</span><br><span class="line">&#125; gMessageQueueClassInfo;</span><br><span class="line"><span class="comment">// dispatchEvents 对应的 Java 中 MessageQueue.dispatchEvents</span></span><br><span class="line">gMessageQueueClassInfo.dispatchEvents = GetMethodIDOrDie(env, clazz,</span><br><span class="line">    <span class="string">"dispatchEvents"</span>, <span class="string">"(II)I"</span>);</span><br></pre></td></tr></table></figure>

<p><code>pollOnce</code> 方法非常简单，需要获取当前对象，所以该方法不能为是静态的。调用了 <code>Looper.pollOnce</code> 方法，它会回调 <code>pollObj</code> 对象的 <code>dispatchEvents</code> 方法。而 <code>Handler</code> 收发消息机制中，并不会使用到文件描述符事件的回调，只需简单了解。  </p>
<h3 id="唤醒-nativeWake"><a href="#唤醒-nativeWake" class="headerlink" title="唤醒 nativeWake"></a>唤醒 <code>nativeWake</code></h3><p><code>Looper.cpp</code> 中，唤醒事件是单独的文件描述符在监听，具体为 <code>eventfd</code> ，用于线程间通信。实际上 <code>nativeWake</code> 函数仅仅是向 <code>eventfd</code> 中写入一个值，将 <code>epoll_wait</code> 函数唤醒。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = </span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否正在轮询等待-nativeIsPolling"><a href="#是否正在轮询等待-nativeIsPolling" class="headerlink" title="是否正在轮询等待 nativeIsPolling"></a>是否正在轮询等待 <code>nativeIsPolling</code></h3><p><code>nativeIsPolling</code> 函数返回的是 <code>Looper.cpp</code> 中 <code>epoll_wait</code> 是否处于阻塞等待状态；这个方法在 <code>Android Framework</code> 使用的也很少。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_MessageQueue_nativeIsPolling</span><span class="params">(JNIEnv* env, </span></span></span><br><span class="line"><span class="function"><span class="params">    jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = </span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;getLooper()-&gt;isPolling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听文件描述符-nativeSetFileDescriptorEvents"><a href="#监听文件描述符-nativeSetFileDescriptorEvents" class="headerlink" title="监听文件描述符 nativeSetFileDescriptorEvents"></a>监听文件描述符 <code>nativeSetFileDescriptorEvents</code></h3><p><code>nativeSetFileDescriptorEvents</code> 函数通过 <code>Looper.cpp::addFd</code> ，向 <code>epoll_wait</code> 中添加文件描述符监听事件，对应的回调 <code>dispatchEvents</code> 在 <code>pollOnce</code> 中分析过。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeSetFileDescriptorEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass clazz, jlong ptr, jint fd, jint events)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = </span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;setFileDescriptorEvents(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::setFileDescriptorEvents(<span class="keyword">int</span> fd, <span class="keyword">int</span> events)&#123;</span><br><span class="line">    <span class="keyword">if</span> (events) &#123;</span><br><span class="line">        <span class="keyword">int</span> looperEvents = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (events &amp; CALLBACK_EVENT_INPUT) &#123;</span><br><span class="line">            looperEvents |= Looper::EVENT_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (events &amp; CALLBACK_EVENT_OUTPUT) &#123;</span><br><span class="line">            looperEvents |= Looper::EVENT_OUTPUT;</span><br><span class="line">        &#125;</span><br><span class="line">        mLooper-&gt;addFd(fd, Looper::POLL_CALLBACK, looperEvents, <span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(events));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;removeFd(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统层实现"><a href="#系统层实现" class="headerlink" title="系统层实现"></a>系统层实现</h2><p>系统层 <code>Looper.cpp</code> 都是在 <code>Linux</code> 中编程实现，包括下面介绍的线程相关方法、<code>eventfd</code> 文件描述符、<code>epoll</code> 机制。<code>Looper.cpp</code> 实现了完整的 <code>native</code> 消息收发机制，使用 <code>MessageEnvelope</code> 存储消息；<code>Request</code> 存储文件描述符的监听；这些都是提供给 <code>native</code> 层使用，不过 <code>Android Framework</code> 使用的并不是特别多。<br>本文介绍的 <code>Java</code> 层 <code>Handler</code> 消息通信机制中，收发消息过程，只会有唤醒 <code>POLL_WAKE</code> 和超时 <code>POLL_TIMEOUT</code> 两种返回事件。最开始看源码时总是将 <code>Java</code> 消息和 <code>native</code> 的消息一一对应，或者相互关联；但实际上它们是两个完全不同的东西，只是共用了 <code>eventfd, epoll</code> 消息处理机制，本文不做 <code>native</code> 消息的介绍，这两个概念不要混淆了。  </p>
<h3 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h3><p><code>TLS: Thread Local Storage</code> 线程本地存储，和 <code>Java ThreadLocal</code> 功能一样，保存线程私有数据。使用同一个变量，不同线程存储和拿到的结果能够被隔离，相当于提供了一个同名而不同值的全局变量（这个全局变量相对于拥有这个变量的线程来说）。  </p>
<ul>
<li><code>pthread_key_t gTLSKey</code><br><code>gTLSKey</code> 共享变量。  </li>
<li><code>pthread_key_create</code><br><code>pthread_key_create(&amp; gTLSKey, threadDestructor);</code> ，绑定 <code>gTLSKey</code> 变量，该变量所有线程都可以访问，但各个线程可以根据自己的需要往 <code>gTLSKey</code> 中填入不同的值。<code>threadDestructor</code> 是销毁函数，线程退出时会调用该销毁函数。  </li>
<li><code>pthread_setspecific</code><br><code>pthread_setspecific(gTLSKey, looper.get());</code> ，当前线程向 <code>gTLSKey</code> 中写入数据。  </li>
<li><code>pthread_getspecific</code><br><code>(Looper*)pthread_getspecific(gTLSKey);</code> ，从 <code>gTLSKey</code> 中取出当前线程存储的值。  </li>
<li><code>pthread_once</code> 仅执行一次<br>函数声明： <code>int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；</code><br>函数功能：变量 <code>once_control</code> 的值设为 <code>PTHREAD_ONCE_INIT</code> 时，本函数保证 <code>init_routine()</code> 函数在进程执行序列中仅执行一次。  </li>
</ul>
<p>根据上面的简单介绍，<code>Looper.cpp</code> 中关于 <code>TLS</code> 线程本地存储的几个函数源码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once_control 变量，即确保函数只执行一次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> gTLSOnce = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> gTLSKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sp&lt;Looper&gt; Looper::getForThread() &#123;</span><br><span class="line">    <span class="comment">// 确保多线程中 initTLSKey 方法只执行一次</span></span><br><span class="line">    <span class="keyword">int</span> result = pthread_once(&amp; gTLSOnce, initTLSKey);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"pthread_once failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 gTLSKey 取出当前线程存储的数据</span></span><br><span class="line">    <span class="keyword">return</span> (Looper*)pthread_getspecific(gTLSKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::initTLSKey() &#123;</span><br><span class="line">    <span class="comment">// 创建并绑定 gTLSKey</span></span><br><span class="line">    <span class="keyword">int</span> result = pthread_key_create(&amp; gTLSKey, threadDestructor);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not allocate TLS key."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁函数</span></span><br><span class="line"><span class="keyword">void</span> Looper::threadDestructor(<span class="keyword">void</span> *st) &#123;</span><br><span class="line">    Looper* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;Looper*&gt;(st);</span><br><span class="line">    <span class="keyword">if</span> (self != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        self-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::setForThread(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) &#123;</span><br><span class="line">    <span class="comment">// also has side-effect of initializing TLS</span></span><br><span class="line">    sp&lt;Looper&gt; old = getForThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        looper-&gt;incStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程向 gTLSKey 写入数据</span></span><br><span class="line">    pthread_setspecific(gTLSKey, looper.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="eventfd-文件描述符"><a href="#eventfd-文件描述符" class="headerlink" title="eventfd 文件描述符"></a><code>eventfd</code> 文件描述符</h3><p><code>eventfd</code> 是一个用来通知事件的文件描述符，用来实现进程/线程间的等待/通知 <code>wait/notify</code> 机制以及数据交互，通过内核取唤醒用户态的事件。<br>只有一个系统调用接口：<code>int eventfd(unsigned int initval, int flags);</code>，返回一个新建的 <code>eventfd</code> 对象，该对象是一个内核维护的无符号的 64 位整型计数器，初始化值为 <code>initval</code> ；<code>flags</code> 有几个可选项：  </p>
<ul>
<li><code>EFD_NONBLOCK</code> ：设置对象为非阻塞状态，<code>read</code> 读取 <code>eventfd</code> 时不会阻塞  </li>
<li><code>EFD_CLOEXEC</code> ：表示执行时关闭；设置此标志后，在执行 <code>exec</code> 时才关闭 <code>eventfd</code> 描述符，否则该描述符一直打开  </li>
</ul>
<p><code>eventfd</code> 是一个文件描述符，所以直接通过 <code>read/write/close</code> 来读写关闭。常见示例为进程/线程 <code>A</code> 向 <code>eventfd</code> 中写入数据，进程/线程 <code>B</code> 从 <code>eventfd</code> 中读取数据。<code>Looper.cpp</code> 中源码分析：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">       mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">       mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">       mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX)&#123;</span><br><span class="line">    <span class="comment">// 构造方法中创建 mWakeEventFd 对象  </span></span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; <span class="number">0</span>,<span class="string">"Could not make wake event fd: %s"</span>,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Looper::~Looper() &#123;</span><br><span class="line">    <span class="comment">// 析构方法中，关闭 mWakeEventFd 句柄</span></span><br><span class="line">    close(mWakeEventFd);</span><br><span class="line">    <span class="comment">// 析构方法中，关闭 epoll 句柄</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 唤醒函数中，实际是向 mWakeEventFd 中写数据</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, </span><br><span class="line">        &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uint64_t</span> counter;</span><br><span class="line">    <span class="comment">// 将 mWakeEventFd 中的数据都读出来</span></span><br><span class="line">    TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="epoll-机制"><a href="#epoll-机制" class="headerlink" title="epoll 机制"></a><code>epoll</code> 机制</h3><p><code>I/O</code> 多路复用就通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（通常是读或者写就绪），能够通知程序进行相应的读写操作。<code>select, poll, epoll</code> 都是 <code>IO</code> 多路复用的机制，本质上它们都是同步 <code>I/O</code>，都需要在读写事件就绪后自己负责进行读写。<br><code>epoll</code> 是 <code>select</code> 和 <code>poll</code> 的增强版本；相对于 <code>select, poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> 使用一个文件描述符可以监听多个其他多个描述符，将用户关系文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 <code>copy</code> 只需一次。<br><code>epoll</code> 只有三个系统调用：  </p>
<ul>
<li><code>epoll_create</code><br>函数声明：<code>int epoll_create(int size);</code> ，创建一个 <code>epoll</code> 的句柄。<br>参数 <code>size</code> 用来告诉内核这个监听的数目一共有多大。需要注意的是当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，使用完后通过 <code>close(mEpollFd);</code> 来关闭。  </li>
<li><code>epoll_ctl</code><br>函数声明：<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code> ，事件注册函数，告诉内核要监听什么类型的事件以及哪些文件描述符。<br>参数 <code>epfd</code> 是 <code>epoll_create</code> 创建的句柄；<code>fd</code> 是被监听文件描述符；<code>op</code> 表示动作，用三个宏来表示：<br><code>EPOLL_CTL_ADD</code>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；<br><code>EPOLL_CTL_MOD</code>：修改已经注册的 <code>fd</code> 的监听事件；<br><code>EPOLL_CTL_DEL</code>：从 <code>epfd</code> 中删除一个 <code>fd</code>；<br>参数 <code>event</code> 告诉内核需要监听什么事，可以是以下几个宏的集合：<br><code>EPOLLIN</code> ：表示对应的文件描述符可以读；<br><code>EPOLLOUT</code> ：表示对应的文件描述符可以写；<br><code>EPOLLPRI</code> ：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><code>EPOLLERR</code> ：表示对应的文件描述符发生错误；<br><code>EPOLLHUP</code> ：表示对应的文件描述符被挂断；<br><code>EPOLLET</code> ： 将 <code>EPOLL</code> 设为边缘触发 <code>Edge Triggered</code> 模式，这是相对于水平触发 <code>Level Triggered</code> 来说的，关于 <code>ET/LT</code> 主要是效率的区别，不做展开；<br><code>EPOLLONESHOT</code> ：只监听一次事件，当监听完这次事件之后，如果还需要继续监听的话，需要再次加入到队列里；  </li>
<li><code>epoll_wait</code><br>函数声明：<code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code> ，<strong>阻塞等待</strong>事件的产生。<br>参数 <code>events</code> 用来从内核得到事件的集合；<code>maxevents</code> 告诉内核这个 <code>events</code> 有多大，不能大于创建 <code>epoll_create()</code> 时的 <code>size</code> ；参数 <code>timeout</code> 是超时时间（单位为毫秒，0 会<strong>不会阻塞</strong>立即返回，-1不确定或永久阻塞）。该函数返回需要处理的事件数目，如返回 0 表示已超时。  </li>
</ul>
<p><code>Looper.cpp</code> 中 <code>epoll</code> 除了监听唤醒文件描述符 <code>eventfd</code>，还可以同时监听 <code>MessageQueue</code> 设置的文件描述符，通过 <code>addFd</code> 添加。部分源码解析：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    <span class="comment">// Close old epoll instance if we have one.</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the new epoll instance and register the wake pipe.</span></span><br><span class="line">    <span class="comment">// 创建 epoll 句柄</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance: %s"</span></span><br><span class="line">                , strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event));</span><br><span class="line">    <span class="comment">// epoll 事件为 mWakeEventFd 可读事件</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="comment">// 注册监听事件，唤醒文件描述符 mWakeEventFd</span></span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, </span><br><span class="line">        mWakeEventFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake </span></span><br><span class="line"><span class="string">        event fd to epoll instance: %s"</span>, strerror(errno));</span><br><span class="line">    <span class="comment">// 其他文件描述符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, </span><br><span class="line">        <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 其他文件描述符</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mWakeEventFd 唤醒事件</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">            ALOGD(<span class="string">"%p ~ pollOnce - returning result %d"</span>, <span class="keyword">this</span>, result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    <span class="comment">// native 消息，timeoutMillis 调整</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">// epoll 阻塞等待事件的产生： mWakeEventFd 以及其他文件描述符</span></span><br><span class="line">    <span class="comment">// 或者 timeoutMillis 超时</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, </span><br><span class="line">            EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件产生，唤醒继续执行</span></span><br><span class="line">    <span class="comment">// No longer idling.</span></span><br><span class="line">    mPolling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire lock.</span></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护代码，状态检查</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 epoll 是因为超时唤醒，更新 result</span></span><br><span class="line">    <span class="comment">// Check for poll timeout.</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - timeout"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不是超时，检查是哪些文件描述符唤醒的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="comment">// mWakeEventFd 唤醒事件</span></span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 交给 eventfd 处理</span></span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他文件描述符的唤醒</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native message 的处理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke all response callbacks.</span></span><br><span class="line">    <span class="comment">// 处理 addFd 添加的文件描述符</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 回调文件描述符监听事件 handleEvent</span></span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent</span><br><span class="line">                (fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd, response.request.seq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 epoll_wait 是否处于阻塞等待</span></span><br><span class="line"><span class="keyword">bool</span> Looper::isPolling() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mPolling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，<code>Handler</code> 机制只监听了 <code>mWakeEventFd</code> 的可读事件，以及超时事件；<code>mPolling</code> 记录了 <code>epoll_wait</code> 是否处于阻塞等待，在 <code>MessageQueue.isPolling</code> 中查看该变量的值。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Looper.cpp</code> 中通过 <code>eventfd</code> 实现线程间通信；通过 <code>epoll</code> 实现监听 <code>eventfd</code> 文件描述符的读写事件，以及 <code>Message</code> 的超时事件。  </p>
<h2 id="消息收发流程图"><a href="#消息收发流程图" class="headerlink" title="消息收发流程图"></a>消息收发流程图</h2><p><code>Handler</code> 机制大致流程：  </p>
<ul>
<li><code>Looper.prepare</code> 准备环境，初始化所有相关对象  </li>
<li><code>Looper.loop</code> 进入无限循环，阻塞等待获取下一条消息 <code>MessageQueue.next</code>  </li>
<li>创建 <code>Handler</code> 子类，初始化 </li>
<li>创建 <code>Message</code> ，存储相关信息 </li>
<li><code>Handler.sendMessage</code> 发送消息，加入到消息队列 <code>MessageQueue.enqueueMessage</code>      </li>
<li><code>Looper</code> 从 <code>MessageQueue</code> 中取出 <code>Message</code> 后，指派给 <code>Handler.handleMessage</code> 处理，处理完后回收 <code>Message.recycleUnchecked</code>  </li>
<li><code>Looper.quit</code> 退出机制  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0023-handler-sequence-diag.png" alt="0023-handler-sequence-diag.png"></p>
<h2 id="HandlerThread-创建与销毁"><a href="#HandlerThread-创建与销毁" class="headerlink" title="HandlerThread 创建与销毁"></a><code>HandlerThread</code> 创建与销毁</h2><p>在 <code>Android</code> 开发中经常会使用到线程，一想到线程，很多同学就立即使用 <code>new Thread(){...}.start();</code> 这样的方式。这样如果在一个 <code>Activity</code> 中多次调用上面的代码，那么将创建多个匿名线程，程序运行的越久可能会越来越慢。因此，需要一个 <code>Handler</code> 来启动一个线程，以及删除一个线程，保证线程不会重复的创建。<br>使用 <code>HandlerThread</code> 和 <code>Handler</code> 配合实现异步后台任务。<strong>特点</strong>：</p>
<ul>
<li>由 2 个 <code>Handler</code> 和 1 个 <code>HandlerThread</code> 来实现  </li>
<li>后台线程串行执行  </li>
</ul>
<h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>HandlerThread</code> 是参考 <code>Looper</code> 标准用法实现的工作线程，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call back method that can be explicitly overridden </span></span><br><span class="line"><span class="comment">     * if needed to execute some setup before Looper loops.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, </span></span><br><span class="line">        <span class="comment">// wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandlerThread-的创建"><a href="#HandlerThread-的创建" class="headerlink" title="HandlerThread 的创建"></a><code>HandlerThread</code> 的创建</h3><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UI线程的Handler</span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">// 处理UI更新</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HandlerThread mBackThread = <span class="keyword">new</span> HandlerThread(<span class="string">"mybackthread"</span>);</span><br><span class="line">mBackThread.start();</span><br><span class="line"><span class="comment">// 后台线程的Handler</span></span><br><span class="line">Handler mBackHandler = <span class="keyword">new</span> Handler(mBackThread.getLooper());</span><br><span class="line">mBackHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 后台线程执行耗时操作，异步</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// mHandler发消息，回到主线程更新UI</span></span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>mBackHandler</code> 的初始化必须在 <code>mBackThread.start();</code> 之后，否则拿不到这个线程的 <code>looper</code>。源码中可以看到，<code>getLooper</code> 会一直等待；而 <code>Looper</code> 是在 <code>run</code> 中创建的，并且通知等待线程。<br>这种模式通过 <code>mBackHandler.post(new Runnable() {})</code> 来实现后台异步任务执行，所有后台任务都是通过 <code>HandlerThread</code> 这个线程执行的，但是 <code>HandlerThread</code> 是串行执行任务的，也就是每次 <code>post</code> 后进入队列排队执行。</p>
<h3 id="HandlerThread的退出"><a href="#HandlerThread的退出" class="headerlink" title="HandlerThread的退出"></a><code>HandlerThread</code>的退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="keyword">if</span>(mBackThread != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mBackThread.quitSafely();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mBackThread.join();</span><br><span class="line">            mBackThread = <span class="keyword">null</span>;</span><br><span class="line">            mBackHandler = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Activity.onDestroy</code> 退出时，等待 <code>mBackThread</code> 线程销毁完成再退出！  </p>
<h2 id="其他线程间通信机制"><a href="#其他线程间通信机制" class="headerlink" title="其他线程间通信机制"></a>其他线程间通信机制</h2><ul>
<li><code>LocalBroadcastManager</code> 本质还是 <code>Handler</code> 机制  </li>
<li><code>EventBus</code><br>查看了 <code>EventBus</code> 源码，<code>UI</code> 主线程间通信还是采用了 Handler 机制：<code>public class HandlerPoster extends Handler implements Poster {...}</code> ；后台线程间通信，采用的是 <code>Java</code> 标准的 <code>notify/wait</code> 机制。  </li>
</ul>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><h3 id="Messenger-信差"><a href="#Messenger-信差" class="headerlink" title="Messenger 信差"></a><code>Messenger</code> 信差</h3><p><code>Messenger</code> 用于进程间异步通信，其中通过 <code>AIDL</code> 来实现的进程间通信的；通过 <code>Handler.sendMessage</code> 来实现异步通信。详细参考<a href="https://redspider110.github.io/2017/11/29/0034-messenger/">Messenger 详解</a> 。  </p>
<h3 id="OnFileDescriptorEventListener-监听文件描述符"><a href="#OnFileDescriptorEventListener-监听文件描述符" class="headerlink" title="OnFileDescriptorEventListener 监听文件描述符"></a><code>OnFileDescriptorEventListener</code> 监听文件描述符</h3><p><code>MessageQueue.java</code> 中提供了完整的文件描述符监听功能，包括 <code>Android_os_MessageQueue.cpp, Looper.cpp</code> 中也实现了对应的功能，本文暂不做描述。  </p>
<h3 id="Native-Loop-机制"><a href="#Native-Loop-机制" class="headerlink" title="Native Loop 机制"></a><code>Native Loop</code> 机制</h3><p><code>Java</code> 层的 <code>Handler</code> 机制，在系统层的 <code>Looper.cpp</code> 文件中重新全部实现了一遍，供 <code>Native</code> 代码使用。本文仅仅介绍了其中的唤醒和轮询两个功能。而 <code>Looper.cpp</code> 中还包含添加文件描述符监听，收发 <code>native</code> 的消息。可以参考：<a href="https://blog.csdn.net/chwan_gogogo/article/details/46953549" target="_blank" rel="noopener">Android Native层Looper详解</a> ，<a href="https://blog.csdn.net/chwan_gogogo/article/details/46953563" target="_blank" rel="noopener">Android Native Looper机制 - 监听文件描述符</a> 。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Handler</code> 通过 <code>Linux</code> 系统调用的意义<br>本文介绍的 <code>Handler</code> 消息收发机制，完全可以使用 <code>Object.wait/notify</code> 来简单实现；但是源码为什么还使用了 <code>Linux epoll</code> 来实现呢？这是因为 <code>Framework</code> 除了提供等待和唤醒方法，还提供了其他文件描述符监听机制等，<code>epoll</code> 机制更强大更高效。  </li>
<li>应用程序的主线程处于无限循环状态<br>应用主线程 <code>ActivityThread</code> 进入 <code>Looper.loop()</code> 后不允许退出，直到应用退出；也就是说主线程是无限循环的，通过 <code>epoll</code> 机制阻塞等待时释放 <code>CPU</code> 资源，直到超时或事件触发才唤醒主线程。而我们经常遇到的 <code>Activity</code> 的 <code>ANR</code> 限制是针对 <code>Activity</code> 等组件的，实际上并不是主线程。  </li>
<li><code>Handler</code> 机制中的线程切换<br><code>Handler</code> 机制通常有两个线程：主线程和后台工作线程。主线程 <code>loop</code> 无限循环阻塞等待；后台工作线程完成耗时任务，发送完消息后就可以退出了；此时阻塞等待的主线程收到 <code>epoll</code> 机制的唤醒，拿到这个消息直接处理。因为消息 <code>Message</code> 是共享变量，所以整个 <code>Handler</code> 机制使用了很多同步锁 <code>synchronized</code> ，所以两个线程之间仅仅只是等待/通知交互。<code>Looper.cpp</code> 底层 <code>epoll</code> 机制并没有涉及数据交互，仅仅是线程间的通知什么时候能够取出消息，相当于 <code>Java notify/wait</code> 机制。而 <code>epoll</code> 还支持监听文件描述符涉及到数据交互，但是不属于本文介绍范围。  </li>
<li><code>Handler</code> 机制的退出<br>主线程是无法退出的，会一直循环等待，除非退出应用程序；其他线程的退出通过调用 <code>Looper.quit</code> 来退出，退出时会移除消息队列的所有消息，并设置 <code>mQuitting</code> 使得 <code>MessageQueue.next</code> 返回 <code>null</code> ，<code>Looper.loop</code> 退出循环。  </li>
<li>消息队列的唤醒<br>消息队列 <code>MessageQueue</code> 有三个地方会唤醒：退出 <code>quit</code> 必须唤醒；移除同步屏障 <code>removeSyncBarrier</code> 和消息入队 <code>enqueueMessage</code> 满足条件时才唤醒。通过 <code>nativeWake</code> 触发唤醒。  </li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">gityuan:Android消息机制-Handler</a>  </li>
<li><a href="https://www.jianshu.com/p/e635c3f851ea" target="_blank" rel="noopener">隔壁老李头：Android Handler 机制系列</a>  </li>
<li><a href="https://developer.android.com/reference/android/os/Handler" target="_blank" rel="noopener">Android Handler.java API</a>  </li>
<li><a href="https://developer.android.com/reference/android/os/Looper" target="_blank" rel="noopener">Android Looper.java API</a>  </li>
<li><a href="https://developer.android.com/reference/android/os/MessageQueue" target="_blank" rel="noopener">Android MessageQueue.java API</a>  </li>
<li><a href="https://developer.android.com/reference/android/os/Message" target="_blank" rel="noopener">Android Message.java API</a>  </li>
<li><a href="https://blog.dreamtobe.cn/2016/03/11/android_handler_looper/" target="_blank" rel="noopener">Android Handler Looper机制</a>  </li>
<li><a href="https://blog.dreamtobe.cn/looper/" target="_blank" rel="noopener">Looper 探底</a>  </li>
<li><a href="https://blog.csdn.net/kc58236582/article/details/52919904" target="_blank" rel="noopener">Android消息机制 空闲消息处理器</a>  </li>
<li><a href="http://book.51cto.com/art/201109/291366.htm" target="_blank" rel="noopener">AMS 释放内存详解</a>  </li>
<li><a href="https://blog.csdn.net/iispring/article/details/47622705" target="_blank" rel="noopener">Android中Looper的quit方法和quitSafely方法</a>  </li>
<li><a href="https://blog.csdn.net/asdgbc/article/details/79148180" target="_blank" rel="noopener">Handler之同步屏障机制sync barrier</a>  </li>
<li><a href="https://blog.csdn.net/linyt/article/details/51931737/" target="_blank" rel="noopener">Linux 本地线程存储栈-TLS</a>  </li>
<li><a href="https://blog.csdn.net/xiaoyeyopulei/article/details/7963839" target="_blank" rel="noopener">Linux多线程学习 pthread_once</a>  </li>
<li><a href="https://blog.csdn.net/majianfei1023/article/details/51199702" target="_blank" rel="noopener">Linux eventfd</a>  </li>
<li><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">Linux IO多路复用之epoll总结</a>  </li>
<li><a href="https://www.2cto.com/kf/201707/660386.html" target="_blank" rel="noopener">Android源码解析之Handler机制详解-Java简化版本的实现</a>  </li>
<li><a href="https://www.jianshu.com/p/493cc5368a73" target="_blank" rel="noopener">Handler BlockingRunnable 介绍</a>  </li>
<li><a href="https://m.2cto.com/kf/201607/526429.html" target="_blank" rel="noopener">MessageQueue的队列管理</a>  </li>
<li><a href="https://blog.csdn.net/kisty_yao/article/details/71191175" target="_blank" rel="noopener">深入理解MessageQueue</a>  </li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    redspider110
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://redspider110.github.io/2017/11/27/0023-handler/" title="Android Handler 机制">http://redspider110.github.io/2017/11/27/0023-handler/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Asynchronous/" rel="tag"># Asynchronous</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/27/0022-content-provider/" rel="next" title="四大组件 -- ContentProvider">
                <i class="fa fa-chevron-left"></i> 四大组件 -- ContentProvider
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/27/0024-async-task/" rel="prev" title="异步 -- AsyncTask">
                异步 -- AsyncTask <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="redspider110">
            
              <p class="site-author-name" itemprop="name">redspider110</p>
              <p class="site-description motion-element" itemprop="description">地球卫士</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码目录及类对应文件"><span class="nav-number">2.</span> <span class="nav-text">源码目录及类对应文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码目录结构"><span class="nav-number">2.1.</span> <span class="nav-text">源码目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类或接口对应文件"><span class="nav-number">2.2.</span> <span class="nav-text">类或接口对应文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message-详解"><span class="nav-number">3.</span> <span class="nav-text">Message 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">3.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息池-sPool"><span class="nav-number">3.2.</span> <span class="nav-text">消息池 sPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要成员变量"><span class="nav-number">3.3.</span> <span class="nav-text">重要成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息标识-flags"><span class="nav-number">3.4.</span> <span class="nav-text">消息标识 flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Messenger-相关"><span class="nav-number">3.5.</span> <span class="nav-text">Messenger 相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Looper-详解"><span class="nav-number">4.</span> <span class="nav-text">Looper 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析-1"><span class="nav-number">4.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要成员变量-1"><span class="nav-number">4.2.</span> <span class="nav-text">重要成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Looper-的初始化"><span class="nav-number">4.3.</span> <span class="nav-text">Looper 的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Looper-loop"><span class="nav-number">4.4.</span> <span class="nav-text">Looper.loop()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Looper-退出"><span class="nav-number">4.5.</span> <span class="nav-text">Looper 退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型工作线程流程"><span class="nav-number">4.6.</span> <span class="nav-text">典型工作线程流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-详解"><span class="nav-number">5.</span> <span class="nav-text">Handler 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析-2"><span class="nav-number">5.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法及成员变量"><span class="nav-number">5.2.</span> <span class="nav-text">构造方法及成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成消息"><span class="nav-number">5.3.</span> <span class="nav-text">生成消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务发布"><span class="nav-number">5.4.</span> <span class="nav-text">任务发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息处理"><span class="nav-number">5.5.</span> <span class="nav-text">消息处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除消息"><span class="nav-number">5.6.</span> <span class="nav-text">移除消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Messenger-相关-1"><span class="nav-number">5.7.</span> <span class="nav-text">Messenger 相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingRunnable-阻塞并同步执行任务"><span class="nav-number">5.8.</span> <span class="nav-text">BlockingRunnable 阻塞并同步执行任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MessageQueue-详解"><span class="nav-number">6.</span> <span class="nav-text">MessageQueue 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析-3"><span class="nav-number">6.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要成员变量-2"><span class="nav-number">6.2.</span> <span class="nav-text">重要成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">6.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步屏障"><span class="nav-number">6.4.</span> <span class="nav-text">同步屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息入队-enqueueMessage"><span class="nav-number">6.5.</span> <span class="nav-text">消息入队 enqueueMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列存储顺序"><span class="nav-number">6.6.</span> <span class="nav-text">消息队列存储顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息出队-next"><span class="nav-number">6.7.</span> <span class="nav-text">消息出队 next</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息轮询状态"><span class="nav-number">6.8.</span> <span class="nav-text">消息轮询状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除消息"><span class="nav-number">6.9.</span> <span class="nav-text">删除消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列退出"><span class="nav-number">6.10.</span> <span class="nav-text">消息队列退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IdleHandler-接口"><span class="nav-number">6.11.</span> <span class="nav-text">IdleHandler 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native-方法"><span class="nav-number">6.12.</span> <span class="nav-text">native 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Native-JNI-层"><span class="nav-number">7.</span> <span class="nav-text">Native JNI 层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境初始化-nativeInit"><span class="nav-number">7.1.</span> <span class="nav-text">环境初始化 nativeInit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁-nativeDestroy"><span class="nav-number">7.2.</span> <span class="nav-text">销毁 nativeDestroy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮询-nativePollOnce"><span class="nav-number">7.3.</span> <span class="nav-text">轮询 nativePollOnce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒-nativeWake"><span class="nav-number">7.4.</span> <span class="nav-text">唤醒 nativeWake</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否正在轮询等待-nativeIsPolling"><span class="nav-number">7.5.</span> <span class="nav-text">是否正在轮询等待 nativeIsPolling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听文件描述符-nativeSetFileDescriptorEvents"><span class="nav-number">7.6.</span> <span class="nav-text">监听文件描述符 nativeSetFileDescriptorEvents</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统层实现"><span class="nav-number">8.</span> <span class="nav-text">系统层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程相关方法"><span class="nav-number">8.1.</span> <span class="nav-text">线程相关方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventfd-文件描述符"><span class="nav-number">8.2.</span> <span class="nav-text">eventfd 文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-机制"><span class="nav-number">8.3.</span> <span class="nav-text">epoll 机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">8.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息收发流程图"><span class="nav-number">9.</span> <span class="nav-text">消息收发流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HandlerThread-创建与销毁"><span class="nav-number">10.</span> <span class="nav-text">HandlerThread 创建与销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析-4"><span class="nav-number">10.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerThread-的创建"><span class="nav-number">10.2.</span> <span class="nav-text">HandlerThread 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerThread的退出"><span class="nav-number">10.3.</span> <span class="nav-text">HandlerThread的退出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他线程间通信机制"><span class="nav-number">11.</span> <span class="nav-text">其他线程间通信机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后续"><span class="nav-number">12.</span> <span class="nav-text">后续</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Messenger-信差"><span class="nav-number">12.1.</span> <span class="nav-text">Messenger 信差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OnFileDescriptorEventListener-监听文件描述符"><span class="nav-number">12.2.</span> <span class="nav-text">OnFileDescriptorEventListener 监听文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Native-Loop-机制"><span class="nav-number">12.3.</span> <span class="nav-text">Native Loop 机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">12.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">13.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">redspider110</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
