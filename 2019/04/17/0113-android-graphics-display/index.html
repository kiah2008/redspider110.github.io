<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android,">










<meta name="description" content="Android 图形 Graphic 和显示 Display 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 BufferQueue 生产者消费者模型， Surface/SurfaceFlinger 图形合成等等。">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 图形显示简述">
<meta property="og:url" content="http://redspider110.github.io/2019/04/17/0113-android-graphics-display/index.html">
<meta property="og:site_name" content="Earth Guardian">
<meta property="og:description" content="Android 图形 Graphic 和显示 Display 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 BufferQueue 生产者消费者模型， Surface/SurfaceFlinger 图形合成等等。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-android-egl.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-ape_fwk_graphics.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-linux-framebuffer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-fps-demo.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-vsync.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-tearing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-single-buffer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer-jank.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer-jank.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-bufferqueue.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-graphics_pipeline.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0109-android-camera-5-hal-buffer_handle_t.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-surface-buffer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-resolution.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-ISurfaceComposerClient.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-IDisplayEventConnection.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-SurfaceFlinger-init.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-layer-composer.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-surface.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-VsyncCallback.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-onFrameAvailable-class-uml.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-requestNextVsync.png">
<meta property="og:updated_time" content="2019-09-18T09:30:13.392Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 图形显示简述">
<meta name="twitter:description" content="Android 图形 Graphic 和显示 Display 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 BufferQueue 生产者消费者模型， Surface/SurfaceFlinger 图形合成等等。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-android-egl.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://redspider110.github.io/2019/04/17/0113-android-graphics-display/">





  <title>Android 图形显示简述 | Earth Guardian</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?faa79b658398065f8158bf82b6221b6d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Earth Guardian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">You are not LATE!You are not EARLY!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://redspider110.github.io/2019/04/17/0113-android-graphics-display/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="redspider110">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earth Guardian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android 图形显示简述</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T09:00:00+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i> 阅读次数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>Android</code> 图形 <code>Graphic</code> 和显示 <code>Display</code> 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 <code>BufferQueue</code> 生产者消费者模型， <code>Surface/SurfaceFlinger</code> 图形合成等等。  </p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>应用开发者可通过两种方式将图像绘制到屏幕上：使用 <code>Canvas</code> 或 <code>OpenGL</code> ：  </p>
<ul>
<li><code>android.graphics.Canvas</code> 是一个 <code>2D</code> 图形 <code>API</code> ， <code>Canvas API</code> 通过一个名为 <code>OpenGLRenderer</code> 的绘制库实现硬件加速，该绘制库将 <code>Canvas</code> 运算转换为 <code>OpenGL</code> 运算，以便它们可以在 <code>GPU</code> 上执行。从 <code>Android 4.0</code> 开始，硬件加速的 <code>Canvas</code> 默认情况下处于启用状态  </li>
<li>除了 <code>Canvas</code>，开发者渲染图形的另一个主要方式是使用 <code>OpenGL ES</code> 直接渲染到 <code>Surface</code> 。 <code>Android</code> 在 <code>Android.opengl</code> 软件包中提供了 <code>OpenGL ES</code> 接口  </li>
</ul>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a><code>EGL</code></h3><p>先熟悉 <code>Android</code> 平台图形处理 <code>API</code> 的标准：  </p>
<ul>
<li><code>OpenGL</code><br>是由 <code>SGI</code> 公司开发的一套 <code>3D</code> 图形软件接口标准，由于具有体系结构简单合理、使用方便、与操作平台无关等优点， <code>OpenGL</code> 迅速成为 <code>3D</code> 图形接口的工业标准，并陆续在各种平台上得以实现。  </li>
<li><code>OpenGL ES</code><br>是由 <code>khronos</code> 组织根据手持及移动平台的特点，对 <code>OpenGL 3D</code> 图形 <code>API</code> 标准进行裁剪定制而形成的。  </li>
<li><code>Vulkan</code><br>是由 <code>khronos</code> 组织在 2016 年正式发布的，是 <code>OpenGL ES</code> 的继任者。 <code>API</code> 是轻量级、更贴近底层硬件 <code>close-to-the-metal</code> 的接口，可使 <code>GPU</code> 驱动软件运用多核与多线程 <code>CPU</code> 性能。  </li>
</ul>
<p><code>OpenGL ES</code> 定义了一个渲染图形的 <code>API</code> ，但没有定义窗口系统。为了让它能够适合各种平台，它将与知道如何通过操作系统创建和访问窗口的库结合使用。而在 <code>Android</code> 中，这个库被称为 <code>EGL</code> ；也就是说 <code>EGL</code> 主要是适配系统和关联窗口属性。如果要绘制纹理多边形，应使用 <code>OpenGL ES</code> 调用；如果要在屏幕上进行渲染，应使用 <code>EGL</code> 调用。<br><code>OpenGL ES</code> 是 <code>Android</code> 绘图 <code>API</code> ，但 <code>OpenGL ES</code> 是平台通用的，在特定设备上使用需要一个中间层做适配， <code>Android</code> 中这个中间层就是 <code>EGL</code> 。  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-android-egl.jpg" alt="0113-android-graphics-display-android-egl.jpg"></p>
<h3 id="Surface-和-SurfaceFlinger"><a href="#Surface-和-SurfaceFlinger" class="headerlink" title="Surface 和 SurfaceFlinger"></a><code>Surface</code> 和 <code>SurfaceFlinger</code></h3><p>无论开发者使用什么渲染 <code>API</code>，一切内容都会渲染到 <code>Surface</code> 。 <code>Surface</code> 表示缓冲队列中的生产者，而缓冲队列通常会被 <code>SurfaceFlinger</code> 消耗。在 <code>Android</code> 平台上创建的每个窗口都由 <code>Surface</code> 提供支持。所有被渲染的可见 <code>Surface</code> 都被 <code>SurfaceFlinger</code> 合成到显示部分。它们遵循生产者/消费者模型：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-ape_fwk_graphics.png" alt="0113-android-graphics-ape_fwk_graphics.png"></p>
<ul>
<li>图像流生产者<br>图像流生产者可以是生成图形缓冲区以供消耗的任何内容。例如 <code>OpenGL ES, Canvas 2D, mediaserver</code> 视频解码器。  </li>
<li>图像流消费者<br>图像流的最常见消费者是 <code>SurfaceFlinger</code> ，该系统服务会消耗当前可见的 <code>Surface</code> ，并使用窗口管理器中提供的信息将它们合成到显示部分。 <code>SurfaceFlinger</code> 是可以修改所显示部分内容的唯一服务。 <code>SurfaceFlinger</code> 使用 <code>OpenGL</code> 和 <code>Hardware Composer</code> 来合成一组 <code>Surface</code> 。<br>其他 <code>OpenGL ES</code> 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流。非 <code>GL</code> 应用也可以是消费者，例如 <code>ImageReader</code> 类。  </li>
</ul>
<h3 id="WMS-WindowManagerServices"><a href="#WMS-WindowManagerServices" class="headerlink" title="WMS: WindowManagerServices"></a><code>WMS: WindowManagerServices</code></h3><p>窗口管理器，控制窗口的 <code>Android</code> 系统服务，它是视图容器。窗口总是由 <code>Surface</code> 提供支持。该服务会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、 <code>Z-Order</code> 以及窗口的其他许多方面。窗口管理器会将所有窗口元数据发送到 <code>SurfaceFlinger</code> ，以便 <code>SurfaceFlinger</code> 可以使用该数据在显示部分合成 <code>Surface</code> 。  </p>
<h3 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a><code>FrameBuffer</code></h3><p><code>FrameBuffer</code> 帧缓冲驱动，它是 <code>Linux</code> 的一种驱动程序接口。 <code>Linux</code> 是工作在保护模式下，所以用户态进程是无法象 <code>DOS</code> 那样使用显卡 <code>BIOS</code> 里提供的中断调用来实现直接写屏， <code>Linux</code> 抽象出 <code>FrameBuffer</code> 这个设备来供用户态进程实现直接写屏。 <code>FrameBuffer</code> 机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过 <code>FrameBuffer</code> 的读写直接对显存进行操作。用户可以将 <code>FrameBuffer</code> 看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由 <code>FrameBuffer</code> 设备驱动来完成的。但 <code>FrameBuffer</code> 本身不具备任何运算数据的能力，就只好比是一个暂时存放水的水池。 <code>CPU</code> 将运算后的结果放到这个水池,水池再将结果流到显示器，中间不会对数据做处理。应用程序也可以直接读写这个水池的内容在这种机制下，尽管 <code>FrameBuffer</code> 需要真正的显卡驱动的支持，但所有显示任务都有 <code>CPU</code> 完成，因此 <code>CPU</code> 负担很重。  </p>
<p>在开发者看来， <code>FrameBuffer</code> 本质上是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说 <code>FrameBuffer</code> 就是一块白板。例如对于初始化为 16 位色的 <code>FrameBuffer</code> 来说， <code>FrameBuffer</code> 中的两个字节代表屏幕上一个点，从上到下，从左至右，屏幕位置与内存地址是顺序的线性关系。<br>帧缓存可以在系统存储器(内存)的任意位置，视频控制器通过访问帧缓存来刷新屏幕。帧缓存也叫刷新缓存 <code>FrameBuffer</code> 或 <code>RefreshBuffer</code> ，这里的帧 <code>Frame</code> 是指整个屏幕范围。帧缓存有个地址，是在内存里。我们通过不停的向 <code>FrameBuffer</code> 中写入数据，显示控制器就自动的从 <code>FrameBuffer</code> 中取数据并显示出来。全部的图形都共享内存中同一个帧缓存。  </p>
<p><code>FrameBuffer</code> 帧缓冲实际上包括两个不同的方面：  </p>
<ul>
<li><code>Frame</code> ：帧，就是指一幅图像，在屏幕上看到的那幅图像就是一帧  </li>
<li><code>Buffer</code> ：缓冲，就是一段存储区域，可这个区域存储的是帧  </li>
</ul>
<p><code>FrameBuffer</code> 就是一个存储图形/图像帧数据的缓冲。<code>Linux</code> 内核提供了统一的 <code>Framebuffer</code> 显示驱动，设备节点 <code>/dev/graphics/fb*</code> 或者 <code>/dev/fb*</code> ，以 <code>fb0</code> 表示第一个 <code>Monitor</code> ，当前实现中只用到了一个显示屏。这个虚拟设备将不同硬件厂商实现的真实设备统一在一个框架下，这样应用层就可以通过标准的接口进行图形/图像的输入和输出了：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-linux-framebuffer.png" alt="0113-android-graphics-display-linux-framebuffer.png"></p>
<p>从上图中可以看出，应用层通过标准的 <code>ioctl, mmap</code> 等系统调用，就可以操作显示设备，用起来非常方便。这里 <code>mmap</code> 把设备中的显存映射到用户空间的，在这块缓冲上写数据，就相当于在屏幕上绘画。</p>
<h3 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a><code>Gralloc</code></h3><p><code>Gralloc</code> 的含义为是 <code>Graphics Alloc</code> 图形分配 。 <code>Android</code> 系统在硬件抽象层中提供了一个 <code>Gralloc</code> 模块，封装了对 <code>Framebuffer</code> 的所有访问操作。<br><code>Gralloc</code> 模块符合 <code>Android</code> 标准的 <code>HAL</code> 架构设计；它分为 <code>fb</code> 和 <code>gralloc</code> 两个设备：前者负责打开内核中的 <code>Framebuffer</code> 、初始化配置，以及提供 <code>post, setSwapInterval</code> 等操作；后者则管理帧缓冲区的分配和释放。上层只能通过 <code>Gralloc</code> 访问帧缓冲区，这样一来就实现了有序的封装保护。  </p>
<p><code>Gralloc</code> 图形内存分配器，分配图像生产者请求的内存。它不仅仅是在原生堆上分配内存的另一种方法；在某些情况下，分配的内存可能并非缓存一致，或者可能完全无法从用户空间访问。分配的性质由用法标记确定，这些标记包括以下属性：  </p>
<ul>
<li>从软件 <code>CPU</code> 访问内存的频率  </li>
<li>从硬件 <code>GPU</code> 访问内存的频率  </li>
<li>是否将内存用作 <code>OpenGL ES: GLES</code> 纹理  </li>
<li>视频编码器是否会使用内存  </li>
</ul>
<p>例如如果格式指定为 <code>RGBA 8888</code> 像素，并且指明将从软件访问缓冲区（这意味着应用将直接触摸像素），则分配器必须按照 <code>R-G-B-A</code> 的顺序为每个像素创建 4 个字节的缓冲区。相反如果指明仅从硬件访问缓冲区且缓冲区作为 <code>GLES</code> 纹理，则分配器可以执行 <code>GLES</code> 驱动程序所需的任何操作 - <code>BGRA</code> 排序、非线性搅和布局、替代颜色格式等。允许硬件使用其首选格式可以提高性能。某些值在特定平台上无法组合，例如视频编码器标记可能需要 <code>YUV</code> 像素，因此将无法添加软件访问权并指定 <code>RGBA 8888</code> 。  </p>
<p><code>Gralloc</code> 分配器返回的句柄可以通过 <code>Binder</code> 在进程之间传递。  </p>
<h3 id="HWC"><a href="#HWC" class="headerlink" title="HWC"></a><code>HWC</code></h3><p><code>HWC: Hardware Composer</code> 硬件混合渲染器，显示子系统的硬件抽象实现。 <code>SurfaceFlinger</code> 可以将某些合成工作委托给 <code>Hardware Composer</code>，以分担 <code>OpenGL</code> 和 <code>GPU</code> 上的工作量。 <code>SurfaceFlinger</code> 只是充当另一个 <code>OpenGL ES</code> 客户端。因此在 <code>SurfaceFlinger</code> 将一个或两个缓冲区合成到第三个缓冲区中的过程中，它会使用 <code>OpenGL ES</code> 。这样使合成的功耗比通过 <code>GPU</code> 执行所有计算更低。<br><code>Hardware Composer HAL</code> 则进行另一半的工作，并且是所有 <code>Android</code> 图形渲染的核心。 <code>Hardware Composer</code> 必须支持事件，其中之一是 <code>VSYNC</code>（另一个是支持即插即用 <code>HDMI</code> 的热插拔 <code>hotplug</code> ） 。  </p>
<h3 id="VSYNC-垂直刷新"><a href="#VSYNC-垂直刷新" class="headerlink" title="VSYNC 垂直刷新"></a>VSYNC 垂直刷新</h3><p>先介绍几个概念：  </p>
<ul>
<li>帧<br>视频，动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。  </li>
<li>帧率<br><code>Frame Rate</code> ，也指帧速率，单位 <code>fps:frames per second</code> ，描述视频、电子绘图或游戏每秒播放多少帧；<code>FPS</code> 是测量用于保存、显示动态视频的信息数量；<strong>我们本篇讲的帧率/帧速率指的是系统显卡处理的速率，即每秒能处理多少帧</strong>。<br>每秒钟帧数愈多，所显示的动作就会愈流畅。通常要避免动作不流畅的最低是 30 ，所以常见的有 <code>30fps, 60fps</code> 等。 <code>wiki</code> 百科中提到几个帧率数字：  <ul>
<li><code>12 fps</code>：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 帧的时候，就会认为是连贯的，是动画的  </li>
<li><code>24 fps</code>：有声电影的拍摄及播放帧率均为每秒 24 帧，对一般人而言已算可接受  </li>
<li><code>30 fps</code>：早期的高动态电子游戏，帧率少于每秒 30 帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低  </li>
<li><code>60 fps</code>：在实际体验中，60 帧相对于 30 帧有着更好的体验  </li>
<li><code>85 fps</code>：一般而言，大脑处理视频的极限<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-fps-demo.gif" alt="0113-android-graphics-display-fps-demo.gif"></li>
</ul>
</li>
<li>屏幕刷新频率<br><code>Refresh Rate</code> 或者是 <code>Scanning Frequency</code>，单位赫兹 <code>Hz</code> （即周期/秒），是指设备刷新屏幕的频率，通常为 <code>60hz</code> 。屏幕的刷新过程是每一行从左到右（<strong>行刷新</strong>，水平刷新，<code>Horizontal Scanning</code> ），从上到下（屏幕刷新，垂直刷新， <code>Vertical Scanning</code> ）。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-vsync.png" alt="0113-android-graphics-vsync.png"></li>
<li><code>Tearing</code> 撕裂<br>显示出来的图像出现上半部分和下半部分不属于同一帧，我们称之为 <code>tearing</code> 。假设系统显卡处理能力为 <code>FPS 100</code> ，显示器的刷新频率是 <code>75Hz</code> ，显卡将比显示器快 <code>1/3</code> ；这意味着，在一个刷新周期之内，显卡将写入 <code>4/3</code> 的帧数据，也就是说下一帧的 1/3 覆盖在前一帧之上；当然随着系统运行， 1/3 这个比例会发生变化，1/3，2/3，1，1/3，循环；这种帧与帧之间的不完全覆盖重合现象就是 <code>Tearing</code> 撕裂现象。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-tearing.png" alt="0113-android-graphics-display-tearing.png"></li>
</ul>
<p>显卡处理图像的帧速率和屏幕刷新频率是相互独立的，当两者不一致时会出现 <code>tearing</code> 问题，为了解决不一致的问题，引入了 <code>Vsync</code> 信号：当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，等待定期同步信号 <code>VSync</code> 信号，收到后才开始下一次屏幕刷新；所以 <code>VSync</code> 中的 <code>V</code> 指的是垂直刷新中的垂直 <code>Vertical</code> 。<br><code>Vsync</code> 技术意味着，显卡显示性能极限被限制在屏幕刷新率以内了：在系统显卡处理的 <code>FPS</code> 高于屏幕刷新率时，显卡会将一部分时间浪费在等待上；因为没有可用的内存用于绘制，显卡需要等待 <code>Vsync</code> 信号才能绘制下一帧。  </p>
<ul>
<li><p>单缓存缓存模型<br>理想的情况是帧率和刷新频率相等，每绘制一帧，屏幕显示一帧，如下图所示；但是如果不一致，就会出现 <code>tearing</code> 。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-single-buffer.png" alt="0113-android-graphics-display-vsync-single-buffer.png"></p>
</li>
<li><p>双重缓存 <code>Double Buffer</code><br>两个缓存区分别为 <code>Back Buffer</code> 和 <code>Frame Buffer</code> 。 <code>GPU</code> 向 <code>Back Buffer</code> 中写数据，屏幕从 <code>Frame Buffer</code> 中读数据。当屏幕刷新完成后产生 <code>VSync</code> 信号，此时将数据从 <code>Back Buffer</code> 复制到 <code>Frame Buffer</code>，可认为该复制操作在瞬间完成；复制完后显示设备开始显示这帧数据，同时通知 <code>CPU/GPU</code> 绘制下一帧图像。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer.png" alt="0113-android-graphics-display-vsync-double-buffer.png"><br>但是当 <code>GPU/CPU</code> 绘制一帧的时间超过了 <code>Vsync</code> 时，屏幕刷新从 <code>Frame Buffer</code> 取到的数据仍然是上一帧数据，即两个 <code>Vsync</code> 周期显示同一帧数据，我们称为发生了掉帧 <code>Dropped Frame, Skipped Frame, Jank</code> 现象。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer-jank.png" alt="0113-android-graphics-display-vsync-double-buffer-jank.png"></p>
</li>
<li><p>三重缓存 <code>Triple Buffer</code><br>在双重缓存模型中，当 <code>Jank</code> 现象出现时， <code>GPU/CPU</code> 此时都处于闲置状态，所以引入了三重缓存的概念：在 <code>Jank</code> 时， <code>GPU/CPU</code> 在第三个 <code>Buffer</code> 中绘制数据：<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer.png" alt="0113-android-graphics-display-vsync-triple-buffer.png"><br>需要注意的是，第三个缓存并不是总是存在的，只要当需要的时候才会创建；而且也无法完全解决 <code>Jank</code> 现象，但是能缓解。<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer-jank.png" alt="0113-android-graphics-display-vsync-triple-buffer-jank.png"></p>
</li>
</ul>
<h3 id="60Hz-和-16-ms"><a href="#60Hz-和-16-ms" class="headerlink" title="60Hz 和 16 ms"></a>60Hz 和 16 ms</h3><p>从上面解释帧速率时提到，虽然人眼感知生理的极限 <code>85fps</code> ，但达到 <code>60fps</code> 时动画就已经有很好的体验，不会出现卡顿和迟滞现象；而最为关键的是 <code>60Hz</code> 是美国交流电的频率，如果屏幕刷新频率能够匹配交流电的频率就可以有效的预防屏幕中出现滚动条；所以：  </p>
<ul>
<li><code>60Hz</code> 的屏幕刷新率或者 <code>60fps</code> 的帧率，是人眼能够感知到比较流畅的数值  </li>
<li><code>1000ms/60=16ms</code> ， <code>16ms</code> 是指 <code>GPU/CPU</code> 在绘制图形时，必须在这个刷新频率内绘制完成，否则会出现丢帧现象  </li>
</ul>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a><code>BufferQueue</code></h3><p>实现了整个生产者消费者模型。 <code>BufferQueues</code> 是 <code>Android</code> 图形组件之间的粘合剂。它们是一对队列，可以调解缓冲区从生产者到消费者的固定周期。一旦生产者移交其缓冲区， <code>SurfaceFlinger</code> 便会负责将所有内容合成到显示部分。<br><code>BufferQueue</code> 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作）；相反缓冲区始终通过句柄进行传递。  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-bufferqueue.png" alt="0113-android-graphics-display-bufferqueue.png"></p>
<p><code>BufferQueue</code> 包含将图像流生产者与图像流消费者结合在一起的逻辑。图像生产者的一些示例包括由相机 <code>HAL</code> 或 <code>OpenGL ES</code> 游戏生成的相机预览。图像消费者的一些示例包括 <code>SurfaceFlinger</code> 或显示 <code>OpenGL ES</code> 流的另一个应用，如显示相机取景器的相机应用。<br><code>BufferQueue</code> 是将缓冲区池与队列相结合的数据结构，它使用 <code>Binder IPC</code> 在进程之间传递缓冲区。生产者接口，或者您传递给想要生成图形缓冲区的某个人的内容，即是 <code>IGraphicBufferProducer</code> （ <code>SurfaceTexture</code> 的一部分）。 <code>BufferQueue</code> 通常用于渲染到 <code>Surface</code> ，并且与 <code>GL</code> 消费者及其他任务一起消耗内容。 <code>BufferQueue</code> 可以在三种不同的模式下运行：  </p>
<ul>
<li>类同步模式<br>默认情况下， <code>BufferQueue</code> 在类同步模式下运行，在该模式下，从生产者进入的每个缓冲区都在消费者那退出。在此模式下不会舍弃任何缓冲区。如果生产者速度太快，创建缓冲区的速度比消耗缓冲区的速度更快，它将阻塞并等待可用的缓冲区。  </li>
<li>非阻塞模式<br><code>BufferQueue</code> 还可以在非阻塞模式下运行，在此类情况下，它会生成错误，而不是等待缓冲区。在此模式下也不会舍弃缓冲区。这有助于避免可能不了解图形框架的复杂依赖项的应用软件出现潜在死锁现象。  </li>
<li>舍弃模式<br><code>BufferQueue</code> 可以配置为丢弃旧缓冲区，而不是生成错误或进行等待。例如，如果对纹理视图执行 <code>GL</code> 渲染并尽快绘制，则必须丢弃缓冲区。  </li>
</ul>
<p>为了执行这项工作的大部分环节， <code>SurfaceFlinger</code> 就像另一个 <code>OpenGL ES</code> 客户端一样工作。例如当 <code>SurfaceFlinger</code> 正在积极地将一个缓冲区或两个缓冲区合成到第三个缓冲区中时，它使用的是 <code>OpenGL ES</code> 。  </p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>Android</code> 图形管道数据流如下图所示：   </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-graphics_pipeline.png" alt="01113-android-graphics-display-graphics_pipeline.png"></p>
<p>左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。 <code>SurfaceFlinger</code> 是合成器，而硬件混合渲染器是制作器。  </p>
<h3 id="组件小结"><a href="#组件小结" class="headerlink" title="组件小结"></a>组件小结</h3><ul>
<li>低级别组件  <ul>
<li><code>BufferQueue</code> 和 <code>gralloc</code> 。 <code>BufferQueue</code> 将可生成图形数据缓冲区的组件（生产者）连接到接受数据以便进行显示或进一步处理的组件（消费者）。通过供应商专用 <code>HAL</code> 接口实现的 <code>gralloc</code> 内存分配器将用于执行缓冲区分配任务。  </li>
<li><code>SurfaceFlinger, Hardware Composer</code> 和虚拟显示屏。 <code>SurfaceFlinger</code> 接受来自多个源的数据缓冲区，然后将它们进行合成并发送到显示屏。 <code>Hardware Composer HAL (HWC)</code> 确定使用可用硬件合成缓冲区的最有效的方法，虚拟显示屏使合成输出可在系统内使用（录制屏幕或通过网络发送屏幕）。  </li>
<li><code>Surface, Canvas, SurfaceHolder</code> 。 <code>Surface</code> 可生成一个通常由 <code>SurfaceFlinger</code> 使用的缓冲区队列。当渲染到 <code>Surface</code> 上时，结果最终将出现在传送给消费者的缓冲区中。 <code>Canvas API</code> 提供一种软件实现方法（支持硬件加速），用于直接在 <code>Surface</code> 上绘图（ <code>OpenGL ES</code> 的低级别替代方案）。与视图有关的任何内容均涉及到 <code>SurfaceHolder</code> ，其 <code>API</code> 可用于获取和设置 <code>Surface</code> 参数（如大小和格式）。  </li>
<li><code>EGLSurface, OpenGL ES</code> 。 <code>OpenGL ES (GLES)</code> 定义了用于与 <code>EGL</code> 结合使用的图形渲染 <code>API</code> 。 <code>EGI</code> 是一个规定如何通过操作系统创建和访问窗口的库（要绘制纹理多边形，请使用 <code>GLES</code> 调用；要将渲染放到屏幕上，请使用 <code>EGL</code> 调用）。 <code>ANativeWindow</code> ，它是 <code>Java Surface</code> 类的 <code>C/C++</code> 等价类，用于通过原生代码创建 <code>EGL</code> 窗口 <code>Surface</code> 。  </li>
<li><code>Vulkan</code> 。 <code>Vulkan</code> 是一种用于高性能 <code>3D</code> 图形的低开销、跨平台 <code>API</code> 。与 <code>OpenGL ES</code> 一样， <code>Vulkan</code> 提供用于在应用中创建高质量实时图形的工具。 <code>Vulkan</code> 的优势包括降低 <code>CPU</code> 开销以及支持 <code>SPIR-V</code> 二进制中间语言。  </li>
</ul>
</li>
<li>高级别组件<ul>
<li><code>SurfaceView</code> 和 <code>GLSurfaceView</code> 。 <code>SurfaceView</code> 结合了 <code>Surface</code> 和 <code>View</code> 。 <code>SurfaceView</code> 的 <code>View</code> 组件由 <code>SurfaceFlinger</code> （而不是应用）合成，从而可以通过单独的线程/进程渲染，并与应用界面渲染隔离。 <code>GLSurfaceView</code> 提供帮助程序类来管理 <code>EGL</code> 上下文、线程间通信以及与 <code>Activity</code> 生命周期的交互（但使用 <code>GLES</code> 时并不需要 <code>GLSurfaceView</code> ）。  </li>
<li><code>SurfaceTexture</code> 。 <code>SurfaceTexture</code> 将 <code>Surface</code> 和 <code>GLES</code> 纹理相结合来创建 <code>BufferQueue</code> ，而应用是 <code>BufferQueue</code> 的消费者。当生产者将新的缓冲区排入队列时，它会通知应用。应用会依次释放先前占有的缓冲区，从队列中获取新缓冲区并执行 <code>EGL</code> 调用，从而使 <code>GLES</code> 可将此缓冲区作为外部纹理使用。 <code>Android 7.0</code> 增加了对安全纹理视频播放的支持，以便用户能够对受保护的视频内容进行 <code>GPU</code> 后处理。  </li>
<li><code>TextureView</code> 。 <code>TextureView</code> 结合了 <code>View</code> 和 <code>SurfaceTexture</code> 。 <code>TextureView</code> 对 <code>SurfaceTexture</code> 进行包装，并负责响应回调以及获取新的缓冲区。在绘图时， <code>TextureView</code> 使用最近收到的缓冲区的内容作为其数据源，根据 <code>View</code> 状态指示，在它应该渲染的任何位置和以它应该采用的任何渲染方式进行渲染。 <code>View</code> 合成始终通过 <code>GLES</code> 来执行，这意味着内容更新可能会导致其他 <code>View</code> 元素重绘。  </li>
</ul>
</li>
</ul>
<p>高级别组件可以直接在 <code>APP</code> 中使用。  </p>
<h2 id="Buffer-Window-体系"><a href="#Buffer-Window-体系" class="headerlink" title="Buffer/Window 体系"></a><code>Buffer/Window</code> 体系</h2><h3 id="代码速查表"><a href="#代码速查表" class="headerlink" title="代码速查表"></a>代码速查表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system/core/libcutils/include/cutils/native_handle.h</span><br><span class="line">hardware/qcom/display/libgralloc/gralloc_priv.h</span><br><span class="line">frameworks/native/libs/nativebase/include/nativebase/nativebase.h</span><br><span class="line">frameworks/native/libs/nativewindow/include/system/window.h</span><br><span class="line">frameworks/native/libs/ui/include/ui/ANativeObjectBase.h</span><br><span class="line">frameworks/native/libs/ui/include/ui/GraphicBuffer.h</span><br><span class="line">frameworks/native/libs/gui/include/gui/Surface.h</span><br></pre></td></tr></table></figure>

<h3 id="native-handle-buffer-handle-t"><a href="#native-handle-buffer-handle-t" class="headerlink" title="native_handle/buffer_handle_t"></a><code>native_handle/buffer_handle_t</code></h3><p>先看 <code>native_handle</code> 这个结构体的定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native_handle.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version;        <span class="comment">/* sizeof(native_handle_t) */</span></span><br><span class="line">    <span class="keyword">int</span> numFds;         <span class="comment">/* number of file-descriptors at &amp;data[0] */</span></span><br><span class="line">    <span class="keyword">int</span> numInts;        <span class="comment">/* number of ints at &amp;data[numFds] */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wzero-length-array"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>];        <span class="comment">/* numFds + numInts ints */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>native_handle</code> 这个结构体，描述了一个数据结构，其中最关键的是 <code>data[0]</code> ，它是一个长度为 0 的数组，即 <code>native_handle</code> 是一个柔性数组。在标准的 <code>C/C++</code> 中,长度为 0 的数组是不被允许的，编译时会产生错误！长度为 0 的数组是 <code>C/C++</code> 的扩展，需要当前编译器支持这个扩展。从头文件注释中也可以看出，当使用的是 <code>clang</code> 编译器时，才会定义 <code>data[0]</code> 并且忽略数组为 0 的警告。  </p>
<p>从 <code>C/C++</code> 中柔性数组的用途来看， <code>native_handle</code> 表示的是一个不定长数据结构，实际意义指向连续分配的内存空间（除了 <code>native_handle</code> 之外）代表的数据结构（通常是 <code>private_handle_t</code> ）。这里这么做，是因为显示系统和每家实现平台相关度很高， <code>native_handle</code> 定义一个通用的数据结构，至于显示系统如何显示，每家自己去实现对应的 <code>private_handle_t</code> 。  </p>
<p><code>native_handle</code> 结构体中的注释写的很清楚， <code>numFds</code> 表示被指向数据结构包含几个文件描述符； <code>numInts</code> 表示被指向数据结构长度是多少个整型；有了这两个信息后，内存分配就很容易了，参考 <code>native_handle_create</code> 的源码实现：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native_handle.c</span></span><br><span class="line"><span class="keyword">native_handle_t</span>* native_handle_create(<span class="keyword">int</span> numFds, <span class="keyword">int</span> numInts) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numFds &lt; <span class="number">0</span> || numInts &lt; <span class="number">0</span> || numFds &gt; kMaxNativeFds </span><br><span class="line">            || numInts &gt; kMaxNativeInts) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 native_handle 分配连续的内存空间</span></span><br><span class="line">    <span class="comment">// 除了 native_handle 自身所占空间，还包含被指向数据结构的长度  </span></span><br><span class="line">    <span class="keyword">size_t</span> mallocSize = <span class="keyword">sizeof</span>(<span class="keyword">native_handle_t</span>) </span><br><span class="line">        + (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numFds + numInts));</span><br><span class="line">    <span class="keyword">native_handle_t</span>* h = <span class="built_in">malloc</span>(mallocSize);</span><br><span class="line">    <span class="keyword">if</span> (h) &#123;</span><br><span class="line">        h-&gt;version = <span class="keyword">sizeof</span>(<span class="keyword">native_handle_t</span>);</span><br><span class="line">        h-&gt;numFds = numFds;</span><br><span class="line">        h-&gt;numInts = numInts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结： <code>native_handle, native_handle_t</code> 表示一个不定长数据结构，而 <code>buffer_handle_t</code> 表示指向 <code>native_handle</code> 的指针。  </p>
<h3 id="private-handle-t"><a href="#private-handle-t" class="headerlink" title="private_handle_t"></a><code>private_handle_t</code></h3><p><code>private_handle_t</code> 描述的是一块缓存，因为和实现平台高度相关，我这里选取高通平台，先看头文件定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gralloc_priv.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> :</span> <span class="keyword">public</span> native_handle &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">native_handle_t</span> nativeHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">enum</span> &#123;</span><br><span class="line">            PRIV_FLAGS_FRAMEBUFFER        = <span class="number">0x00000001</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file-descriptors</span></span><br><span class="line">        <span class="keyword">int</span>     fd;</span><br><span class="line">        <span class="keyword">int</span>     fd_metadata;          <span class="comment">// fd for the meta-data</span></span><br><span class="line">        <span class="comment">// ints</span></span><br><span class="line">        <span class="keyword">int</span>     magic;</span><br><span class="line">        <span class="keyword">int</span>     flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  size;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  offset;</span><br><span class="line">        <span class="keyword">int</span>     bufferType;</span><br><span class="line">        <span class="keyword">uint64_t</span> base __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  offset_metadata;</span><br><span class="line">        <span class="comment">// The gpu address mapped into the mmu.</span></span><br><span class="line">        <span class="keyword">uint64_t</span> gpuaddr __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line">        <span class="keyword">int</span>     format;</span><br><span class="line">        <span class="keyword">int</span>     width;   <span class="comment">// holds aligned width of the actual buffer allocated</span></span><br><span class="line">        <span class="keyword">int</span>     height;  <span class="comment">// holds aligned height of the  actual buffer allocated</span></span><br><span class="line">        <span class="keyword">uint64_t</span> base_metadata __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line">        <span class="keyword">int</span> unaligned_width;   <span class="comment">// holds width client asked to allocate</span></span><br><span class="line">        <span class="keyword">int</span> unaligned_height;  <span class="comment">// holds height client asked to allocate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sNumFds = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sNumInts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">sizeof</span>(<span class="keyword">private_handle_t</span>) - <span class="keyword">sizeof</span>(<span class="keyword">native_handle_t</span>)) /</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) - sNumFds;</span><br><span class="line">        &#125;</span><br><span class="line">        static const int sMagic = 'gmsm';</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>private_handle_t</code> 描述了缓存区使用的文件描述符 <code>fd, fd_metadata</code> 、大小、偏移量、基地址、长宽、格式、没有对齐的长宽等等，而 <code>sNumFds</code> 对应 <code>nativeHandle.numFds</code> ； <code>sNumInts</code> 对应 <code>nativeHandle.numInts</code> ，即除了文件描述符之外，该数据结构的长度。<br>小结： <code>private_handle_t</code> 在各个模块之间传递的时候很不方便，而如果用 <code>native_handle</code> 的来传递，就可以消除平台的差异性。一个简单示意图描述两者的关系：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0109-android-camera-5-hal-buffer_handle_t.png" alt="0109-android-camera-5-hal-buffer_handle_t.png"></p>
<p>至此，我们可以简单的理解为 <code>native_handle, native_handle_t, private_handle_t, buffer_handle_t</code> 表示的是同一块内存。  </p>
<h3 id="ANativeWindowBuffer"><a href="#ANativeWindowBuffer" class="headerlink" title="ANativeWindowBuffer"></a><code>ANativeWindowBuffer</code></h3><p>先了解 <code>android_native_base_t</code> 数据结构的定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">android_native_base_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* a magic value defined by the actual EGL native type */</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the sizeof() of the actual EGL native type */</span></span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reference-counting interface */</span></span><br><span class="line">    <span class="keyword">void</span> (*incRef)(struct <span class="keyword">android_native_base_t</span>* base);</span><br><span class="line">    <span class="keyword">void</span> (*decRef)(struct <span class="keyword">android_native_base_t</span>* base);</span><br><span class="line">&#125; <span class="keyword">android_native_base_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>android_native_base_t</code> 中 <code>incRef/decRef</code> 主要功能是：为了把派生类和 <code>Android</code> 所有 <code>class</code> 的老祖宗 <code>RefBase</code> 联系起来所预留的函数指针。  </p>
<p>再看 <code>ANativeWindowBuffer</code> 数据结构的定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nativebase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindowBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    ANativeWindowBuffer() &#123;</span><br><span class="line">        common.magic = ANDROID_NATIVE_BUFFER_MAGIC;</span><br><span class="line">        common.version = <span class="keyword">sizeof</span>(ANativeWindowBuffer);</span><br><span class="line">        <span class="built_in">memset</span>(common.reserved, <span class="number">0</span>, <span class="keyword">sizeof</span>(common.reserved));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement the methods that sp&lt;ANativeWindowBuffer&gt; expects so that it</span></span><br><span class="line">    <span class="comment">// can be used to automatically refcount ANativeWindowBuffer's.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        common.incRef(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        common.decRef(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">android_native_base_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> stride;</span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line">    <span class="keyword">int</span> usage_deprecated;</span><br><span class="line">    <span class="keyword">uintptr_t</span> layerCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* handle;</span><br><span class="line">    <span class="keyword">uint64_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we needed extra space for storing the 64-bits usage flags</span></span><br><span class="line">    <span class="comment">// the number of slots to use from reserved_proc depends on the</span></span><br><span class="line">    <span class="comment">// architecture.</span></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">8</span> - (<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">void</span>*))];</span><br><span class="line">&#125; ANativeWindowBuffer_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindowBuffer</span> <span class="title">ANativeWindowBuffer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Old typedef for backwards compatibility.</span></span><br><span class="line"><span class="keyword">typedef</span> ANativeWindowBuffer_t <span class="keyword">android_native_buffer_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>ANativeWindowBuffer</code> 中使用了 <code>native_handle_t</code> 指针，同时该结构体中也有长宽、格式、步进等基本描述信息；也就是 <code>ANativeWindowBuffer</code> 描述的是一块 <code>Window</code> 相关的缓存区。  </p>
<h3 id="ANativeWindow"><a href="#ANativeWindow" class="headerlink" title="ANativeWindow"></a><code>ANativeWindow</code></h3><p><code>ANativeWindow</code> 数据结构的定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    ANativeWindow()</span><br><span class="line">        : flags(<span class="number">0</span>), minSwapInterval(<span class="number">0</span>), maxSwapInterval(<span class="number">0</span>), xdpi(<span class="number">0</span>), ydpi(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        common.magic = ANDROID_NATIVE_WINDOW_MAGIC;</span><br><span class="line">        common.version = <span class="keyword">sizeof</span>(ANativeWindow);</span><br><span class="line">        <span class="built_in">memset</span>(common.reserved, <span class="number">0</span>, <span class="keyword">sizeof</span>(common.reserved));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Implement the methods that sp&lt;ANativeWindow&gt; expects so that it</span></span><br><span class="line"><span class="comment">       can be used to automatically refcount ANativeWindow's. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        common.incRef(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        common.decRef(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">android_native_base_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* flags describing some attributes of this surface or its updater */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* min swap interval supported by this updated */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   minSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* max swap interval supported by this updated */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   maxSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* horizontal and vertical resolution in DPI */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> xdpi;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ydpi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some storage reserved for the OEM's driver. */</span></span><br><span class="line">    <span class="keyword">intptr_t</span>    oem[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>     (*setSwapInterval)(struct ANativeWindow* window,</span><br><span class="line">                <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="keyword">int</span>     (*dequeueBuffer_DEPRECATED)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer** buffer);</span><br><span class="line">    <span class="keyword">int</span>     (*lockBuffer_DEPRECATED)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="keyword">int</span>     (*queueBuffer_DEPRECATED)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="keyword">int</span>     (*query)(<span class="keyword">const</span> struct ANativeWindow* window,</span><br><span class="line">                <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line">    <span class="keyword">int</span>     (*perform)(struct ANativeWindow* window,</span><br><span class="line">                <span class="keyword">int</span> operation, ... );</span><br><span class="line">    <span class="keyword">int</span>     (*cancelBuffer_DEPRECATED)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="keyword">int</span>     (*dequeueBuffer)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer** buffer, <span class="keyword">int</span>* fenceFd);</span><br><span class="line">    <span class="keyword">int</span>     (*queueBuffer)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer* buffer, <span class="keyword">int</span> fenceFd);</span><br><span class="line">    <span class="keyword">int</span>     (*cancelBuffer)(struct ANativeWindow* window,</span><br><span class="line">                struct ANativeWindowBuffer* buffer, <span class="keyword">int</span> fenceFd);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Backwards compatibility: use ANativeWindow (struct ANativeWindow in C).</span></span><br><span class="line"><span class="comment">  * android_native_window_t is deprecated.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindow</span> <span class="title">android_native_window_t</span> __<span class="title">deprecated</span>;</span></span><br></pre></td></tr></table></figure>

<p>从数据结构定义中可以看出， <code>ANativeWindow</code> 和窗口属性相关，它表示的是一个底层实现的窗口，定义的各种函数指针都是对 <code>ANativeWindowBuffer</code> 内存的操作；而 <code>fenceFd</code> 可以看成这个 <code>buffer</code> 的锁。  </p>
<p>小结：不管是 <code>ANativeWindow, ANativeWindowBuffer</code> 它们都包含 <code>android_native_base_t</code> 结构体，但是都没有对 <code>incRef, decRef</code> 赋值；可以认为 <code>ANativeWindow, ANativeWindowBuffer</code> 为抽象数据结构。  </p>
<h3 id="ANativeObjectBase-模板"><a href="#ANativeObjectBase-模板" class="headerlink" title="ANativeObjectBase 模板"></a><code>ANativeObjectBase</code> 模板</h3><p><code>ANativeObjectBase</code> 是一个模板类，定义如下：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ANativeObjectBase.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NATIVE_TYPE, <span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> REF,</span><br><span class="line">        <span class="keyword">typename</span> NATIVE_BASE = <span class="keyword">android_native_base_t</span>&gt;</span><br><span class="line">class ANativeObjectBase : <span class="keyword">public</span> NATIVE_TYPE, <span class="keyword">public</span> REF</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Disambiguate between the incStrong in REF and NATIVE_TYPE</span></span><br><span class="line">    <span class="keyword">void</span> incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> &#123;</span><br><span class="line">        REF::incStrong(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        REF::decStrong(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ANativeObjectBase&lt;NATIVE_TYPE, TYPE, REF, NATIVE_BASE&gt; BASE;</span><br><span class="line">    ANativeObjectBase() : NATIVE_TYPE(), REF() &#123;</span><br><span class="line">        NATIVE_TYPE::common.incRef = incRef;</span><br><span class="line">        NATIVE_TYPE::common.decRef = decRef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TYPE* <span class="title">getSelf</span><span class="params">(NATIVE_TYPE* self)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;TYPE*&gt;(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TYPE <span class="keyword">const</span>* <span class="title">getSelf</span><span class="params">(NATIVE_TYPE <span class="keyword">const</span>* self)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;TYPE <span class="keyword">const</span> *&gt;(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TYPE* <span class="title">getSelf</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSelf(<span class="keyword">reinterpret_cast</span>&lt;NATIVE_TYPE*&gt;(base));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TYPE <span class="keyword">const</span> * <span class="title">getSelf</span><span class="params">(NATIVE_BASE <span class="keyword">const</span>* base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSelf(<span class="keyword">reinterpret_cast</span>&lt;NATIVE_TYPE <span class="keyword">const</span>*&gt;(base));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incRef</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        ANativeObjectBase* self = getSelf(base);</span><br><span class="line">        self-&gt;incStrong(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decRef</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        ANativeObjectBase* self = getSelf(base);</span><br><span class="line">        self-&gt;decStrong(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace android</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cplusplus</span></span></span><br></pre></td></tr></table></figure>

<p><code>ANativeObjectBase</code> 模板类的主要作用就是实现 <code>incRef, decRef</code> 引用计数，以及父类子类的类型转换。  </p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a><code>GraphicBuffer</code></h3><p>先看 <code>GraphicBuffer</code> 的头文件定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GraphicBuffer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicBuffer</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer, RefBase&gt;,</span><br><span class="line">      <span class="keyword">public</span> Flattenable&lt;GraphicBuffer&gt;</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><code>GraphicBuffer</code> 使用 <code>ANativeObjectBase</code> 模板，即 <code>GraphicBuffer</code> 就是 <code>ANativeWindowBuffer</code> 的一种具体实现；而 <code>ANativeWindowBuffer.common</code> 成员的两个函数指针 <code>incRef, decRef</code> 指向了 <code>GraphicBuffer</code> 的另一个基类 <code>RefBase</code> 的 <code>incStrong, decStrong</code> ；而 <code>ANativeWindowBuffer</code> 可以看做是把 <code>buffer_handle_t</code> 包了一层，所以 <code>GraphicBuffer</code> 也是指向的一块缓存区。  </p>
<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a><code>Surface</code></h3><p><code>Surface</code> 的头文件定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">    &#125;;</span><br><span class="line">    BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Surface</code> 也使用了 <code>ANativeObjectBase</code> 模板，即 <code>Surface</code> 就是 <code>ANativeWindow</code> 的一种具体实现，同样也继承了 <code>RefBase</code> 实现引用计数。另外成员数据结构 <code>BufferSlot</code> 是对 <code>GraphicBuffer</code> 的包装，而 <code>mSlots</code> 数组表示每个 <code>Surface</code> 中包含 <code>NUM_BUFFER_SLOTS</code> 个 <code>GraphicBuffer</code> 缓存。<br>而 <code>Surface</code> 的构造函数中，也将 <code>ANativeWindow</code> 的函数指针进行了赋值：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line">Surface::Surface(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, </span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">      : mGraphicBufferProducer(bufferProducer),</span><br><span class="line">        mCrop(Rect::EMPTY_RECT),</span><br><span class="line">        mBufferAge(<span class="number">0</span>),</span><br><span class="line">        mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">        mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">        mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">        mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">        mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">        mQueriedSupportedTimestamps(<span class="literal">false</span>),</span><br><span class="line">        mFrameTimestampsSupportsPresent(<span class="literal">false</span>),</span><br><span class="line">        mEnableFrameTimestamps(<span class="literal">false</span>),</span><br><span class="line">       mFrameEventHistory(<span class="built_in">std</span>::make_unique&lt;ProducerFrameEventHistory&gt;())&#123;</span><br><span class="line">    <span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">    ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">    ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">    ANativeWindow::query            = hook_query;</span><br><span class="line">    ANativeWindow::perform          = hook_perform;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>native_handle/native_handle_t</code> 是 <code>private_handle_t</code> 的抽象表示方法，消除平台相关性；方便 <code>private_handle_t</code> 所表示的缓存区可以在 <code>Android</code> 各个层次之间传递；而 <code>buffer_handle_t</code> 是指向他们的指针  </li>
<li><code>ANativeWindowBuffer</code> 将 <code>buffer_handle_t</code> 进行了包装；<code>ANativeWindow, ANativeWindowBuffer</code> 都继承于 <code>android_native_base_t</code> ，它定义了引用计数两个函数指针；可以认为 <code>ANativeWindow, ANativeWindowBuffer</code> 为抽象数据结构，表示窗口和其对应缓存  </li>
<li><code>GraphicBuffer, Surface</code> 都使用了模版类 <code>ANativeObjectBase</code> ，都继承了 <code>RefBase</code> 实现 <code>incRef, decRef</code> 引用计数；它们是具体的实现类，即实现具体的窗口缓存和窗口  </li>
<li><code>Surface</code> 的成员 <code>BufferSlot mSlots[NUM_BUFFER_SLOTS];</code> 可以看作是 <code>sp&lt;GraphicBuffer&gt;</code> 类型的数组；也就是说每个 <code>Surface</code> 中都包含有 <code>NUM_BUFFER_SLOTS</code> 个 <code>GraphicBuffer</code>  </li>
<li><code>Surface, GraphicBuffer</code> 是图形显示系统的高层类，后续主要围绕这两个类来介绍；一个代表窗口，一个代表窗口对应的缓存  </li>
</ul>
<p><a href="https://upload-images.jianshu.io/upload_images/606437-20bbb0ebba7fd244.png" target="_blank" rel="noopener">Buffer/Window 体系缓存，查看大图</a>  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-surface-buffer.png" alt="0113-android-graphics-display-surface-buffer.png"></p>
<p><code>BufferQueue</code> 中的 <code>Buffer</code> 对象，我们用的都是 <code>GraphicBuffer</code> 。 <code>Surface</code> 是 <code>Andorid</code> 窗口的描述，是 <code>ANativeWindow</code> 的实现；同样 <code>GraphicBuffer</code> 是 <code>Android</code> 中图形 <code>Buffer</code> 的描述，是 <code>ANativeWindowBuffer</code> 的实现。而一个窗口可以有多个 <code>Buffer</code> 。  </p>
<h2 id="libui-库"><a href="#libui-库" class="headerlink" title="libui 库"></a><code>libui</code> 库</h2><p><code>libui.so</code> 库主要是 <code>GraphicBuffer</code> 缓存相关的代码，包含缓存分配，映射当当前进程等等，而 <code>IAllocator, IMapper</code> 具体是在 <code>HAL</code> 中实现的。  </p>
<h3 id="代码目录结构"><a href="#代码目录结构" class="headerlink" title="代码目录结构"></a>代码目录结构</h3><p><code>frameworks/native/libs/ui</code> 目录结构：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ui</span><br><span class="line">├── Android.bp</span><br><span class="line">├── ColorSpace.cpp</span><br><span class="line">├── DebugUtils.cpp</span><br><span class="line">├── Fence.cpp</span><br><span class="line">├── FenceTime.cpp</span><br><span class="line">├── FrameStats.cpp</span><br><span class="line">├── Gralloc2.cpp</span><br><span class="line">├── GraphicBufferAllocator.cpp</span><br><span class="line">├── GraphicBuffer.cpp</span><br><span class="line">├── GraphicBufferMapper.cpp</span><br><span class="line">├── HdrCapabilities.cpp</span><br><span class="line">├── include</span><br><span class="line">│   └── ui</span><br><span class="line">│       ├── ANativeObjectBase.h</span><br><span class="line">│       ├── BufferQueueDefs.h</span><br><span class="line">│       ├── ColorSpace.h</span><br><span class="line">│       ├── DebugUtils.h</span><br><span class="line">│       ├── DisplayInfo.h</span><br><span class="line">│       ├── DisplayStatInfo.h</span><br><span class="line">│       ├── Fence.h</span><br><span class="line">│       ├── FenceTime.h</span><br><span class="line">│       ├── FloatRect.h</span><br><span class="line">│       ├── FrameStats.h</span><br><span class="line">│       ├── Gralloc2.h</span><br><span class="line">│       ├── GraphicBufferAllocator.h</span><br><span class="line">│       ├── GraphicBuffer.h</span><br><span class="line">│       ├── GraphicBufferMapper.h</span><br><span class="line">│       ├── HdrCapabilities.h</span><br><span class="line">│       ├── PixelFormat.h</span><br><span class="line">│       ├── Point.h</span><br><span class="line">│       ├── Rect.h</span><br><span class="line">│       ├── Region.h</span><br><span class="line">│       └── UiConfig.h</span><br><span class="line">├── MODULE_LICENSE_APACHE2</span><br><span class="line">├── NOTICE</span><br><span class="line">├── PixelFormat.cpp</span><br><span class="line">├── Rect.cpp</span><br><span class="line">├── Region.cpp</span><br><span class="line">├── tests</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   ├── colorspace_test.cpp</span><br><span class="line">│   └── Region_test.cpp</span><br><span class="line">├── tools</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   └── lutgen.cpp</span><br><span class="line">└── UiConfig.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 42 files</span><br></pre></td></tr></table></figure>

<h3 id="GraphicBufferAllocator-GraphicBufferMapper"><a href="#GraphicBufferAllocator-GraphicBufferMapper" class="headerlink" title="GraphicBufferAllocator/GraphicBufferMapper"></a><code>GraphicBufferAllocator/GraphicBufferMapper</code></h3><p>它们两个都是包装类，包装了 <code>IAllocator, IMapper</code> ，而这两个类都是在 <code>HAL Gralloc2</code> 中实现的。  </p>
<ul>
<li><code>GraphicBufferAllocator</code><br>缓存分配，包装了 <code>IAllocator</code> 类。  </li>
<li><code>GraphicBufferMapper</code><br>缓存映射到当前进程，包装了 <code>IMapper</code> 类。  </li>
</ul>
<h3 id="GraphicBuffer-1"><a href="#GraphicBuffer-1" class="headerlink" title="GraphicBuffer"></a><code>GraphicBuffer</code></h3><p><code>GraphicBuffer</code> 继承 <code>ANativeWindowBuffer</code> ，并持有 <code>GraphicBufferMapper</code> 映射对应的缓存区。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicBuffer</span> :</span> </span><br><span class="line">    <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer,RefBase&gt;,</span><br><span class="line">    <span class="keyword">public</span> Flattenable&lt;GraphicBuffer&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> sp&lt;GraphicBuffer&gt; from(ANativeWindowBuffer *);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GraphicBufferMapper&amp; mBufferMapper;</span><br><span class="line">    <span class="keyword">ssize_t</span> mInitCheck;</span><br><span class="line">    <span class="keyword">uint64_t</span> mId;</span><br><span class="line">    <span class="keyword">uint32_t</span> mGenerationNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Fence-机制"><a href="#Fence-机制" class="headerlink" title="Fence 机制"></a><code>Fence</code> 机制</h3><p><code>Fence</code> 是一种同步机制，主要用于 <code>GraphicBuffer</code> 的同步。它主要被用来处理跨硬件的情况，尤其是 <code>CPU, GPU, HWC</code> 之间的同步，另外它还可以用于多个时间点之间的同步。 <code>GPU</code> 编程和纯 <code>CPU</code> 编程一个很大的不同是它是异步的，也就是说当我们调用 <code>GL command</code> 返回时这条命令并不一定完成了，只是把这个命令放在本地的 <code>command buffer</code> 里，而 <code>Fence</code> 机制就是解决这些同步问题的。<br><code>Fence</code> 顾名思义就是把先到的拦住，等后来的，两者步调一致了再往前走。抽象地说，<code>Fence</code> 包含了同一或不同时间轴上的多个时间点，只有当这些点同时到达时 <code>Fence</code> 才会被触发。 <code>Fence</code> 可以由硬件实现 <code>Graphic driver</code>，也可以由软件实现 <code>Android kernel</code> 中的 <code>sw_sync</code> 。  </p>
<p><code>Fence</code> 的主要实现代码路径：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/libs/ui/Fence.cpp</span><br><span class="line">system/core/libsync/sync.c</span><br><span class="line">kernel/drivers/base/sync.c</span><br><span class="line">frameworks/native/libs/gui/SyncFeatures.cpp</span><br></pre></td></tr></table></figure>

<p>总得来说， <code>kernel driver</code> 部分是同步的主要实现，<code>libsync</code> 是对 <code>driver</code> 接口的封装， <code>Fence</code> 是对 <code>libsync</code> 的进一步的 <code>C++</code> 封装。 <code>Fence</code> 会被作为 <code>GraphicBuffer</code> 的附属随着 <code>GraphicBuffer</code> 在生产者和消费间传输； <code>SyncFeatures</code> 用以查询系统支持的同步机制。  </p>
<h3 id="DisplayInfo-显示信息"><a href="#DisplayInfo-显示信息" class="headerlink" title="DisplayInfo 显示信息"></a><code>DisplayInfo</code> 显示信息</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayInfo.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisplayInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> w&#123;<span class="number">0</span>&#125;;                      <span class="comment">// 屏幕的宽</span></span><br><span class="line">    <span class="keyword">uint32_t</span> h&#123;<span class="number">0</span>&#125;;                      <span class="comment">// 屏幕的高</span></span><br><span class="line">    <span class="keyword">float</span> xdpi&#123;<span class="number">0</span>&#125;;                      <span class="comment">// 屏幕 x 方向每英寸的像素点</span></span><br><span class="line">    <span class="keyword">float</span> ydpi&#123;<span class="number">0</span>&#125;;                      <span class="comment">// 屏幕 y 方向每英寸的像素点</span></span><br><span class="line">    <span class="keyword">float</span> fps&#123;<span class="number">0</span>&#125;;                       <span class="comment">// FPS 屏幕的刷新率</span></span><br><span class="line">    <span class="keyword">float</span> density&#123;<span class="number">0</span>&#125;;                   <span class="comment">// 屏幕的密度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> orientation&#123;<span class="number">0</span>&#125;;             <span class="comment">// 屏幕的旋转方式</span></span><br><span class="line">    <span class="keyword">bool</span> secure&#123;<span class="literal">false</span>&#125;;                 <span class="comment">// 屏幕是否是安全的</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> appVsyncOffset&#123;<span class="number">0</span>&#125;;          <span class="comment">// App 的 Vsync 的偏移</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> presentationDeadline&#123;<span class="number">0</span>&#125;;    <span class="comment">// 显示的最后时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Display orientations as defined in Surface.java </span></span><br><span class="line"><span class="comment">    and ISurfaceComposer.h. */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DISPLAY_ORIENTATION_0 = <span class="number">0</span>,</span><br><span class="line">    DISPLAY_ORIENTATION_90 = <span class="number">1</span>,</span><br><span class="line">    DISPLAY_ORIENTATION_180 = <span class="number">2</span>,</span><br><span class="line">    DISPLAY_ORIENTATION_270 = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>

<p><code>DisplayInfo</code> 结构体包含了显示屏幕的基本信息：  </p>
<ul>
<li>屏幕分辨率 <code>Resolution</code><br>屏幕的宽高是用分辨率 <code>Resolution</code> 来描述的，也就是有多少个像素点。屏幕宽度，即屏幕横向可以显示多少个像素点；屏幕高度，即屏幕纵向可以显示多少给像素点。平常所说的 <code>720P: 1080x720</code> 屏幕，即横向可以显示 1080 个像素点，纵向可以显示 720 个像素点。如下为常见屏幕分辨率：<br><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-resolution.png" alt="0113-android-graphics-display-resolution.png"></li>
<li>屏幕 <code>DPI</code><br><code>DPI: Dots Per Inch</code> 每英寸点数，是一个度量单位，表示屏幕每英寸上有多少个物理点。常见屏幕物理大小，是用英寸来描述屏幕对角线的长度，比如 <code>IPhone X</code> 的大小 5.8 寸，即屏幕对角线长度为 5.8 英寸。*<em>标准 <code>DPI</code> 为 <code>160dpi</code> *</em>，人类视网膜级通常为 <code>300dpi</code> 。<br><code>PPI: Pixel Per Inch</code> 每英寸像素，也是度量单位，表示每英寸显示多少个像素。通常情况下 <code>DPI, PPI</code> 设为相同，表示每个物理点显示一个像素；但是好一点的显示器，可能 <code>DPI</code> 比 <code>PPI</code> 大，即一个像素由多个物理点来显示。  </li>
<li>密度 <code>Density</code><br><code>DIP: Density Independent Pixels</code> 设备无关像素，通常简写为 <code>DP=DIP</code>，请注意 <code>DPI</code> 做好区分。 <code>DP</code> 表示这个像素的数值是和设备无关的，那实际转换时怎么转换呢？<br><code>Density</code> 密度，实际是一个缩放因子，它表示当前设备实际 <code>DPI</code> 和标准 <code>DPI</code> 的比例值；比如设备实际 <code>DPI</code> 为 <code>320dpi</code> ，那么 <code>density=320/160=2</code> ，即 <code>density</code> 为 2 。有了 <code>density</code> 之后， <code>dp, px</code> 可以使用公式来转换 <code>px=density*dp</code> 。<br>所以我们在 <code>APP</code> 布局设计中，所有显示设置的距离，通常使用 <code>dp</code> 来计算，来规避不同屏幕特性。  </li>
<li>屏幕刷新率 <code>FPS</code><br>这里屏幕刷新率使用 <code>FPS</code> 来表示，不是 <code>Hz</code> ，表示屏幕每秒能显示多少帧数据；通常为 60 fps ，即 16 ms 刷新一次。  </li>
<li>屏幕旋转方向 <code>orientations</code><br>手机默认竖屏，0 表示竖屏， 180 表示横屏。  </li>
<li>屏幕安全性 <code>secure</code><br>这主要是用于 <code>DRM</code> 数字版权保护时，确保显示的设备是安全的，以防止 <code>DRM</code> 的内容被在显示的过程中被截取，只有安全的设备才能显示 <code>DRM</code> 的内容。 <code>Android</code> 默认所有的非虚拟显示都是安全的。  </li>
<li><code>appVsyncOffset, presentationDeadline</code><br>这两个都和 <code>Vsync</code> 有关； <code>appVsyncOffset</code> 是一个偏移量，在系统或硬件 <code>Vsync</code> 的基础上做一些偏移； <code>presentationDeadline</code> 表示，一帧数据必现在这个时间内显示出来。  </li>
</ul>
<h2 id="libgui-库"><a href="#libgui-库" class="headerlink" title="libgui 库"></a><code>libgui</code> 库</h2><h3 id="代码目录结构-1"><a href="#代码目录结构-1" class="headerlink" title="代码目录结构"></a>代码目录结构</h3><p><code>frameworks/native/libs/gui</code> 目录结构：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">gui/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── BitTube.cpp</span><br><span class="line">├── BufferItemConsumer.cpp</span><br><span class="line">├── BufferItem.cpp</span><br><span class="line">├── bufferqueue</span><br><span class="line">│   └── 1.0</span><br><span class="line">│       ├── B2HProducerListener.cpp</span><br><span class="line">│       └── H2BGraphicBufferProducer.cpp</span><br><span class="line">├── BufferQueueConsumer.cpp</span><br><span class="line">├── BufferQueueCore.cpp</span><br><span class="line">├── BufferQueue.cpp</span><br><span class="line">├── BufferQueueProducer.cpp</span><br><span class="line">├── BufferSlot.cpp</span><br><span class="line">├── CleanSpec.mk</span><br><span class="line">├── ConsumerBase.cpp</span><br><span class="line">├── CpuConsumer.cpp</span><br><span class="line">├── DisplayEventReceiver.cpp</span><br><span class="line">├── FrameTimestamps.cpp</span><br><span class="line">├── GLConsumer.cpp</span><br><span class="line">├── GuiConfig.cpp</span><br><span class="line">├── IConsumerListener.cpp</span><br><span class="line">├── IDisplayEventConnection.cpp</span><br><span class="line">├── IGraphicBufferConsumer.cpp</span><br><span class="line">├── IGraphicBufferProducer.cpp</span><br><span class="line">├── include</span><br><span class="line">│   ├── gui</span><br><span class="line">│   │   ├── BufferItemConsumer.h</span><br><span class="line">│   │   ├── BufferItem.h</span><br><span class="line">│   │   ├── bufferqueue</span><br><span class="line">│   │   │   └── 1.0</span><br><span class="line">│   │   │       ├── B2HProducerListener.h</span><br><span class="line">│   │   │       └── H2BGraphicBufferProducer.h</span><br><span class="line">│   │   ├── BufferQueueConsumer.h</span><br><span class="line">│   │   ├── BufferQueueCore.h</span><br><span class="line">│   │   ├── BufferQueueDefs.h</span><br><span class="line">│   │   ├── BufferQueue.h</span><br><span class="line">│   │   ├── BufferQueueProducer.h</span><br><span class="line">│   │   ├── BufferSlot.h</span><br><span class="line">│   │   ├── ConsumerBase.h</span><br><span class="line">│   │   ├── CpuConsumer.h</span><br><span class="line">│   │   ├── DisplayEventReceiver.h</span><br><span class="line">│   │   ├── FrameTimestamps.h</span><br><span class="line">│   │   ├── GLConsumer.h</span><br><span class="line">│   │   ├── GuiConfig.h</span><br><span class="line">│   │   ├── IConsumerListener.h</span><br><span class="line">│   │   ├── IDisplayEventConnection.h</span><br><span class="line">│   │   ├── IGraphicBufferConsumer.h</span><br><span class="line">│   │   ├── IGraphicBufferProducer.h</span><br><span class="line">│   │   ├── IProducerListener.h</span><br><span class="line">│   │   ├── ISurfaceComposerClient.h</span><br><span class="line">│   │   ├── ISurfaceComposer.h</span><br><span class="line">│   │   ├── OccupancyTracker.h</span><br><span class="line">│   │   ├── StreamSplitter.h</span><br><span class="line">│   │   ├── SurfaceComposerClient.h</span><br><span class="line">│   │   ├── SurfaceControl.h</span><br><span class="line">│   │   ├── Surface.h</span><br><span class="line">│   │   └── view</span><br><span class="line">│   │       └── Surface.h</span><br><span class="line">│   └── private</span><br><span class="line">│       └── gui</span><br><span class="line">│           ├── BitTube.h</span><br><span class="line">│           ├── ComposerService.h</span><br><span class="line">│           ├── LayerState.h</span><br><span class="line">│           └── SyncFeatures.h</span><br><span class="line">├── IProducerListener.cpp</span><br><span class="line">├── ISurfaceComposerClient.cpp</span><br><span class="line">├── ISurfaceComposer.cpp</span><br><span class="line">├── LayerState.cpp</span><br><span class="line">├── OccupancyTracker.cpp</span><br><span class="line">├── StreamSplitter.cpp</span><br><span class="line">├── SurfaceComposerClient.cpp</span><br><span class="line">├── SurfaceControl.cpp</span><br><span class="line">├── Surface.cpp</span><br><span class="line">├── SyncFeatures.cpp</span><br><span class="line">├── tests</span><br><span class="line">│   ├── ...</span><br><span class="line">└── view</span><br><span class="line">    └── Surface.cpp</span><br><span class="line"></span><br><span class="line">11 directories, 96 files</span><br></pre></td></tr></table></figure>

<p>其中 <code>H2B, B2H</code> 表示 <code>Framework Buffer</code> 和 <code>HAL</code> 层数据结构的相互转换；实际上代表的是同一样东西，方便各层内部使用。  </p>
<h3 id="IGraphicBufferProducer-IProducerListener-生产者"><a href="#IGraphicBufferProducer-IProducerListener-生产者" class="headerlink" title="IGraphicBufferProducer/IProducerListener 生产者"></a><code>IGraphicBufferProducer/IProducerListener</code> 生产者</h3><p><code>IGraphicBufferProducer</code> 是生产者接口，实现了 <code>IInterface</code> 可以用于跨进程通信。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGraphicBufferProducer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IGraphicBufferProducer</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_HYBRID_META_INTERFACE(GraphicBufferProducer, </span><br><span class="line">        HGraphicBufferProducer)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据指定参数申请一块 Buffer ，索引值为 slot ，同步为 fence</span></span><br><span class="line">    <span class="comment">// 从 BufferQueue 中出队一块缓存 GraphicBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* slot, sp&lt;Fence&gt;* fence, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">        PixelFormat format, <span class="keyword">uint64_t</span> usage, <span class="keyword">uint64_t</span>* outBufferAge,</span></span></span><br><span class="line"><span class="function"><span class="params">        FrameEventHistoryDelta* outTimestamps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取 slot 位置的 GraphicBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 客户端已经向 slot 位置的 Buffer 填充完数据 </span></span><br><span class="line">    <span class="comment">// IGraphicBufferProducer 得到 Buffer 的输入信息，</span></span><br><span class="line">    <span class="comment">// slot 这块缓存 GraphicBuffer 进入队列 BufferQueue</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">queueBuffer</span><span class="params">(<span class="keyword">int</span> slot, <span class="keyword">const</span> QueueBufferInput&amp; input,</span></span></span><br><span class="line"><span class="function"><span class="params">            QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 释放 slot 位置的 GraphicBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">detachNextBuffer</span><span class="params">(sp&lt;GraphicBuffer&gt;* outBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            sp&lt;Fence&gt;* outFence)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据指定的 buffer 获取 slot</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 释放 slot 位置的 buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">cancelBuffer</span><span class="params">(<span class="keyword">int</span> slot, <span class="keyword">const</span> sp&lt;Fence&gt;&amp; fence)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 客户端根据 api 类型，连接 IGraphicBufferProducer ，</span></span><br><span class="line">    <span class="comment">// 客户端得到缓存的相关信息 QueueBufferOutput</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">connect</span><span class="params">(<span class="keyword">const</span> sp&lt;IProducerListener&gt;&amp; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> api, <span class="keyword">bool</span> producerControlledByApp, </span></span></span><br><span class="line"><span class="function"><span class="params">            QueueBufferOutput* output)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">disconnect</span><span class="params">(<span class="keyword">int</span> api, </span></span></span><br><span class="line"><span class="function"><span class="params">        DisconnectMode mode = DisconnectMode::Api)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取消费者名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> String8 <span class="title">getConsumerName</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IProducerListener</code> 是 <code>IGraphicBufferProducer</code> 对应的回调接口。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IProducerListener.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerListener</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProducerListener() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~ProducerListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onBufferReleased</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// Asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">needsReleaseNotify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProducerListener</span> :</span> <span class="keyword">public</span> ProducerListener, <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ProducerListener)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnProducerListener</span> :</span> <span class="keyword">public</span> BnInterface&lt;IProducerListener&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">            Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">needsReleaseNotify</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyProducerListener</span> :</span> <span class="keyword">public</span> BnProducerListener</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~DummyProducerListener();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onBufferReleased</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">needsReleaseNotify</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IGraphicBufferConsumer-IConsumerListener-消费者"><a href="#IGraphicBufferConsumer-IConsumerListener-消费者" class="headerlink" title="IGraphicBufferConsumer/IConsumerListener 消费者"></a><code>IGraphicBufferConsumer/IConsumerListener</code> 消费者</h3><p><code>IGraphicBufferConsumer</code> 是消费者接口，实现了 <code>IInterface</code> 可以用于跨进程通信。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGraphicBufferConsumer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IGraphicBufferConsumer</span> :</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(GraphicBufferConsumer)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从 BufferQueue 中获取一块准备好了的缓存 GraphicBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> presentWhen, <span class="keyword">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 释放 slot 位置的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据指定的 GraphicBuffer 获取 slot</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 移除指定 slot 位置的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">releaseBuffer</span><span class="params">(<span class="keyword">int</span> buf, <span class="keyword">uint64_t</span> frameNumber, </span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR fence, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 连接一个消费者进入 BufferQueue</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">consumerConnect</span><span class="params">(<span class="keyword">const</span> sp&lt;IConsumerListener&gt;&amp; consumer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> controlledByApp)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 BufferQueue 断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">consumerDisconnect</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IConsumerListener</code> 是 <code>IGraphicBufferConsumer</code> 对应的回调接口：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IConsumerListener.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerListener</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConsumerListener() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~ConsumerListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span></span><br><span class="line"><span class="function">        </span>= <span class="number">0</span>; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/* item */</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onBuffersReleased</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onSidebandStreamChanged</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">addAndGetFrameTimestamps</span><span class="params">(<span class="keyword">const</span> NewFrameEventsEntry* </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">/*newTimestamps*/</span>, FrameEventHistoryDelta* <span class="comment">/*outDelta*/</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IConsumerListener</span> :</span> <span class="keyword">public</span> ConsumerListener, <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ConsumerListener)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BufferItem"><a href="#BufferItem" class="headerlink" title="BufferItem"></a><code>BufferItem</code></h3><p><code>BufferItem</code> 描述了一块缓存 <code>GraphicBuffer</code> ，以及位置 <code>mSlot</code> ，同步 <code>mFence</code> 等等信息。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferItem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferItem</span> :</span> <span class="keyword">public</span> Flattenable&lt;BufferItem&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">    sp&lt;Fence&gt; mFence;</span><br><span class="line">    Rect mCrop;</span><br><span class="line">    ...</span><br><span class="line">    android_dataspace mDataSpace;</span><br><span class="line">    <span class="keyword">uint64_t</span> mFrameNumber;</span><br><span class="line">    <span class="keyword">int</span> mSlot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferSlot"><a href="#BufferSlot" class="headerlink" title="BufferSlot"></a><code>BufferSlot</code></h3><p><code>BufferSlot</code> 记录了当前 <code>slot</code> 位置的缓存 <code>GraphicBuffer</code> ，以及对应状态， <code>EGL</code> 相关信息。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferSlot.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    BufferSlot()</span><br><span class="line">    : mGraphicBuffer(<span class="literal">nullptr</span>),</span><br><span class="line">      mEglDisplay(EGL_NO_DISPLAY),</span><br><span class="line">      mBufferState(),</span><br><span class="line">      mRequestBufferCalled(<span class="literal">false</span>),</span><br><span class="line">      mFrameNumber(<span class="number">0</span>),</span><br><span class="line">      mEglFence(EGL_NO_SYNC_KHR),</span><br><span class="line">      mFence(Fence::NO_FENCE),</span><br><span class="line">      mAcquireCalled(<span class="literal">false</span>),</span><br><span class="line">      mNeedsReallocation(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">    EGLDisplay mEglDisplay;</span><br><span class="line">    BufferState mBufferState;</span><br><span class="line">    <span class="keyword">bool</span> mRequestBufferCalled;</span><br><span class="line">    <span class="keyword">uint64_t</span> mFrameNumber;</span><br><span class="line">    EGLSyncKHR mEglFence;</span><br><span class="line">    sp&lt;Fence&gt; mFence;</span><br><span class="line">    <span class="keyword">bool</span> mAcquireCalled;</span><br><span class="line">    <span class="keyword">bool</span> mNeedsReallocation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>BufferQueueDefs</code> 中定义了一个 <code>BufferSlot</code> 的数组结构类型 <code>SlotsType</code> 。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueDefs.h</span></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BufferQueueCore</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> BufferQueueDefs &#123;</span><br><span class="line">        <span class="keyword">typedef</span> BufferSlot SlotsType[NUM_BUFFER_SLOTS];</span><br><span class="line">    &#125; <span class="comment">// namespace BufferQueueDefs</span></span><br><span class="line">&#125; <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>

<h3 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a><code>BufferQueueCore</code></h3><p><code>BufferQueueCore</code> 是生产者消费模型的核心，如下是几个重要的成员变量：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueCore.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueCore</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> Vector&lt;BufferItem&gt; Fifo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    String8 mConsumerName;</span><br><span class="line">    sp&lt;IConsumerListener&gt; mConsumerListener;</span><br><span class="line">    sp&lt;IProducerListener&gt; mConnectedProducerListener;</span><br><span class="line"></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line">    Fifo mQueue;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mQueue</code><br>是一个新建先出队列，存储了一队 <code>BufferItem</code> 数据，即一组缓存区。  </li>
<li><code>mSlots</code><br>一个数组，保存了 <code>BufferSlot</code> 数据，每个 <code>slot</code> 位置对应一个缓存。  </li>
<li><code>mConsumerListener</code><br>当前生产消费模型中的，消费者回调接口。  </li>
<li><code>mConnectedProducerListener</code><br>当前生产消费模型中的，生产者回调接口。  </li>
</ul>
<h3 id="BufferQueueProducer-BufferQueueConsumer-生产者-消费者实现类"><a href="#BufferQueueProducer-BufferQueueConsumer-生产者-消费者实现类" class="headerlink" title="BufferQueueProducer/BufferQueueConsumer 生产者/消费者实现类"></a><code>BufferQueueProducer/BufferQueueConsumer</code> 生产者/消费者实现类</h3><p><code>BufferQueueProducer</code> 是 <code>IGraphicBufferConsumer</code> 的实现类，实现了生产者对应的功能。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueProducer</span> :</span> <span class="keyword">public</span> BnGraphicBufferProducer,</span><br><span class="line">                            <span class="keyword">private</span> IBinder::DeathRecipient &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;BufferQueueCore&gt; mCore;</span><br><span class="line">    <span class="comment">// This references mCore-&gt;mSlots.</span></span><br><span class="line">    BufferQueueDefs::SlotsType&amp; mSlots;</span><br><span class="line">    String8 mConsumerName;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Fence&gt; mLastQueueBufferFence;</span><br><span class="line">    Rect mLastQueuedCrop;</span><br><span class="line">    <span class="keyword">uint32_t</span> mLastQueuedTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferQueueProducer</code> 中持有 <code>BufferQueueCore</code> 对象； <code>mSlots</code> 指向 <code>mCore-&gt;mSlots</code> ；同时保持了生产消费模型中，对应消费者的名称。  </p>
<p><code>BufferQueueConsumer</code> 是 <code>IGraphicBufferConsumer</code> 的实现类，实现了消费者对应的功能。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueConsumer</span> :</span> <span class="keyword">public</span> BnGraphicBufferConsumer &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;BufferQueueCore&gt; mCore;</span><br><span class="line">    <span class="comment">// This references mCore-&gt;mSlots.</span></span><br><span class="line">    BufferQueueDefs::SlotsType&amp; mSlots;</span><br><span class="line">    String8 mConsumerName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferQueueConsumer</code> 中持有 <code>BufferQueueCore</code> 对象； <code>mSlots</code> 指向 <code>mCore-&gt;mSlots</code> 。  </p>
<h3 id="BufferQueue-模型"><a href="#BufferQueue-模型" class="headerlink" title="BufferQueue 模型"></a><code>BufferQueue</code> 模型</h3><p><code>BufferQueue</code> 类是 <code>Android</code> 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产者）连接到接受数据以进行显示或进一步处理的一方（消费者）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 <code>BufferQueue</code> 。<br>基本用法很简单：生产者请求一个可用的缓冲区 <code>dequeueBuffer</code> ，并指定一组特性，包括宽度、高度、像素格式和用法标记；生产者填充缓冲区并将其返回到队列 <code>queueBuffer</code> 。随后消费者获取该缓冲区 <code>acquireBuffer</code> ，并使用该缓冲区的内容。当消费者操作完毕后，将该缓冲区返回到队列 <code>releaseBuffer</code> 。<br>最新的 Android 设备支持“同步框架”，这使得系统能够在与可以异步处理图形数据的硬件组件结合使用时提高工作效率。例如，生产者可以提交一系列 <code>OpenGL ES</code> 绘制命令，然后在渲染完成之前将输出缓冲区加入队列。该缓冲区伴有一个栅栏，当内容准备就绪时，栅栏会发出信号。当该缓冲区返回到空闲列表时，会伴有第二个栅栏，因此消费者可以在内容仍在使用期间释放该缓冲区。该方法缩短了缓冲区通过系统时的延迟时间，并提高了吞吐量。<br>队列的一些特性（例如可以容纳的最大缓冲区数）由生产者和消费者联合决定。但是 <code>BufferQueue</code> 负责根据需要分配缓冲区。除非特性发生变化，否则将会保留缓冲区；例如，如果生产者请求具有不同大小的缓冲区，则系统会释放旧的缓冲区，并根据需要分配新的缓冲区。<br>生产者和消费者可以存在于不同的进程中； <code>BufferQueue</code> 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作），缓冲区始终通过句柄进行传递。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueue.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> ::android::ConsumerListener ConsumerListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyConsumerListener 是 ConsumerListener 弱引用实现</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ProxyConsumerListener</span> :</span> <span class="keyword">public</span> BnConsumerListener &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ProxyConsumerListener</span><span class="params">(<span class="keyword">const</span> wp&lt;ConsumerListener&gt;&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">            consumerListener)</span></span>;</span><br><span class="line">        ~ProxyConsumerListener() override;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">()</span> override</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> override</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> override</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onBuffersReleased</span><span class="params">()</span> override</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSidebandStreamChanged</span><span class="params">()</span> override</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addAndGetFrameTimestamps</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> NewFrameEventsEntry* newTimestamps,</span></span></span><br><span class="line"><span class="function"><span class="params">                FrameEventHistoryDelta* outDelta)</span> override</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 弱引用</span></span><br><span class="line">        wp&lt;ConsumerListener&gt; mConsumerListener;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BufferQueue manages a pool of gralloc memory slots to be used by</span></span><br><span class="line">    <span class="comment">// producers and consumers. allocator is used to allocate all the</span></span><br><span class="line">    <span class="comment">// needed gralloc buffers.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBufferQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">            sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">bool</span> consumerIsSurfaceFlinger = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    BufferQueue() = <span class="keyword">delete</span>; <span class="comment">// Create through createBufferQueue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>BufferQueue</code> 的头文件定义很简单：  </p>
<ul>
<li>定义了一个 <code>ConsumerListener</code> 的弱引用  </li>
<li>整个类只有一个函数 <code>createBufferQueue</code> ，它将参数中的 <code>IGraphicBufferProducer, IGraphicBufferConsumer</code> 消费者关联起来  </li>
<li>没有构造函数，只能通过 <code>createBufferQueue</code> 来创建对象  </li>
<li><code>BufferQueue</code> 中并不包含队列数据结构来存储缓存，仅仅连接了生产者、消费者两者的关系  </li>
</ul>
<p>来看 <code>createBufferQueue</code> 的具体实现：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueue.cp</span></span><br><span class="line"><span class="keyword">void</span> BufferQueue::createBufferQueue(</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* outProducer,</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span><br><span class="line">        <span class="keyword">bool</span> consumerIsSurfaceFlinger) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;BufferQueueCore&gt; core(<span class="keyword">new</span> BufferQueueCore());</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer(</span><br><span class="line">        <span class="keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger));</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br><span class="line">    ...</span><br><span class="line">    *outProducer = producer;</span><br><span class="line">    *outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码删掉了 <code>LOG</code> 打印及空判断，整个代码流程非常简单：  </p>
<ul>
<li>新建 <code>BufferQueueCore core</code>  </li>
<li>由 <code>core</code> 新建生产者 <code>IGraphicBufferProducer</code>  </li>
<li>由 <code>core</code> 新建消费者 <code>IGraphicBufferConsumer</code>  </li>
</ul>
<p>也就是说 <code>BufferQueueCore</code> 是最终的纽带，保存了生产者消费者对应的缓存区，连接了两者的关系。  </p>
<h3 id="Surface-1"><a href="#Surface-1" class="headerlink" title="Surface"></a><code>Surface</code></h3><p><code>Surface</code> 代表着窗口，它包含一个生产者 <code>IGraphicBufferProducer</code> 用来填充缓存，也就是窗口中用来显示在屏幕上的内容，<code>mSlot</code> 数组表示可以有多个缓存区。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; getIGraphicBufferProducer() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function">String8 <span class="title">getConsumerName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">    &#125;;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer;</span><br><span class="line">    BufferSlot mSlots[NUM_BUFFER_SLOTS];</span><br><span class="line">    <span class="keyword">uint32_t</span> mReqWidth;</span><br><span class="line">    <span class="keyword">uint32_t</span> mReqHeight;</span><br><span class="line">    PixelFormat mReqFormat;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// must be used from the lock/unlock thread</span></span><br><span class="line">    sp&lt;GraphicBuffer&gt;           mLockedBuffer;</span><br><span class="line">    sp&lt;GraphicBuffer&gt;           mPostedBuffer;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ISurfaceComposer-ISurfaceComposerClient"><a href="#ISurfaceComposer-ISurfaceComposerClient" class="headerlink" title="ISurfaceComposer/ISurfaceComposerClient"></a><code>ISurfaceComposer/ISurfaceComposerClient</code></h3><p><code>ISurfaceComposerClient/ISurfaceComposer</code> 都继承了 <code>IInterface</code> ，它们俩分别代表 <code>Surface</code> 合成的客户端和服务端，具体在 <code>SurfaceFlinger</code> 服务进程中实现， <code>libgui</code> 中只对合成能力（函数）做了定义。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISurfaceComposerClient.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposerClient</span> :</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposerClient)</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parent, <span class="keyword">uint32_t</span> windowType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> ownerUid, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">destroySurface</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">clearLayerFrameStats</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getLayerFrameStats</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle, </span></span></span><br><span class="line"><span class="function"><span class="params">        FrameStats* outStats)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ISurfaceComposer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposer</span>:</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposer)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;ISurfaceComposerClient&gt; createConnection() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;ISurfaceComposerClient&gt; createScopedConnection(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; parent) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IDisplayEventConnection&gt; createDisplayEventConnection(</span><br><span class="line">            VsyncSource vsyncSource = eVsyncSourceApp) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; createDisplay(<span class="keyword">const</span> String8&amp; displayName,</span><br><span class="line">            <span class="keyword">bool</span> secure) = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">destroyDisplay</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">captureScreen</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; producer,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect sourceCrop, <span class="keyword">uint32_t</span> reqWidth, <span class="keyword">uint32_t</span> reqHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int32_t</span> minLayerZ, <span class="keyword">int32_t</span> maxLayerZ,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">bool</span> useIdentityTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rotation rotation = eRotateNone)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是 <code>ISurfaceComposerClient</code> 相关的类图结构：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-ISurfaceComposerClient.png" alt="01113-android-graphics-display-ISurfaceComposerClient.png"></p>
<p>先看 <code>ComposerService</code> ，它代表着 <code>SurfaceFlinger</code> 服务端，头文件定义如下：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComposerService.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerService</span> :</span> <span class="keyword">public</span> Singleton&lt;ComposerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; mComposerService;</span><br><span class="line">    sp&lt;IBinder::DeathRecipient&gt; mDeathObserver;</span><br><span class="line">    Mutex mLock;</span><br><span class="line"></span><br><span class="line">    ComposerService();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">composerServiceDied</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;ComposerService&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a connection to the Composer Service.  This will block until</span></span><br><span class="line">    <span class="comment">// a connection is established.</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;ISurfaceComposer&gt; getComposerService();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看 <code>connectLocked, getComposerService</code> 两个函数的实现：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"><span class="keyword">void</span> ComposerService::connectLocked() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">"SurfaceFlinger"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(<span class="number">250000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*static*/</span> sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">"ComposerService reconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>connectLocked</code> 连接过程就是等待 <code>SurfaceFlinger</code> 服务启动后并获取它； <code>getComposerService</code> 直接返回已经连接成功的实例 <code>mComposerService</code> 。  </p>
<p>再看 <code>SurfaceComposerClient</code> ，可以将它理解为应用端，是 <code>SurfaceFlinger</code> 服务的客户端，它将建立和 <code>SurfaceFlinger</code> 服务的通信，头文件定义如下：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceComposerClient</span> :</span> <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Return the connection of this client</span></span><br><span class="line">    sp&lt;IBinder&gt; connection() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//! Create a surface</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; createSurface(</span><br><span class="line">            <span class="keyword">const</span> String8&amp; name,<span class="comment">// name of the surface</span></span><br><span class="line">            <span class="keyword">uint32_t</span> w,         <span class="comment">// width in pixel</span></span><br><span class="line">            <span class="keyword">uint32_t</span> h,         <span class="comment">// height in pixel</span></span><br><span class="line">            PixelFormat format, <span class="comment">// pixel-format desired</span></span><br><span class="line">            <span class="keyword">uint32_t</span> flags = <span class="number">0</span>, <span class="comment">// usage flags</span></span><br><span class="line">            SurfaceControl* parent = <span class="literal">nullptr</span>, <span class="comment">// parent</span></span><br><span class="line">            <span class="keyword">uint32_t</span> windowType = <span class="number">0</span>, </span><br><span class="line">            <span class="keyword">uint32_t</span> ownerUid = <span class="number">0</span> <span class="comment">// UID of the task</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">status_t</span>    destroySurface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Create a virtual display</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;IBinder&gt; createDisplay(<span class="keyword">const</span> String8&amp; displayName,</span><br><span class="line">        <span class="keyword">bool</span> secure);</span><br><span class="line">    <span class="comment">//! Destroy a virtual display</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyDisplay</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Composer&amp; <span class="title">getComposer</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt;  mClient;</span><br><span class="line">    Composer&amp;                   mComposer;</span><br><span class="line">    wp&lt;IGraphicBufferProducer&gt;  mParent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>mClient</code> 实际对应的是 <code>SurfaceFlinger</code> 进程中的 <code>Client.cpp</code> ，查看 <code>SurfaceComposerClient::onFirstRef</code> 源码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> rootProducer = mParent.promote();</span><br><span class="line">        sp&lt;ISurfaceComposerClient&gt; conn;</span><br><span class="line">        conn = (rootProducer != <span class="literal">nullptr</span>) ? </span><br><span class="line">                sm-&gt;createScopedConnection(rootProducer) :</span><br><span class="line">                sm-&gt;createConnection();</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">            mClient = conn;</span><br><span class="line">            mStatus = NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createScopedConnection(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (authenticateSurfaceTexture(gbp) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; layer = (<span class="keyword">static_cast</span>&lt;MonitoredProducer*&gt;(</span><br><span class="line">        gbp.get()))-&gt;getLayer();</span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> initClient(<span class="keyword">new</span> Client(<span class="keyword">this</span>, layer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SurfaceComposerClient</code> 中有一个重要功能就是创建 <code>Surface</code> ，对应源码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w,</span><br><span class="line">        <span class="keyword">uint32_t</span> h,</span><br><span class="line">        PixelFormat format,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        SurfaceControl* parent,</span><br><span class="line">        <span class="keyword">uint32_t</span> windowType,</span><br><span class="line">        <span class="keyword">uint32_t</span> ownerUid)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, </span><br><span class="line">                flags, parentHandle,</span><br><span class="line">                windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error.."</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用 <code>SurfaceFlinger</code> 中的 <code>mClient</code> 来创建 <code>Layer, IGraphicBufferProducer</code> ；而具体的 <code>Surface</code> 则由 <code>SurfaceControl</code> 来创建。  </p>
<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a><code>SurfaceControl</code></h3><p><code>SurfaceControl</code> 持有创建的 <code>Surface</code> 的强引用，头文件定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceControl.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceControl</span> :</span> <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt;   mClient;</span><br><span class="line">    sp&lt;IBinder&gt;                 mHandle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt;  mGraphicBufferProducer;</span><br><span class="line">    <span class="keyword">mutable</span> sp&lt;Surface&gt;         mSurfaceData;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mHandle</code> 指向 <code>SurfaceFlinger</code> 创建的 <code>Layer</code> 。而 <code>SurfaceControl::createSurface</code> 直接 <code>new</code> 了一个 <code>Surface</code> 对象。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceControl.cpp</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::createSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> generateSurfaceLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IDisplayEventConnection-显示连接"><a href="#IDisplayEventConnection-显示连接" class="headerlink" title="IDisplayEventConnection 显示连接"></a><code>IDisplayEventConnection</code> 显示连接</h3><p><code>IDisplayEventConnection</code> 继承了 <code>IInterface</code> ，客户端 <code>APP</code> 通过它向服务端 <code>SurfaceFlinger</code> 发送刷新请求。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDisplayEventConnection</span> :</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(DisplayEventConnection)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * stealReceiveChannel() returns a BitTube to receive events from. </span></span><br><span class="line"><span class="comment">     *Only the receive file descriptor of outChannel will be initialized,</span></span><br><span class="line"><span class="comment">     * and this effectively "steals" the receive channel from the remote</span></span><br><span class="line"><span class="comment">     * end (such that the remote end can only use its send channel).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * setVsyncRate() sets the vsync event delivery rate. </span></span><br><span class="line"><span class="comment">     * A value of 1 returns every vsync event.</span></span><br><span class="line"><span class="comment">     * A value of 2 returns every other event, etc. </span></span><br><span class="line"><span class="comment">     * A value of 0 returns no event unless</span></span><br><span class="line"><span class="comment">     * requestNextVsync() has been called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setVsyncRate</span><span class="params">(<span class="keyword">uint32_t</span> count)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * requestNextVsync() schedules the next vsync event. </span></span><br><span class="line"><span class="comment">     * It has no effect if the vsync rate is &gt; 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">requestNextVsync</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// Asynchronous</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IDisplayEventConnection</code> 的类图结构  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-IDisplayEventConnection.png" alt="0113-android-graphics-display-create-IDisplayEventConnection.png"></p>
<p><code>IDisplayEventConnection</code> 的具体实现是在 <code>SurfaceFlinger</code> 进程中的 <code>EventThread::Connection</code> ；<code>DisplayEventReceiver</code> 持有该实例。  </p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>libgui</code> 中一共提供了 4 组 <code>IInterface</code> 接口： <code>IGraphicBufferProducer/IProducerListener, IGraphicBufferConsumer/IConsumerListener, ISurfaceComposerClient/ISurfaceComposer, IDisplayEventConnection</code>  </li>
<li><code>IGraphicBufferProducer/IProducerListener</code> 生产者模型  </li>
<li><code>IGraphicBufferConsumer/IConsumerListener</code> 消费者模型  </li>
<li><code>ISurfaceComposerClient/ISurfaceComposer</code> 提供创建 <code>Surface</code> 的功能，及相关管理  </li>
<li><code>IDisplayEventConnection</code> 提供了 <code>APP</code> 客户端请求服务端 <code>SurfaceFlinger</code> 刷新的接口  </li>
</ul>
<h2 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a><code>SurfaceFlinger</code></h2><h3 id="代码速查表-1"><a href="#代码速查表-1" class="headerlink" title="代码速查表"></a>代码速查表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">surfaceflinger/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── Android.mk</span><br><span class="line">├── Barrier.h</span><br><span class="line">├── Client.cpp</span><br><span class="line">├── Client.h</span><br><span class="line">├── clz.h</span><br><span class="line">├── Colorizer.h</span><br><span class="line">├── DdmConnection.cpp</span><br><span class="line">├── DdmConnection.h</span><br><span class="line">├── DisplayDevice.cpp</span><br><span class="line">├── DisplayDevice.h</span><br><span class="line">├── DisplayHardware</span><br><span class="line">│   ├── ComposerHal.cpp</span><br><span class="line">│   ├── ComposerHal.h</span><br><span class="line">│   ├── DisplaySurface.h</span><br><span class="line">│   ├── FramebufferSurface.cpp</span><br><span class="line">│   ├── FramebufferSurface.h</span><br><span class="line">│   ├── HWC2.cpp</span><br><span class="line">│   ├── HWC2.h</span><br><span class="line">│   ├── HWComposerBufferCache.cpp</span><br><span class="line">│   ├── HWComposerBufferCache.h</span><br><span class="line">│   ├── HWComposer.cpp</span><br><span class="line">│   ├── HWComposer.h</span><br><span class="line">│   ├── HWComposer_hwc1.cpp</span><br><span class="line">│   ├── HWComposer_hwc1.h</span><br><span class="line">│   ├── PowerHAL.cpp</span><br><span class="line">│   ├── PowerHAL.h</span><br><span class="line">│   ├── VirtualDisplaySurface.cpp</span><br><span class="line">│   └── VirtualDisplaySurface.h</span><br><span class="line">├── DisplayUtils.cpp</span><br><span class="line">├── DisplayUtils.h</span><br><span class="line">├── DispSync.cpp</span><br><span class="line">├── DispSync.h</span><br><span class="line">├── Effects</span><br><span class="line">│   ├── Daltonizer.cpp</span><br><span class="line">│   └── Daltonizer.h</span><br><span class="line">├── EventControlThread.cpp</span><br><span class="line">├── EventControlThread.h</span><br><span class="line">├── EventLog</span><br><span class="line">│   ├── EventLog.cpp</span><br><span class="line">│   ├── EventLog.h</span><br><span class="line">│   └── EventLogTags.logtags</span><br><span class="line">├── EventThread.cpp</span><br><span class="line">├── EventThread.h</span><br><span class="line">├── ExSurfaceFlinger</span><br><span class="line">│   ├── ExLayer.cpp</span><br><span class="line">│   ├── ExLayer.h</span><br><span class="line">│   ├── ExSurfaceFlinger.cpp</span><br><span class="line">│   ├── ExSurfaceFlinger.h</span><br><span class="line">│   ├── ExVirtualDisplaySurface.cpp</span><br><span class="line">│   └── ExVirtualDisplaySurface.h</span><br><span class="line">├── FrameTracker.cpp</span><br><span class="line">├── FrameTracker.h</span><br><span class="line">├── GpuService.cpp</span><br><span class="line">├── GpuService.h</span><br><span class="line">├── Layer.cpp</span><br><span class="line">├── LayerDim.cpp</span><br><span class="line">├── LayerDim.h</span><br><span class="line">├── Layer.h</span><br><span class="line">├── LayerRejecter.cpp</span><br><span class="line">├── LayerRejecter.h</span><br><span class="line">├── LayerVector.cpp</span><br><span class="line">├── LayerVector.h</span><br><span class="line">├── main_surfaceflinger.cpp</span><br><span class="line">├── MessageQueue.cpp</span><br><span class="line">├── MessageQueue.h</span><br><span class="line">├── MODULE_LICENSE_APACHE2</span><br><span class="line">├── MonitoredProducer.cpp</span><br><span class="line">├── MonitoredProducer.h</span><br><span class="line">├── RenderEngine</span><br><span class="line">│   ├── Description.cpp</span><br><span class="line">│   ├── Description.h</span><br><span class="line">│   ├── GLES20RenderEngine.cpp</span><br><span class="line">│   ├── GLES20RenderEngine.h</span><br><span class="line">│   ├── GLExtensions.cpp</span><br><span class="line">│   ├── GLExtensions.h</span><br><span class="line">│   ├── Mesh.cpp</span><br><span class="line">│   ├── Mesh.h</span><br><span class="line">│   ├── ProgramCache.cpp</span><br><span class="line">│   ├── ProgramCache.h</span><br><span class="line">│   ├── Program.cpp</span><br><span class="line">│   ├── Program.h</span><br><span class="line">│   ├── RenderEngine.cpp</span><br><span class="line">│   ├── RenderEngine.h</span><br><span class="line">│   ├── Texture.cpp</span><br><span class="line">│   └── Texture.h</span><br><span class="line">├── StartPropertySetThread.cpp</span><br><span class="line">├── StartPropertySetThread.h</span><br><span class="line">├── SurfaceFlingerConsumer.cpp</span><br><span class="line">├── SurfaceFlingerConsumer.h</span><br><span class="line">├── SurfaceFlinger.cpp</span><br><span class="line">├── SurfaceFlinger.h</span><br><span class="line">├── SurfaceFlinger_hwc1.cpp</span><br><span class="line">├── surfaceflinger.rc</span><br><span class="line">├── SurfaceInterceptor.cpp</span><br><span class="line">├── SurfaceInterceptor.h</span><br><span class="line">├── Transform.cpp</span><br><span class="line">└── Transform.h</span><br><span class="line"></span><br><span class="line">9 directories, 117 files</span><br></pre></td></tr></table></figure>

<h3 id="surfaceflinger-进程"><a href="#surfaceflinger-进程" class="headerlink" title="surfaceflinger 进程"></a><code>surfaceflinger</code> 进程</h3><p><code>SurfaceFlinger</code> 是以独立进程运行的，进程名为 <code>surfaceflinger</code> ，对应的 <code>rc</code> 文件如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// surfaceflinger.rc</span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc readproc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/stune/foreground/tasks</span><br><span class="line">    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</span><br></pre></td></tr></table></figure>

<p><code>surfaceflinger</code> 服务属于核心类 <code>core</code>，当 <code>surfaceflinger</code> 重启时会触发 <code>zygote</code> 的重启。接下来看进程 <code>main</code> 方法对应文件为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// main_surfaceflinger.cpp</span><br><span class="line">int main(int, char**) &#123;</span><br><span class="line">    // 启动 IAllocator, DisplayService 两个服务</span><br><span class="line">    startHidlServices();</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    // 1. new SurfaceFlinger 实例</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = </span><br><span class="line">        DisplayUtils::getInstance()-&gt;getSFInstance();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line">    if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM);</span><br><span class="line"></span><br><span class="line">    // 2. SurfaceFlinger 初始化</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    // 3. 发布 SurfaceFlinger, GpuService 两个服务</span><br><span class="line">    // publish surface flinger</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), </span><br><span class="line">        flinger, false);</span><br><span class="line"></span><br><span class="line">    // publish GpuService</span><br><span class="line">    sp&lt;GpuService&gt; gpuservice = new GpuService();</span><br><span class="line">    sm-&gt;addService(String16(GpuService::SERVICE_NAME),gpuservice,false);</span><br><span class="line"></span><br><span class="line">    struct sched_param param = &#123;0&#125;;</span><br><span class="line">    param.sched_priority = 2;</span><br><span class="line">    if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t set SCHED_FIFO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // run surface flinger in this thread</span><br><span class="line">    // 4. SurfaceFlinger 无限循环等待事件</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>surfaceflinger</code> 进程的 <code>main</code> 函数中主要做了 4 件事：  </p>
<ul>
<li>通过 <code>DisplayUtils</code> 创建 <code>SurfaceFlinger</code> 对象  </li>
<li><code>SurfaceFlinger</code> 对象调用 <code>init</code> 方法，实现初始化  </li>
<li><code>SurfaceFlinger</code> 向系统注册 <code>Binder</code> 服务  </li>
<li><code>SurfaceFlinger</code> 对象调用 <code>run</code> 方法，该方法是一个 <code>do-while</code> 无限循环  </li>
</ul>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><a href="https://upload-images.jianshu.io/upload_images/606437-92984e2a12a8b3d0.png" target="_blank" rel="noopener">SurfaceFlinger 初始化流程，查看大图</a>  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-SurfaceFlinger-init.png" alt="0113-android-graphics-display-SurfaceFlinger-init.png"></p>
<h3 id="DisplayDevice-显示设备"><a href="#DisplayDevice-显示设备" class="headerlink" title="DisplayDevice 显示设备"></a><code>DisplayDevice</code> 显示设备</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayDevice.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayDevice</span> :</span> <span class="keyword">public</span> LightRefBase&lt;DisplayDevice&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">enum</span> DisplayType &#123;</span><br><span class="line">        DISPLAY_ID_INVALID = <span class="number">-1</span>,</span><br><span class="line">        DISPLAY_PRIMARY     = HWC_DISPLAY_PRIMARY,      <span class="comment">// 主显</span></span><br><span class="line">        DISPLAY_EXTERNAL    = HWC_DISPLAY_EXTERNAL,     <span class="comment">// 外显</span></span><br><span class="line">        DISPLAY_VIRTUAL     = HWC_DISPLAY_VIRTUAL,      <span class="comment">// 虚显</span></span><br><span class="line">        NUM_BUILTIN_DISPLAY_TYPES = HWC_NUM_PHYSICAL_DISPLAY_TYPES,</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示设备有三种类型：主显、外显、虚显；每添加一个显示屏，都会创建一个 <code>DisplayDevice</code> 。  </p>
<h3 id="Layer-层"><a href="#Layer-层" class="headerlink" title="Layer 层"></a><code>Layer</code> 层</h3><p><code>Layer</code> 是 <code>SurfaceFlinger</code> 进行合成的基本操作单元。<code>Layer</code> 在应用请求创建 <code>Surface</code> 的时候在 <code>SurfaceFlinger</code> 内部创建，因此一个 <code>Surface</code> 对应一个 <code>Layer</code> 。每个 <code>Layer</code> 包含常见属性：  </p>
<ul>
<li><code>Z order</code>  </li>
<li><code>Alpha value from 0 to 255</code>  </li>
<li><code>visibleRegion</code>  </li>
<li><code>crop region</code>  </li>
<li><code>transformation: rotate 0, 90, 180, 270: flip H, V: scale</code>  </li>
</ul>
<p>当多个 <code>Layer</code> 进行合成的时候，并不是整个 <code>Layer</code> 的空间都会被完全显示，根据这个 <code>Layer</code> 最终的显示效果，一个 <code>Layer</code> 可以被划分成很多的 <code>Region</code> ， 在 <code>SurfaceFlinger</code> 中定义了以下几种类型：  </p>
<ul>
<li><code>TransparantRegion</code> ：完全透明的区域，在它之下的区域将被显示出来  </li>
<li><code>OpaqueRegion</code> ：完全不透明的区域，是否显示取决于它上面是否有遮挡或是否透明  </li>
<li><code>VisibleRegion</code> ：可见区域，包括完全不透明无遮挡区域或半透明区域；即 <code>visibleRegion = Region - above OpaqueRegion.</code>  </li>
<li><code>CoveredRegion</code> ：被遮挡区域，在它之上，有不透明或半透明区域  </li>
<li><code>DirtyRegion</code> ：可见部分改变区域，包括新的被遮挡区域，和新的露出区域  </li>
</ul>
<p>头文件定义：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> :</span> <span class="keyword">public</span> SurfaceFlingerConsumer::ContentsChangedListener &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// regions below are in window-manager space</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line">    Region coveredRegion;</span><br><span class="line">    Region visibleNonTransparentRegion;</span><br><span class="line">    Region surfaceDamageRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer serial number.  This gives layers an explicit ordering, so we</span></span><br><span class="line">    <span class="comment">// have a stable sort order when their layer stack and Z-order are</span></span><br><span class="line">    <span class="comment">// the same.</span></span><br><span class="line">    <span class="keyword">int32_t</span> sequence;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// constants</span></span><br><span class="line">    sp&lt;SurfaceFlingerConsumer&gt; mSurfaceFlingerConsumer;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; mProducer;</span><br><span class="line">    <span class="keyword">uint32_t</span> mTextureName;      <span class="comment">// from GLES</span></span><br><span class="line">    <span class="keyword">bool</span> mPremultipliedAlpha;</span><br><span class="line">    String8 mName;</span><br><span class="line">    String8 mTransactionName; <span class="comment">// A cached version of "TX - " + mName for systraces</span></span><br><span class="line">    PixelFormat mFormat;</span><br><span class="line">    ...</span><br><span class="line">    FenceTimeline mAcquireTimeline;</span><br><span class="line">    FenceTimeline mReleaseTimeline;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// The mesh used to draw the layer in GLES composition mode</span></span><br><span class="line">    <span class="keyword">mutable</span> Mesh mMesh;</span><br><span class="line">    <span class="comment">// The texture used to draw the layer in GLES composition mode</span></span><br><span class="line">    <span class="keyword">mutable</span> Texture mTexture;</span><br><span class="line">    Vector&lt;BufferItem&gt; mQueueItems;</span><br><span class="line">    <span class="comment">// Child list about to be committed/used for editing.</span></span><br><span class="line">    LayerVector mCurrentChildren;</span><br><span class="line">    <span class="comment">// Child list used for rendering.</span></span><br><span class="line">    LayerVector mDrawingChildren;</span><br><span class="line"></span><br><span class="line">    wp&lt;Layer&gt; mCurrentParent;</span><br><span class="line">    wp&lt;Layer&gt; mDrawingParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SurfaceFlinger</code> 接收所有 <code>Surface</code> 作为输入，根据 <code>Z-Order</code>， 透明度，大小，位置等参数，计算出每个 <code>Surface</code> 在最终合成图像中的位置，然后交由 <code>HWComposer, OpenGL</code> 生成最终的显示 <code>Buffer</code> , 然后显示到特定的显示设备上。<br><code>Layer</code> 的合成分为两种，离线合成和在线合成：</p>
<ul>
<li>离线合成<br>先将所有图层画到一个最终层 <code>FrameBuffer</code> 上，再将 <code>FrameBuffer</code> 送到 <code>LCD</code> 显示。由于合成 <code>FrameBuffer</code> 与送 <code>LCD</code> 显示一般是异步的（线下生成 <code>FrameBuffer</code> ，需要时线上的 <code>LCD</code> 去取），因此叫离线合成。  </li>
<li>在线合成<br>不使用 <code>FrameBuffer</code> ，在 <code>LCD</code> 需要显示某一行的像素时，用显示控制器将所有图层与该行相关的数据取出，合成一行像素送过去。只有一个图层时，又叫 <code>Overlay</code> 技术。<br>由于省去合成 <code>FrameBuffer</code> 时读图层，写 <code>FrameBuffer</code> 的步骤，大幅降低了内存传输量，减少了功耗，但这个需要硬件支持。  </li>
</ul>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-layer-composer.jpg" alt="0113-android-graphics-display-layer-composer.jpg"></p>
<h3 id="Surface-创建流程图"><a href="#Surface-创建流程图" class="headerlink" title="Surface 创建流程图"></a><code>Surface</code> 创建流程图</h3><p>由客户端 <code>SurfaceComposerClient</code> 发起创建流程，然后由服务端 <code>SurfaceFlinger</code> 创建对应的 <code>Layer</code> ，而 <code>Layer</code> 在被引用时会创建生产者消费者模型的 <code>BufferQueue</code> ，然后再由客户端将拿到的结果传入 <code>SurfaceControl</code> ，最后直接实例化一个 <code>Surface</code> 。  </p>
<p>创建生产者消费者模型 <code>BufferQueue</code> 的关键代码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, <span class="literal">true</span>);</span><br><span class="line">    mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger, <span class="keyword">this</span>);</span><br><span class="line">    mSurfaceFlingerConsumer = </span><br><span class="line">        <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName, <span class="keyword">this</span>);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;</span><br><span class="line">        mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://upload-images.jianshu.io/upload_images/606437-645921566ffd77c6.png" target="_blank" rel="noopener">创建 Surface 流程，查看大图</a>  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-surface.png" alt="0113-android-graphics-display-create-surface.png"></p>
<h3 id="VSYNC-垂直刷新-1"><a href="#VSYNC-垂直刷新-1" class="headerlink" title="VSYNC 垂直刷新"></a><code>VSYNC</code> 垂直刷新</h3><p><code>Android</code> 中有 2 种 <code>VSync</code> 信号：屏幕产生的硬件 <code>VSync</code> 和由 <code>SurfaceFlinger</code> 将其转成的软件 <code>Vsync</code> 信号；软件 <code>Vsync</code> 后者经由 <code>Binder</code> 传递给 <code>Choreographer</code> 。<br><code>Vsync</code> 信号可将某些事件同步到显示设备的刷新周期。应用总是在 <code>VSYNC</code> 边界上开始绘制，而 <code>SurfaceFlinger</code> 总是在 <code>VSYNC</code> 边界上进行合成。这样可以消除卡顿，并提升图形的视觉表现。 <code>HWComposer</code> 对象创建过程，会注册一些回调方法；当硬件产生 <code>VSYNC</code> 信号时，则会回调 <code>HWC2::ComposerCallbackBridge::onVsync</code> 方法，然后逐级回调，下图是整个回调流程图：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-VsyncCallback.png" alt="0113-android-graphics-VsyncCallback.png"></p>
<ul>
<li>硬件 <code>Vsync</code> 信号发送过来，一路执行到 <code>DispSyncThread.updateModel</code> 方法中调用 <code>mCond.signal</code> ，唤醒 <code>DispSyncThread</code> 线程  </li>
<li><code>DispSyncThread</code> 线程中执行 <code>EventThread::onVSyncEvent</code> 中调用 <code>mCondition.broadcast</code> 唤醒 <code>EventThread</code> 线程  </li>
<li><code>EventThread</code> 线程中执行 <code>DisplayEventReceiver::sendEvents</code> 方法，会调用 <code>BitTube::sendObjects</code> ；在 <code>MessageQueue::setEventThread</code> 中，我们设置了 <code>BitTube</code> 事件的回调，当收到数据会触发 <code>MQ.cb_eventReceiver</code> ；根据 <code>Handler</code> 消息机制，进入 <code>SurfaceFlinger</code> 主线程  </li>
<li><code>SurfaceFlinger</code> 主线程进入到 <code>MesageQueue的handleMessage</code> ，最终调用 <code>SurfaceFlinger::handleMessageRefresh</code>  </li>
</ul>
<h3 id="客户端通知-SurfaceFlinger-刷新"><a href="#客户端通知-SurfaceFlinger-刷新" class="headerlink" title="客户端通知 SurfaceFlinger 刷新"></a>客户端通知 <code>SurfaceFlinger</code> 刷新</h3><p><code>BufferQueueProducer::queueBuffer</code> 函数中会调用 <code>listener-&gt;onFrameAvailable</code> ，而这最终会触发服务端的 <code>Layer::onFrameAvailable</code> ，从而通知 <code>SurfaceFlinger</code> 合成图像。我们先看 <code>onFrameAvailable</code> 接口的继承关系：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-onFrameAvailable-class-uml.png" alt="0113-android-graphics-display-onFrameAvailable-class-uml.png"></p>
<p>从 <code>Surface</code> 创建流程中贴出的 <code>Layer::onFirstRef</code> 代码中可以看到，在 <code>Layer</code> 中设置了 <code>mSurfaceFlingerConsumer-&gt;setContentsChangedListener</code> 监听事件，所以 <code>BufferQueueProducer::queueBuffer</code> 会触发 <code>Layer::onFrameAvailable</code> 事件，下面是完整的请求流程。<br>客户端在 <code>BufferQueue</code> 中生产完图像数据后，通知 <code>SurfaceFlinger</code> 刷新界面的流程图：  </p>
<p><a href="https://upload-images.jianshu.io/upload_images/606437-4f8a5a419984488c.png" target="_blank" rel="noopener">客户端通知 SurfaceFlinger 刷新，查看大图</a>  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-requestNextVsync.png" alt="0113-android-graphics-display-requestNextVsync.png"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul>
<li><code>WMS</code>  </li>
<li><code>Layer</code> 合成流程  </li>
<li>结合 <code>Camera</code> 熟悉图形显示中 <code>Buffer</code> 相关流程  </li>
<li><code>Choreographer</code> 及掉帧分析  <ul>
<li><a href="https://www.jianshu.com/p/dd32ec35db1d" target="_blank" rel="noopener">Choreographer 简析</a></li>
</ul>
</li>
<li>详述 <code>SurfaceTexture, SurfaceView, GLSurfaceView</code> 等区别  </li>
<li>工具 <code>dumpsys SurfaceFlinger</code> 输出的 <code>LOG</code> 分析  </li>
<li><code>screencap</code> 命令及源码分析  </li>
<li><code>Systrace</code> 性能工具分析  <ul>
<li><a href="https://source.android.google.cn/devices/tech/debug/systrace" target="_blank" rel="noopener">Systrace 官网</a>   </li>
</ul>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://source.android.google.cn/devices/graphics" target="_blank" rel="noopener">Android 图形显示-官网</a>  </li>
<li><a href="https://blog.csdn.net/ear5cm/article/details/45458683" target="_blank" rel="noopener">Android中native_handle private_handle_t 的关系</a>  </li>
<li><strong><a href="https://www.jianshu.com/u/f92447ae8445" target="_blank" rel="noopener">夕阳风-图形显示系列文章</a></strong>  </li>
<li><strong><a href="http://windrunnerlihuan.com/2017/04/27/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C-SurfaceFlinger%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">SurfaceFlinger 系列</a></strong>  </li>
<li><a href="https://blog.csdn.net/zhaizu/article/details/51882768" target="_blank" rel="noopener">理解 VSYNC</a>  </li>
<li><a href="http://www.cnblogs.com/yaozhongxiao/archive/2014/07/14/3842908.html" target="_blank" rel="noopener">dp, dpi, px, density 的关系</a>  </li>
<li><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">gityuan: SurfaceFlinger 相关</a>  </li>
<li><a href="https://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">阿拉神农：深入理解Surface系统</a>  </li>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/79483406" target="_blank" rel="noopener">图解 Surface, SurfaceFlinger 关系</a>  </li>
<li><a href="https://github.com/google/grafika" target="_blank" rel="noopener">Google Grafika</a>  </li>
<li><a href="https://blog.csdn.net/u013928208/article/details/82999075" target="_blank" rel="noopener">图形引擎的核心 - BufferQueue</a>  </li>
<li><a href="https://blog.csdn.net/xisuzun7960/article/details/81212721" target="_blank" rel="noopener">surfaceflinger框架-流程图大全</a>   </li>
<li><a href="https://blog.csdn.net/armwind/article/details/73436532" target="_blank" rel="noopener">BufferQueue介绍</a>  </li>
<li><a href="https://blog.csdn.net/jinzhuojun/article/details/39698317/" target="_blank" rel="noopener">GraphicBuffer同步机制-Fence</a>  </li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    redspider110
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://redspider110.github.io/2019/04/17/0113-android-graphics-display/" title="Android 图形显示简述">http://redspider110.github.io/2019/04/17/0113-android-graphics-display/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/10/0112-android-jni/" rel="next" title="Android JNI">
                <i class="fa fa-chevron-left"></i> Android JNI
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/17/0114-dl-machine-learning/" rel="prev" title="机器学习、深度学习、神经网络">
                机器学习、深度学习、神经网络 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="redspider110">
            
              <p class="site-author-name" itemprop="name">redspider110</p>
              <p class="site-description motion-element" itemprop="description">地球卫士</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EGL"><span class="nav-number">1.1.</span> <span class="nav-text">EGL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface-和-SurfaceFlinger"><span class="nav-number">1.2.</span> <span class="nav-text">Surface 和 SurfaceFlinger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WMS-WindowManagerServices"><span class="nav-number">1.3.</span> <span class="nav-text">WMS: WindowManagerServices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FrameBuffer"><span class="nav-number">1.4.</span> <span class="nav-text">FrameBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gralloc"><span class="nav-number">1.5.</span> <span class="nav-text">Gralloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HWC"><span class="nav-number">1.6.</span> <span class="nav-text">HWC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VSYNC-垂直刷新"><span class="nav-number">1.7.</span> <span class="nav-text">VSYNC 垂直刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60Hz-和-16-ms"><span class="nav-number">1.8.</span> <span class="nav-text">60Hz 和 16 ms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferQueue"><span class="nav-number">1.9.</span> <span class="nav-text">BufferQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据流"><span class="nav-number">1.10.</span> <span class="nav-text">数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件小结"><span class="nav-number">1.11.</span> <span class="nav-text">组件小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-Window-体系"><span class="nav-number">2.</span> <span class="nav-text">Buffer/Window 体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码速查表"><span class="nav-number">2.1.</span> <span class="nav-text">代码速查表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native-handle-buffer-handle-t"><span class="nav-number">2.2.</span> <span class="nav-text">native_handle/buffer_handle_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#private-handle-t"><span class="nav-number">2.3.</span> <span class="nav-text">private_handle_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANativeWindowBuffer"><span class="nav-number">2.4.</span> <span class="nav-text">ANativeWindowBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANativeWindow"><span class="nav-number">2.5.</span> <span class="nav-text">ANativeWindow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANativeObjectBase-模板"><span class="nav-number">2.6.</span> <span class="nav-text">ANativeObjectBase 模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GraphicBuffer"><span class="nav-number">2.7.</span> <span class="nav-text">GraphicBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface"><span class="nav-number">2.8.</span> <span class="nav-text">Surface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libui-库"><span class="nav-number">3.</span> <span class="nav-text">libui 库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码目录结构"><span class="nav-number">3.1.</span> <span class="nav-text">代码目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GraphicBufferAllocator-GraphicBufferMapper"><span class="nav-number">3.2.</span> <span class="nav-text">GraphicBufferAllocator/GraphicBufferMapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GraphicBuffer-1"><span class="nav-number">3.3.</span> <span class="nav-text">GraphicBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fence-机制"><span class="nav-number">3.4.</span> <span class="nav-text">Fence 机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DisplayInfo-显示信息"><span class="nav-number">3.5.</span> <span class="nav-text">DisplayInfo 显示信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libgui-库"><span class="nav-number">4.</span> <span class="nav-text">libgui 库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码目录结构-1"><span class="nav-number">4.1.</span> <span class="nav-text">代码目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGraphicBufferProducer-IProducerListener-生产者"><span class="nav-number">4.2.</span> <span class="nav-text">IGraphicBufferProducer/IProducerListener 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGraphicBufferConsumer-IConsumerListener-消费者"><span class="nav-number">4.3.</span> <span class="nav-text">IGraphicBufferConsumer/IConsumerListener 消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferItem"><span class="nav-number">4.4.</span> <span class="nav-text">BufferItem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferSlot"><span class="nav-number">4.5.</span> <span class="nav-text">BufferSlot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferQueueCore"><span class="nav-number">4.6.</span> <span class="nav-text">BufferQueueCore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferQueueProducer-BufferQueueConsumer-生产者-消费者实现类"><span class="nav-number">4.7.</span> <span class="nav-text">BufferQueueProducer/BufferQueueConsumer 生产者/消费者实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferQueue-模型"><span class="nav-number">4.8.</span> <span class="nav-text">BufferQueue 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface-1"><span class="nav-number">4.9.</span> <span class="nav-text">Surface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISurfaceComposer-ISurfaceComposerClient"><span class="nav-number">4.10.</span> <span class="nav-text">ISurfaceComposer/ISurfaceComposerClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SurfaceControl"><span class="nav-number">4.11.</span> <span class="nav-text">SurfaceControl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDisplayEventConnection-显示连接"><span class="nav-number">4.12.</span> <span class="nav-text">IDisplayEventConnection 显示连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">4.13.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SurfaceFlinger"><span class="nav-number">5.</span> <span class="nav-text">SurfaceFlinger</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码速查表-1"><span class="nav-number">5.1.</span> <span class="nav-text">代码速查表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#surfaceflinger-进程"><span class="nav-number">5.2.</span> <span class="nav-text">surfaceflinger 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化流程"><span class="nav-number">5.3.</span> <span class="nav-text">初始化流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DisplayDevice-显示设备"><span class="nav-number">5.4.</span> <span class="nav-text">DisplayDevice 显示设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layer-层"><span class="nav-number">5.5.</span> <span class="nav-text">Layer 层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface-创建流程图"><span class="nav-number">5.6.</span> <span class="nav-text">Surface 创建流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VSYNC-垂直刷新-1"><span class="nav-number">5.7.</span> <span class="nav-text">VSYNC 垂直刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端通知-SurfaceFlinger-刷新"><span class="nav-number">5.8.</span> <span class="nav-text">客户端通知 SurfaceFlinger 刷新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后续"><span class="nav-number">6.</span> <span class="nav-text">后续</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">7.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">redspider110</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
