<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android,">










<meta name="description" content="Android HIDL 基础知识，源码分析。">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android HIDL">
<meta property="og:url" content="http://redspider110.github.io/2018/12/27/0110-android-hidl/index.html">
<meta property="og:site_name" content="Earth Guardian">
<meta property="og:description" content="Android HIDL 基础知识，源码分析。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble_cpp_legacy_hal_progression.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl_memoryblock_arch.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble_cpp_compiler_generated_files.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-hwbinder.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-IBase.png">
<meta property="og:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-IServiceManager.png">
<meta property="og:updated_time" content="2019-09-18T09:30:13.389Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android HIDL">
<meta name="twitter:description" content="Android HIDL 基础知识，源码分析。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://redspider110.github.io/2018/12/27/0110-android-hidl/">





  <title>Android HIDL | Earth Guardian</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?faa79b658398065f8158bf82b6221b6d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Earth Guardian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">You are not LATE!You are not EARLY!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://redspider110.github.io/2018/12/27/0110-android-hidl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="redspider110">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earth Guardian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android HIDL</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-27T09:00:00+08:00">
                2018-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i> 阅读次数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>Android HIDL</code> 基础知识，源码分析。  </p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在 <code>Android O 8.0</code> 后引入的 <code>Treble</code> 项目，目的是将 <code>Framework</code> 和 <code>HAL</code> 层分开；<code>Google</code> 重点关注 <code>Framework</code> 及以上部分，<code>HAL</code> 及以下交给各厂商实现, <code>HAL</code> 层及厂商实现都会放到新的 <code>/vendor</code> 分区中；这样 <code>Google</code> 在后续 <code>OTA</code> 系统升级时，可以单独升级系统部分，而不需要修改厂商实现部分。因此重新定义了 <code>Framework</code> 和 <code>HAL</code> 层的接口，即 <code>HIDL</code> ；以及新增了接口层的测试 <code>VTS: Vendor Test Suite</code> ，确保厂商实现部分接口设计符合规范并能向前兼容。简而言之，<code>Google</code> 这么做主要目的是：不管厂商如何实现，修改了哪些东西，需要确保 <code>Android</code> 原生系统都能在这台设备上升级并使用。当然这种结构也方便手机厂商做 <code>system</code> 升级，如果当前版本已经是 <code>Android O</code> ，各个分区已经分配好，可以做到仅仅更新 <code>AOSP</code> 部分到 <code>P</code> ，而其他 <code>vendor</code> 可以保持不变，提供了一种可能性和便利性，实际上厂商是否愿意这么做呢？  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble.png" alt="0110-android-hidl-treble.png"></p>
<p><code>HIDL: HAL Interface Definition Language</code> ， <code>HIDL</code> 发音为 <code>hide-l</code> ，指定了 <code>HAL</code> 层和 <code>Framework</code> 层通信的接口，目的是 <code>Framework</code>和 <code>HAL</code> 层能相互通信；这样用户能够替换 <code>Android</code> 框架，而无需重新编译 <code>HAL</code> 。  </p>
<h3 id="HAL-类型"><a href="#HAL-类型" class="headerlink" title="HAL 类型"></a><code>HAL</code> 类型</h3><p><code>HAL</code> 有两种类型：  </p>
<ul>
<li><code>Binder HAL</code><br>绑定式 <code>HAL</code> ，通过 <code>Binder</code> 机制实现跨进程通信。  </li>
<li><code>Passthrough HAL</code><br>直通式 <code>HAL</code> ，通过 <code>dlopen</code> 方式加载库，也就是在同一进程直接调用。这里需要注意，默认情况下通常会使用 *<em><code>Binder</code> 化直通式 <code>HAL</code> *</em>，也就是说最后仍然是跨进程 <code>Binder</code> 通信。    </li>
</ul>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble_cpp_legacy_hal_progression.png" alt="0110-android-hidl-treble_cpp_legacy_hal_progression.png"></p>
<h3 id="Binder-HAL"><a href="#Binder-HAL" class="headerlink" title="Binder HAL"></a><code>Binder HAL</code></h3><p><code>Android O</code> 开始，<code>Framework</code> 和 <code>HAL</code> 跨进程也是使用 <code>Binder</code> 互相通信，这种通信方式极大地增加了老版本中的 <code>Binder</code> 流量，因此新增了 <code>Binder</code> 域，官网推荐三个域的使用范围：  </p>
<ul>
<li><code>/dev/binder</code><br>用于 <code>Framework</code> 和 <code>APP</code> 之间的 <code>IPC</code> ，使用 <code>AIDL</code> 接口。  </li>
<li><code>/dev/hwbinder</code><br>用于 <code>Framework</code> 和 <code>Vendor</code> 进程之间的 <code>IPC</code> ，使用 <code>HIDL</code> 接口。<br>用于供应商进程之间的 <code>IPC</code> ，使用 <code>HIDL</code> 接口。  </li>
<li><code>/dev/vndbinder</code><br>供应商/供应商进程之间的 <code>IPC</code> ，使用 <code>AIDL</code> 接口。  </li>
</ul>
<h3 id="Binder-化直通式-HAL"><a href="#Binder-化直通式-HAL" class="headerlink" title="Binder 化直通式 HAL"></a><code>Binder</code> 化直通式 <code>HAL</code></h3><p>它实际是直通模式的 <code>HAL</code> ，通过 <code>Binder</code> 化来实现。比如 <code>HAL</code> 接口 <code>a.b.c.d@M.N::IFoo</code>，系统会创建两个软件包：  </p>
<ul>
<li><code>a.b.c.d@M.N::IFoo-impl</code><br>包含 <code>HAL</code> 的实现，并暴露函数 <code>IFoo* HIDL_FETCH_IFoo(const char* name)</code>。在旧版设备上，此软件包经过 <code>dlopen</code> 处理，且实现使用 <code>HIDL_FETCH_IFoo</code> 进行了实例化。也可以使用 <code>hidl-gen</code> 和 <code>-Lc++-impl</code> 以及 <code>-Landroidbp-impl</code> 来生成基础代码。  </li>
<li><code>a.b.c.d@M.N::IFoo-service</code><br>打开直通式 <code>HAL</code>，并将其自身注册为 <code>Binder</code> 化服务，从而使同一 <code>HAL</code> 实现能够同时以直通模式和 <code>Binder</code> 化模式使用。<br>如果有一个 <code>IFoo</code> ，可以调用 <code>sp&lt;IFoo&gt; IFoo::getService(string name, bool getStub)</code> ，以获取对 <code>IFoo</code> 实例的访问权限。如果 <code>getStub</code> 为 <code>True</code>，则 <code>getService</code> 会尝试仅在直通模式下打开 <code>HAL</code>。如果 <code>getStub</code> 为 <code>False</code>，则 <code>getService</code> 会尝试找到 <code>Binder</code> 化服务；如果未找到，则它会尝试找到直通式服务。除了在 <code>defaultPassthroughServiceImplementation</code> 中，其余情况一律不得使用 <code>getStub</code> 参数。（搭载 <code>Android O</code> 的设备是完全 <code>Binder</code> 化的设备，因此不得在直通模式下打开服务。）  </li>
</ul>
<h3 id="网络配置工具"><a href="#网络配置工具" class="headerlink" title="网络配置工具"></a>网络配置工具</h3><p><code>Android</code> 中包含标准的 <code>Linux</code> 网络实用程序: <code>ifconfig, ip, ip6tables</code> 等，但是这些程序都在 <code>system/bin</code> 目录下， 在 <code>Android O</code> 之后，避免系统更新导致这些程序使用时不匹配，这些程序都被集成到 <code>netutils-wrapper-1.0</code> 工具中：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ELUGA_Ray_710:/system/bin # ls *wrapper-* -l</span><br><span class="line">lrwxr-xr-x 1 root shell    20 20*:56 ip-wrapper-1.0 -&gt; netutils-wrapper-1.0</span><br><span class="line">lrwxr-xr-x 1 root shell    20 20*:56 ip6tables-wrapper-1.0 -&gt; netutils-wrapper-1.0</span><br><span class="line">lrwxr-xr-x 1 root shell    20 20*:56 iptables-wrapper-1.0 -&gt; netutils-wrapper-1.0</span><br><span class="line">lrwxr-xr-x 1 root shell    20 20*:56 ndc-wrapper-1.0 -&gt; netutils-wrapper-1.0</span><br><span class="line">lrwxr-xr-x 1 root shell    20 20*:56 tc-wrapper-1.0 -&gt; netutils-wrapper-1.0</span><br><span class="line">-rwxr-xr-x 1 root shell 65248 20*:56 netutils-wrapper-1.0</span><br></pre></td></tr></table></figure>

<p><code>Android O</code> 之后，<code>vendor</code> 中不能直接调用 <code>/system/bin/netutils-wrapper-1.0</code> ，否则会出错；也不能直接调用 <code>/system/bin/ip &lt;FOO&gt; &lt;BAR&gt;</code> ，而只能使用封装程序 <code>/system/bin/ip-wrapper-1.0 &lt;FOO&gt; &lt;BAR&gt;</code> ；如果 <code>vendor</code> 进程调用这些命令，需要在 <code>SELinux policy</code> 中添加：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain_auto_trans(VENDOR-DOMAIN-NAME, netutils_wrapper_exec, netutils_wrapper)</span><br></pre></td></tr></table></figure>

<h3 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h3><p><code>Android</code> 源码中提供了工具将老旧版本的 <code>hal</code> 模块转换为 <code>HIDL HAL</code> 格式，工具： <code>c2hal: system/tools/hidl/c2hal</code> ，使用示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2hal -r android.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport -p android.hardware.nfc@1.0 hardware/libhardware/include/hardware/nfc.h</span><br></pre></td></tr></table></figure>

<p>转换完成后，可以进一步手动修正部分小错误。  </p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><code>Binder</code> 化<br>表示 <code>HIDL</code> 用于进程之间的远程过程调用，并通过类似 <code>Binder</code> 的机制来实现。  </li>
<li>异步回调<br>由 <code>HAL</code> 用户提供、传递给 <code>HAL</code>（通过 <code>HIDL</code> 方法）并由 <code>HAL</code> 调用以随时返回数据的接口。  </li>
<li>同步回调<br>将数据从服务器的 <code>HIDL</code> 方法实现返回到客户端；不用于返回无效值或单个原始值的方法。  </li>
<li>客户端<br>调用特定接口的方法的进程。 <code>HAL</code> 进程或框架进程可以是一个接口的客户端和另一个接口的服务器。  </li>
<li>扩展<br>也可以理解为继承；表示向另一接口添加方法和/或类型的接口，一个接口只能扩展另一个接口。可用于具有相同软件包名称的 <code>Minor</code> 版本递增，也可用于在旧软件包的基础上构建的新软件包。  </li>
<li>生成<br>表示将值返回给客户端的接口方法。要返回一个非原始值或多个值，则会生成同步回调函数。  </li>
<li>接口<br>方法和类型的集合。会转换为 <code>C++</code> 或 <code>Java</code> 中的类。接口中的所有方法均按同一方向调用：客户端进程会调用由服务器进程实现的方法。  </li>
<li>单向<br>应用到 <code>HIDL</code> 方法时，表示该方法既不返回任何值也不会造成阻塞。  </li>
<li>直通式<br><code>HIDL</code> 的一种模式，使用这种模式时，服务器是共享库，由客户端进行 <code>dlopen</code> 处理。在直通模式下，客户端和服务器是相同的进程，但代码库不同。此模式仅用于将旧版代码库并入 <code>HIDL</code> 模型。  </li>
<li>服务器<br>实现接口的方法的进程。  </li>
<li>传输<br>在服务器和客户端之间移动数据的 <code>HIDL</code> 基础架构。  </li>
<li>版本<br>软件包的版本。由两个整数组成： <code>Major</code> 版本和 <code>Minor</code> 版本。 <code>Minor</code> 版本递增可以添加（但不会更改）类型和方法。  </li>
<li>应用二进制接口 `ABI<br>应用编程接口 + 所需的任何二进制链接。  </li>
<li>完全限定名称 <code>fqName</code><br>用于区分 <code>hidl</code> 类型的名称。例如： <code>android.hardware.foo@1.0::IFoo</code> 。  </li>
<li>软件包<br>共用一个版本的接口和数据类型的集合。包含 <code>HIDL</code> 接口和类型的软件包。例如： <code>android.hardware.foo@1.0</code> 。  </li>
<li>软件包根目录<br>包含 <code>HIDL</code> 接口的根目录软件包。例如： <code>HIDL</code> 接口 <code>android.hardware</code> 在软件包根目录 <code>android.hardware.foo@1.0</code> 中。  </li>
<li>软件包根目录路径<br>软件包根目录映射到的 <code>Android</code> 源代码树中的位置。  </li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">ROOT =</span><br><span class="line">    PACKAGE IMPORTS PREAMBLE &#123; ITEM ITEM ... &#125;  // not for types.hal</span><br><span class="line">    PREAMBLE = interface identifier EXTENDS</span><br><span class="line">  | PACKAGE IMPORTS ITEM ITEM...  // only for types.hal; no method definitions</span><br><span class="line"></span><br><span class="line">ITEM =</span><br><span class="line">    ANNOTATIONS? oneway? identifier(FIELD, FIELD ...) GENERATES?;</span><br><span class="line">  |  struct identifier &#123; SFIELD; SFIELD; ...&#125;;  // Note - no forward declarations</span><br><span class="line">  |  union identifier &#123; UFIELD; UFIELD; ...&#125;;</span><br><span class="line">  |  enum identifier: TYPE &#123; ENUM_ENTRY, ENUM_ENTRY ... &#125;; // TYPE = enum or scalar</span><br><span class="line">  |  typedef TYPE identifier;</span><br><span class="line"></span><br><span class="line">VERSION = integer.integer;</span><br><span class="line"></span><br><span class="line">PACKAGE = package android.hardware.identifier[.identifier[...]]@VERSION;</span><br><span class="line"></span><br><span class="line">PREAMBLE = interface identifier EXTENDS</span><br><span class="line"></span><br><span class="line">EXTENDS = &lt;empty&gt; | extends import_name  // must be interface, not package</span><br><span class="line"></span><br><span class="line">GENERATES = generates (FIELD, FIELD ...)</span><br><span class="line"></span><br><span class="line">// allows the Binder interface to be used as a type</span><br><span class="line">// (similar to typedef&apos;ing the final identifier)</span><br><span class="line">IMPORTS =</span><br><span class="line">   [empty]</span><br><span class="line">  |  IMPORTS import import_name;</span><br><span class="line"></span><br><span class="line">TYPE =</span><br><span class="line">  uint8_t | int8_t | uint16_t | int16_t | uint32_t | int32_t | uint64_t | int64_t |</span><br><span class="line"> float | double | bool | string</span><br><span class="line">|  identifier  // must be defined as a typedef, struct, union, enum or import</span><br><span class="line">               // including those defined later in the file</span><br><span class="line">|  memory</span><br><span class="line">|  pointer</span><br><span class="line">|  vec&lt;TYPE&gt;</span><br><span class="line">|  bitfield&lt;TYPE&gt;  // TYPE is user-defined enum</span><br><span class="line">|  fmq_sync&lt;TYPE&gt;</span><br><span class="line">|  fmq_unsync&lt;TYPE&gt;</span><br><span class="line">|  TYPE[SIZE]</span><br><span class="line"></span><br><span class="line">FIELD =</span><br><span class="line">   TYPE identifier</span><br><span class="line"></span><br><span class="line">UFIELD =</span><br><span class="line">   TYPE identifier</span><br><span class="line">  |  struct identifier &#123; FIELD; FIELD; ...&#125; identifier;</span><br><span class="line">  |  union identifier &#123; FIELD; FIELD; ...&#125; identifier;</span><br><span class="line"></span><br><span class="line">SFIELD =</span><br><span class="line">   TYPE identifier</span><br><span class="line">  |  struct identifier &#123; FIELD; FIELD; ...&#125;;</span><br><span class="line">  |  union identifier &#123; FIELD; FIELD; ...&#125;;</span><br><span class="line">  |  struct identifier &#123; FIELD; FIELD; ...&#125; identifier;</span><br><span class="line">  |  union identifier &#123; FIELD; FIELD; ...&#125; identifier;</span><br><span class="line"></span><br><span class="line">SIZE =  // Must be greater than zero</span><br><span class="line">     constexpr</span><br><span class="line"></span><br><span class="line">ANNOTATIONS =</span><br><span class="line">     [empty]</span><br><span class="line">  |  ANNOTATIONS ANNOTATION</span><br><span class="line"></span><br><span class="line">ANNOTATION =</span><br><span class="line">  |  @identifier</span><br><span class="line">  |  @identifier(VALUE)</span><br><span class="line">  |  @identifier(ANNO_ENTRY, ANNO_ENTRY  ...)</span><br><span class="line"></span><br><span class="line">ANNO_ENTRY =</span><br><span class="line">     identifier=VALUE</span><br><span class="line"></span><br><span class="line">VALUE =</span><br><span class="line">     &quot;any text including \&quot; and other escapes&quot;</span><br><span class="line">  |  constexpr</span><br><span class="line">  |  &#123;VALUE, VALUE ...&#125;  // only in annotations</span><br><span class="line"></span><br><span class="line">ENUM_ENTRY =</span><br><span class="line">     identifier</span><br><span class="line">  |  identifier = constexpr</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>/** */, /* */, //</code> 来注释  </li>
<li><code>[empty]</code> 表示该字词可能为空  </li>
<li><code>?</code> 跟在文本或字词后，表示它是可选的  </li>
<li><code>...</code> 表示包含零个或多个项、用指定的分隔符号分隔的序列。<code>HIDL</code> 中<strong>不含</strong>可变参数  </li>
<li>逗号 <code>,</code> 用于分隔序列元素  </li>
<li>分号 <code>;</code> 用于终止各个元素，包括最后的元素  </li>
<li>大写字母是非终止符  </li>
<li>italics 是一个令牌系列，例如 integer 或 identifier（标准 C 解析规则）  </li>
<li>constexpr 是 C 样式的常量表达式（如 1 + 1 和 1L &lt;&lt; 3）  </li>
<li>import_name 是软件包或接口名称，按 HIDL 版本编号中所述的方式加以限定</li>
<li>小写 words 是文本令牌</li>
</ul>
<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><p>软件包名称可以具有子级，例如 <code>package.subpackage</code> 。软件包前缀和对应的位置如下：  </p>
<table>
<thead>
<tr>
<th align="left">软件包前缀</th>
<th align="left">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">android.hardware.*</td>
<td align="left">hardware/interfaces/*</td>
</tr>
<tr>
<td align="left">android.frameworks.*</td>
<td align="left">frameworks/hardware/interfaces/*</td>
</tr>
<tr>
<td align="left">android.system.*</td>
<td align="left">system/hardware/interfaces/*</td>
</tr>
<tr>
<td align="left">android.hidl.*</td>
<td align="left">system/libhidl/transport/*</td>
</tr>
</tbody></table>
<p>例如 <code>package android.hardware.example.extension.light@2.0</code> 软件包：<br>可以在 <code>hardware/interfaces/example/extension/light/2.0</code> 下找到。软件包目录中包含扩展名为 <code>.hal</code> 的文件，每个文件均必须包含一个指定文件所属的软件包和版本的 <code>package</code> 语句；文件 <code>types.hal</code>（如果存在）并不定义接口，而是定义软件包中每个接口可以访问的数据类型。  </p>
<h3 id="版本编号"><a href="#版本编号" class="headerlink" title="版本编号"></a>版本编号</h3><p>软件包分版本，用两个整数表示： <code>major.minor</code> ：  </p>
<ul>
<li><code>Major</code> 版本不向后兼容<br>递增 <code>Major</code> 版本号将会使 <code>Minor</code> 版本号重置为 0 。  </li>
<li><code>Minor</code> 版本向后兼容<br>如果递增 <code>Minor</code> 版本号，则意味着较新版本完全向后兼容之前的版本。可以添加新的数据结构和方法，但不能更改现有的数据结构或方法签名。  </li>
</ul>
<p>可同时在一台设备上提供 <code>HAL</code> 的多个 <code>Major</code> 或 <code>Minor</code> 版本。不过 <code>Minor</code> 版本应优先于 <code>Major</code> 版本，因为与之前的 <code>Minor</code> 版本接口一起使用的客户端代码也适用于同一接口的后续 <code>Minor</code> 版本。  </p>
<h3 id="支持的注解"><a href="#支持的注解" class="headerlink" title="支持的注解"></a>支持的注解</h3><p>主要用于 VTS 测试 </p>
<ul>
<li><code>@callflow</code><br><code>next=</code>  </li>
<li><code>@entry</code>  </li>
<li><code>@exit</code>  </li>
</ul>
<h3 id="hal-定义"><a href="#hal-定义" class="headerlink" title="hal 定义"></a><code>hal</code> 定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IBar extends IFoo &#123; // IFoo is another interface</span><br><span class="line">    // embedded types</span><br><span class="line">    struct MyStruct &#123;/*...*/&#125;;</span><br><span class="line"></span><br><span class="line">    // interface methods</span><br><span class="line">    create(int32_t id) generates (MyStruct s);</span><br><span class="line">    close();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不含显式 <code>extends</code> 声明的接口会从 <code>android.hidl.base@1.0::IBase</code> （类似于 <code>Java</code> 中的 <code>java.lang.Object</code> ）隐式扩展。隐式导入的 <code>IBase</code> 接口声明了多种不应也不能在用户定义的接口中重新声明或以其他方式使用的预留方法，也就是说 <code>hal</code> 中不存在重载和重写！  </p>
<p>接口只能扩展一个其他接口（<strong>不支持多重继承</strong>），具有非零 <code>Minor</code> 版本号的软件包中的每个接口必须扩展一个以前版本的软件包中的接口：  </p>
<ul>
<li>存在 1.2 版本的软件包 <code>original</code> 中的接口 <code>IFoo</code>  </li>
<li>小版本 <code>Minor</code> 升级到 1.3 版本，软件包 <code>original</code> 中的接口 <code>IFoo</code> 必须继承 1.2 版本的 <code>IFoo</code>  </li>
<li>假设大版本 <code>Major</code> 升级到 4.0 版本，而软件包 <code>derivative</code> 中的接口 <code>IBar</code> 是继承于 1.2 版本的软件包 <code>original</code> 中的接口 <code>IFoo</code>  </li>
<li>小版本 <code>Minor</code> 升级到 4.1 版本， <code>IBar</code> 必须扩展 4.0 版本的 <code>IBar</code> ；而不能继承 1.3 版本的 <code>IFoo</code> ，因为它是与 1.2 版本的 <code>IFoo</code> 绑定的  </li>
<li>大版本 <code>Major</code> 再次升级到 5.0 版本，此时 <code>IBar</code> 可以直接 1.3 版本的 `IFoo  </li>
</ul>
<p>接口扩展并不意味着生成的代码中存在代码库依赖关系或跨 <code>HAL</code> 包含关系，接口扩展只是在 <code>HIDL</code> 级别导入数据结构和方法定义。<code>HAL</code> 中的每个方法必须在相应 <code>HAL</code> 中重新实现。  </p>
<h3 id="import-导入"><a href="#import-导入" class="headerlink" title="import 导入"></a><code>import</code> 导入</h3><p><code>import</code> 语句是用于访问其他软件包中的软件包接口和类型的 <code>HIDL</code> 机制，存在两种导入情况：  </p>
<ul>
<li><code>import</code> 语句位于 <code>types.hal</code> 文件中时，导入的内容对整个软件包可见，属于软件包级导入  </li>
<li><code>improt</code> 语句位于 <code>custom.hal</code> 接口文件中时，导入的内容只对当前接口文件可见，属于接口级导入  </li>
</ul>
<p><code>import</code> 语句后，根据导入值分三种情况：  </p>
<ul>
<li>完整软件包导入<br>导入值是一个软件包名称和版本，则系统会将整个软件包导入，即可访问整个软件包的接口或类型。  </li>
<li>接口导入<br>导入值是一个接口文件，则导入该接口以及 <code>types.hal</code> 两个文件。  </li>
<li>类型导入<br>导入值是 <code>types.hal</code> 中定义的某个类型，则仅将该类型导入，而 <code>types.hal</code> 中的其他类型不导入。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import android.hardware.nfc@1.0;            // 导入整个软件包</span><br><span class="line">import android.hardware.example@1.0::IQuux; // 导入接口文件和 types.hal</span><br><span class="line">import android.hardware.example@1.0::types; // 仅仅导入 types.hal 中定义的 types 类型</span><br></pre></td></tr></table></figure>

<h3 id="接口哈希-Hash-和版本控制文件-current-txt"><a href="#接口哈希-Hash-和版本控制文件-current-txt" class="headerlink" title="接口哈希 Hash 和版本控制文件 current.txt"></a>接口哈希 <code>Hash</code> 和版本控制文件 <code>current.txt</code></h3><p><code>HIDL</code> 接口哈希，是一种旨在防止意外更改接口并确保接口更改经过全面审查的机制。因为 <code>HIDL</code> 接口带有版本编号，也就是说接口一经发布便不得再更改。  </p>
<p>软件包根目录必须有版本控制文件 <code>current.txt</code> ；如果创建一个软件包路径，如 <code>-r vendor.awesome:vendor/awesome/interfaces</code> ），则还应创建文件 <code>$ANDROID_BUILD_TOP/vendor/awesome/interfaces/current.txt</code> 。<br><code>current.txt</code> 必须包含接口哈希及接口全限定名称，比如 <code>system/libhidl/transport/current.txt</code> 文件内容为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Do not change this file except to add new interfaces. Changing</span><br><span class="line"># pre-existing interfaces will fail VTS and break framework-only OTAs</span><br><span class="line"></span><br><span class="line"># HALs released in Android O</span><br><span class="line"></span><br><span class="line">fc6c***da68 android.hidl.allocator@1.0::IAllocator</span><br><span class="line">bdda***0fd9 android.hidl.base@1.0::IBase</span><br><span class="line">500e***7567 android.hidl.base@1.0::types</span><br><span class="line">4d04***0d3f android.hidl.manager@1.0::IServiceManager</span><br><span class="line">5055***50fb android.hidl.manager@1.0::IServiceNotification</span><br><span class="line">2b88***27c8 android.hidl.memory@1.0::IMapper</span><br><span class="line">4632***a16b android.hidl.memory@1.0::IMemory</span><br><span class="line">7c9f***4b7c android.hidl.token@1.0::ITokenManager</span><br><span class="line"></span><br><span class="line"># HALs released in Android O-MR1</span><br><span class="line"></span><br><span class="line">0b94***4ef6 android.hidl.manager@1.1::IServiceManager</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>current.txt</code> 中的内容按照 <code>Android</code> 大版本来分隔，比如上半部分为 <code>Android O</code> ，下半部分为 <code>Android O-MR1</code> ，厂商自定义的接口文件也应该遵循这个格式。  </p>
</blockquote>
<p>可以手动将哈希添加到 <code>current.txt</code> 文件中，也可以使用 <code>hidl-gen</code> 加上参数 <code>-Lhash</code> 选项添加。<br>如下为针对类型文件、接口、整个软件包生成哈希：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0::types</span><br><span class="line">9626fd18...f9d298a6 vendor.awesome.nfc@1.0::types</span><br><span class="line">$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0::INfc</span><br><span class="line">07ac2dc9...11e3cf57 vendor.awesome.nfc@1.0::INfc</span><br><span class="line">$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0</span><br><span class="line">9626fd18...f9d298a6 vendor.awesome.nfc@1.0::types</span><br><span class="line">07ac2dc9...11e3cf57 vendor.awesome.nfc@1.0::INfc</span><br><span class="line">f2fe5442...72655de6 vendor.awesome.nfc@1.0::INfcClientCallback</span><br></pre></td></tr></table></figure>

<p>如果是新添加的 <code>hal</code> 软件包，则将生成哈希及对应接口文件，一并写入 <code>current.txt</code> 文件中：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0 &gt;&gt; vendor/awesome/hardware/interfaces/current.txt</span><br></pre></td></tr></table></figure>

<p>接口文件的哈希，可以通过调用 <code>IBase::getHashChain</code> 来查看。 <code>hidl-gen</code> 编译接口时，会检查 <code>HAL</code> 软件包根目录中的 <code>current.txt</code> 文件，以查看 <code>HAL</code> 是否已被更改：  </p>
<ul>
<li>如果没有找到对应的哈希值，则继续编译，并认为接口没有发布  </li>
<li>如果找到了对应哈希值，则做相应检查：  <ul>
<li>如果接口与哈希值匹配，则继续编译  </li>
<li>如果接口与哈希值不匹配，则意味着接口被更改了，停止编译  </li>
</ul>
</li>
</ul>
<p>所以，如果接口文件处于调试阶段，需要等调试完成后再发布到 <code>current.txt</code> 中；而接口文件一旦发布，将无法更改；如果想更改接口，必须升级版本号，也就是重新定义接口。比如 <code>camera</code> 相关接口的修改，必须升级版本号：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// hardware/interfaces/current.txt</span><br><span class="line">c170***2d62f android.hardware.camera.device@1.0::ICameraDevice</span><br><span class="line">78e9***44076 android.hardware.camera.device@1.0::ICameraDeviceCallback</span><br><span class="line">28f0***44566 android.hardware.camera.device@1.0::ICameraDevicePreviewCallback</span><br><span class="line">4db4***352a3 android.hardware.camera.device@1.0::types</span><br><span class="line">b32f***55918 android.hardware.camera.device@3.2::ICameraDevice</span><br><span class="line">63bf***b3b21 android.hardware.camera.device@3.2::ICameraDeviceCallback</span><br><span class="line">0fa3***7208e android.hardware.camera.device@3.2::ICameraDeviceSession</span><br></pre></td></tr></table></figure>

<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>数据在传递过程中：  </p>
<ul>
<li><code>.hal</code> 文件接口中定义的方法默认为阻塞模式，如果需要采用非阻塞式则在方法前面使用关键字 <code>oneway</code>  </li>
<li>方法调用和回调只能接受 <code>in</code> 参数，并且不支持 <code>out, inout</code> 参数  </li>
<li>方法在数据传递时超过 4KB 以上的数据便被认为是过度调用；同时跨进程调用是基于 <code>Binder</code> 机制，所以总的数据传输不能超过 1MB  </li>
</ul>
<p>对于跨进程通信， <code>HIDL</code> 只使用参数回调函数，避免了内存所有权的棘手问题，特别是不能有效通过方法返回的值可以直接通过回调函数返回。这样既不将数据传递到 <code>HIDL</code> ，也不从 <code>HIDL</code> 接收数据，改变数据的所有权。数据只需要在被调用函数的持续时间内存在，并且可以在被调用函数返回后立即销毁。  </p>
<p><code>HIDL</code> 如果不使用 <code>Binder RPC</code> ，可以通过两种方法来转移数据：  </p>
<ul>
<li>共享内存<br>分配的内存通过映射来共享。  </li>
<li>快速消息队列 <code>FMQ</code><br><code>HIDL</code> 提供了一种可实现无等待消息传递的模板化消息队列类型。</li>
</ul>
<h3 id="快速消息队列-FMQ"><a href="#快速消息队列-FMQ" class="headerlink" title="快速消息队列 FMQ"></a>快速消息队列 <code>FMQ</code></h3><p><code>HIDL</code> 的远程过程调用 <code>RPC</code> 基础架构使用 <code>Binder</code> 机制，这意味着调用涉及开销、需要内核操作，并且可以触发调度程序操作。不过对于必须在开销较小且无内核参与的进程之间传输数据的情况， <code>HIDL</code> 提供了快速消息队列 <code>FMQ</code> 系统。<br><code>FMQ</code> 会创建具有所需属性的消息队列， <code>MQDescriptorSync, MQDescriptorUnsync</code> 对象可通过 <code>HIDL RPC</code> 调用发送，并可供接收进程用于访问消息队列。  </p>
<p>它在直通式或绑定式模式下不使用内核或调度程序，从而创建可以借助内置 <code>HIDL</code> 类型 <code>MQDescriptorSync</code> 或 <code>MQDescriptorUnsync</code> 的参数通过 <code>RPC</code> 传递的对象。  </p>
<p><code>MessageQueue</code> 支持的队列类型 <code>flavor</code> 有两种：  </p>
<ul>
<li>未同步队列 <code>flavor: kSynchronizedReadWrite</code><br>可以溢出，并且可以有多个读取器；每个读取器都必须及时读取数据，否则数据将会丢失。未同步队列只有一个写入器，但可以有任意多个读取器。此类队列有一个写入位置；不过，每个读取器都会跟踪各自的独立读取位置。执行写入操作一定会成功（不会检查是否出现溢出情况），但前提是写入的内容不超出配置的队列容量（如果写入的内容超出队列容量，则操作会立即失败）。由于各个读取器的读取位置可能不同，因此每当新的写入操作需要空间时，系统都允许数据离开队列，而无需等待每个读取器读取每条数据。  </li>
<li>已同步队列 <code>flavor: kUnsynchronizedWrite</code><br>不能溢出，并且只能有一个读取器。已同步队列有一个写入器和一个读取器，其中写入器有一个写入位置，读取器有一个读取位置。写入的数据量不可能超出队列可提供的空间；读取的数据量不可能超出队列当前存在的数据量。  </li>
</ul>
<p>这两种队列都不能下溢（从空队列进行读取将会失败），并且只能有一个写入器。  </p>
<p><code>FMQ</code> 相关源码路径如下，其中 <code>MessageQueue</code> 主要是模板，所以定义和代码实现都在该 <code>.h</code> 文件中：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system/libfmq/include/fmq/MessageQueue.h</span><br><span class="line">system/libhidl/base/include/hidl/MQDescriptor.h</span><br></pre></td></tr></table></figure>

<p>队列类型是在 <code>MQDescriptor.h</code> 中定义的：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MQDescriptor.h</span></span><br><span class="line"><span class="keyword">enum</span> MQFlavor : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * represents the wait-free synchronized flavor of the</span></span><br><span class="line"><span class="comment">   * FMQ. It is intended to be have a single reader and single writer.</span></span><br><span class="line"><span class="comment">   * Attempts to overflow/underflow returns a failure.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  kSynchronizedReadWrite = <span class="number">0x01</span>,</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * represents the flavor of FMQ where writes always succeed. </span></span><br><span class="line"><span class="comment">   * This flavor allows one writer and many readers. A read operation</span></span><br><span class="line"><span class="comment">   * can detect an overwrite and reset the read counter.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  kUnsynchronizedWrite = <span class="number">0x02</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建快速队列示例：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmq/MessageQueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> android::hardware::kSynchronizedReadWrite;</span><br><span class="line"><span class="keyword">using</span> android::hardware::kUnsynchronizedWrite;</span><br><span class="line"><span class="keyword">using</span> android::hardware::MQDescriptorSync;</span><br><span class="line"><span class="keyword">using</span> android::hardware::MQDescriptorUnsync;</span><br><span class="line"><span class="keyword">using</span> android::hardware::MessageQueue;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// For a synchronized non-blocking FMQ</span></span><br><span class="line">mFmqSynchronized =</span><br><span class="line">  <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) MessageQueue&lt;<span class="keyword">uint16_t</span>, kSynchronizedReadWrite&gt;</span><br><span class="line">      (kNumElementsInQueue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For an unsynchronized FMQ that supports blocking</span></span><br><span class="line">mFmqUnsynchronizedBlocking =</span><br><span class="line">  <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) MessageQueue&lt;<span class="keyword">uint16_t</span>, kUnsynchronizedWrite&gt;</span><br><span class="line">      (kNumElementsInQueue, <span class="literal">true</span> <span class="comment">/* enable blocking operations */</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MessageQueue&lt;T, flavor&gt;(numElements)</code> 初始化程序负责创建并初始化支持消息队列功能的对象  </li>
<li><code>MessageQueue&lt;T, flavor&gt;(numElements, configureEventFlagWord)</code> 初始化程序负责创建并初始化支持消息队列功能和阻塞的对象  </li>
<li><code>flavor</code> 可以是 <code>kSynchronizedReadWrite</code> 同步队列或 <code>kUnsynchronizedWrite</code> 未同步队列  </li>
<li><code>uint16_t</code> 可以是任意不涉及嵌套式缓冲区（无 <code>string</code> 或 <code>vec</code> 类型）、句柄或接口的 <code>HIDL</code> 定义的类型  </li>
<li><code>kNumElementsInQueue</code> 表示队列的大小（以条目数表示）；它用于确定将为队列分配的共享内存缓冲区的大小  </li>
</ul>
<h3 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h3><p><code>HIDL</code> 共享内存 <code>MemoryBlock</code> 是构建在 <code>hidl_memory</code> ， <code>HIDL @1.0::IAllocator</code> 和 <code>HIDL @1.0::IMapper</code> 之上的抽象层，专为有多个内存块共用单个内存堆的 <code>HIDL</code> 服务而设计。<br>也就是说， <code>HIDL</code> 共享内存块只是提供了一种使用思路，而不是像 <code>FMQ</code> 提供了具体实现；使用 <code>MemoryBlock</code> 可显著减少 <code>mmap/munmap</code> 数量和用户空间细分错误，从而提升性能。架构图如下，核心思想是多个内存块共用单个内存堆 <code>hidl_memory</code> ：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl_memoryblock_arch.png" alt="0110-android-hidl_memoryblock_arch.png"></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>HIDL</code> 基本数据类型及对应处理，都是在 <code>system/libhidl/base</code> 目录中实现的，基本数据类型的定义文件为 <code>HidlSupport.h</code> ，目录结构为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── Android.bp</span><br><span class="line">├── HidlInternal.cpp</span><br><span class="line">├── HidlSupport.cpp</span><br><span class="line">├── include</span><br><span class="line">│   └── hidl</span><br><span class="line">│       ├── HidlInternal.h</span><br><span class="line">│       ├── HidlSupport.h</span><br><span class="line">│       ├── MQDescriptor.h</span><br><span class="line">│       ├── Status.h</span><br><span class="line">│       ├── SynchronizedQueue.h</span><br><span class="line">│       └── TaskRunner.h</span><br><span class="line">├── Status.cpp</span><br><span class="line">└── TaskRunner.cpp</span><br><span class="line"></span><br><span class="line">2 directories, 11 files</span><br></pre></td></tr></table></figure>

<h3 id="hidl-death-recipient"><a href="#hidl-death-recipient" class="headerlink" title="hidl_death_recipient"></a><code>hidl_death_recipient</code></h3><p>服务死亡通知，如果客户端注册该通知，当服务端断开时，会发出通知。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_death_recipient</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">serviceDied</span><span class="params">(<span class="keyword">uint64_t</span> cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> ::android::wp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; who)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="hidl-handle"><a href="#hidl-handle" class="headerlink" title="hidl_handle"></a><code>hidl_handle</code></h3><p>句柄基本类型，是对 <code>native_handle_t</code> 句柄的封装：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_handle</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// explicit conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> native_handle_t *<span class="title">getNativeHandle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    details::hidl_pointer&lt;<span class="keyword">const</span> <span class="keyword">native_handle_t</span>&gt; </span><br><span class="line">        mHandle __attribute__ ((aligned(<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用传递 <code>hidl_handle</code> 对象（复合类型的顶级或一部分）的 <code>HIDL</code> 接口方法时，其中包含的文件描述符的所有权如下所述：  </p>
<ul>
<li>将 <code>hidl_handle</code> 对象作为参数传递的调用程序会保留对其封装的 <code>native_handle_t</code> 中包含的文件描述符的所有权；该调用程序在完成对这些文件描述符的操作后，必须将这些文件描述符关闭  </li>
<li>通过将 <code>hidl_handle</code> 对象传递到 <code>_cb</code> 函数来返回该对象的进程会保留对该对象封装的 <code>native_handle_t</code> 中包含的文件描述符的所有权；该进程在完成对这些文件描述符的操作后，必须将这些文件描述符关闭  </li>
<li>接收 <code>hidl_handle</code> 的传输拥有对相应对象封装的 <code>native_handle_t</code> 中的文件描述符的所有权；接收器可在事务回调期间按原样使用这些文件描述符，但如果想在回调完成后继续使用这些文件描述符，则必须克隆原生句柄。事务完成时， <code>transport</code> 将自动对文件描述符执行 <code>close</code> 操作  </li>
</ul>
<p><code>HIDL</code> 不支持在 <code>Java</code> 中使用句柄。  </p>
<h3 id="hidl-string"><a href="#hidl-string" class="headerlink" title="hidl_string"></a><code>hidl_string</code></h3><p><code>HIDL</code> 字符串；通过 <code>HIDL</code> 接口将字符串传递到 <code>Java</code> 或从 <code>Java</code> 传递字符串将会导致字符集转换，而此项转换可能无法精确保留原始编码。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_string</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    details::hidl_pointer&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt; mBuffer;</span><br><span class="line">    <span class="keyword">uint32_t</span> mSize;  <span class="comment">// NOT including the terminating '\0'.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="hidl-memory"><a href="#hidl-memory" class="headerlink" title="hidl_memory"></a><code>hidl_memory</code></h3><p><code>memory</code> 类型用于表示 <code>HIDL</code> 中未映射的共享内存。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_memory</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hidl_handle mHandle __attribute__ ((aligned(<span class="number">8</span>)));</span><br><span class="line">    <span class="keyword">uint64_t</span> mSize __attribute__ ((aligned(<span class="number">8</span>)));</span><br><span class="line">    hidl_string mName __attribute__ ((aligned(<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="hidl-vec"><a href="#hidl-vec" class="headerlink" title="hidl_vec"></a><code>hidl_vec</code></h3><p><code>vec&lt;T&gt;</code> 模板用于表示包含 <code>T</code> 实例且大小可变的缓冲区。 <code>T</code> 可以是任何由 <code>HIDL</code> 提供的或由用户定义的类型，句柄除外。（ <code>vec&lt;T&gt;</code> 的 <code>vec&lt;&gt;</code> 将指向 <code>vec&lt;T&gt;</code> 结构体数组，而不是指向内部 <code>T</code> 缓冲区数组。） <code>T</code> 可以是以下项之一：  </p>
<ul>
<li>基本类型（例如 <code>uint32_t</code> ）  </li>
<li>字符串  </li>
<li>用户定义的枚举  </li>
<li>用户定义的结构体  </li>
<li>接口，或 <code>interface</code> 关键字（ <code>vec&lt;IFoo&gt;，vec&lt;interface&gt;</code> 仅在作为顶级参数时受支持）  </li>
<li>句柄  </li>
<li><code>bitfield&lt;U&gt;</code>  </li>
<li><code>vec&lt;U&gt;</code> ，其中 <code>U</code> 可以是此列表中的任何一项，接口除外（例如， <code>vec&lt;vec&lt;IFoo&gt;&gt;</code> 不受支持）  </li>
<li><code>U[]</code>（有大小的 <code>U</code> 数组），其中 <code>U</code> 可以是此列表中的任何一项，接口除外  </li>
</ul>
<h3 id="hidl-array"><a href="#hidl-array" class="headerlink" title="hidl_array"></a><code>hidl_array</code></h3><p>表示多维数组。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> SIZE1, <span class="keyword">size_t</span>... SIZES&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_array</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mBuffer[elementCount()];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An array of T's. Assumes that T::operator=(const T &amp;) is defined.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> SIZE1&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_array</span>&lt;T, SIZE1&gt; &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mBuffer[SIZE1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="hidl-version"><a href="#hidl-version" class="headerlink" title="hidl_version"></a><code>hidl_version</code></h3><p><code>HIDL</code> 版本号。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidl_version</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> uint16_t <span class="title">get_major</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mMajor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> uint16_t <span class="title">get_minor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mMinor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uint16_t</span> mMajor;</span><br><span class="line">    <span class="keyword">uint16_t</span> mMinor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> android::hardware::<span class="function">hidl_version <span class="title">make_hidl_version</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint16_t</span> major, <span class="keyword">uint16_t</span> minor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hidl_version(major,minor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hal-文件自动生成代码"><a href="#hal-文件自动生成代码" class="headerlink" title=".hal 文件自动生成代码"></a><code>.hal</code> 文件自动生成代码</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>比如 <code>.hal</code> 文件准备添加到 <code>hardware/interface</code> 目录下：  </p>
<ul>
<li>新建包名对应的文件夹，比如 <code>myintere</code>  </li>
<li>在包文件夹下新建主次版本对应的文件夹，比如 <code>1.0</code>  </li>
<li>在版本目录下定义并编写 <code>.hal</code> 文件  </li>
<li>执行 <code>.hal</code> 文件所在位置的 <code>update-makefiles.sh</code> 脚本（实际还是调用的 <code>hidl-gen</code> ），自动生成 <code>Android.bp/mk</code> 文件<br>因为是在 <code>hardware/interface</code> 目录下添加的，则执行： <code>./hardware/interfaces/update-makefiles.sh</code> ，自动生成对应 <code>Android.bp</code> 。  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1. 新建目录</span><br><span class="line">xmt@server139:~/**/hardware/interfaces/tests/$ mkdir -p myintere/1.0</span><br><span class="line">// 2. 新建 .hal 文件</span><br><span class="line">xmt@server139:~/**/hardware/interfaces/tests/myintere/1.0$ touch IMyCallback.hal  IMyIntere.hal</span><br><span class="line">// 3. 根目录下执行 update-makefiles.sh 脚本</span><br><span class="line">xmt@server139:~/**/$ ./hardware/interfaces/update-makefiles.sh</span><br></pre></td></tr></table></figure>

<h3 id="hidl-gen-规则"><a href="#hidl-gen-规则" class="headerlink" title="hidl-gen 规则"></a><code>hidl-gen</code> 规则</h3><p><code>hidl-gen</code> 转换规则以及生成哪些文件都是在自动生成的 <code>Android.bp</code> 文件中定义的； <code>hidl, aidl</code> 文件自动生成 <code>java, cpp, h</code> 文件工具源码都是在 <code>system/tools/</code> 目录下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system/tools/</span><br><span class="line">├── aidl</span><br><span class="line">└── hidl</span><br></pre></td></tr></table></figure>

<p>绑定式模式使用 <code>hidl-gen</code> 编译器并以 <code>IFoo.hal</code> 接口文件作为输入，它具有以下自动生成的文件：  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-treble_cpp_compiler_generated_files.png" alt="0110-android-hidl-treble_cpp_compiler_generated_files.png"></p>
<p>由编译器生成的文件：  </p>
<ul>
<li><code>IFoo.h</code><br>描述 <code>C++</code> 类中的纯 <code>IFoo</code> 接口；它包含 <code>IFoo.hal</code> 文件中的 <code>IFoo</code> 接口中所定义的方法和类型，必要时会转换为 <code>C++</code> 类型。不包含与用于实现此接口的 <code>RPC</code> 机制（例如 <code>HwBinder</code>）相关的详细信息。类的命名空间包含软件包名称和版本号，例如 <code>::android::hardware::samples::IFoo::V1_0</code> 。客户端和服务器都包含此标头：客户端用它来调用方法，服务器用它来实现这些方法。  </li>
<li><code>IHwFoo.h</code><br>头文件，其中包含用于对接口中使用的数据类型进行序列化的函数的声明。开发者不得直接包含其标头（它不包含任何类）。  </li>
<li><code>BpFoo.h</code><br>从 <code>IFoo</code> 继承的类，可描述接口的 <code>HwBinder</code> 代理（客户端）实现。开发者不得直接引用此类。  </li>
<li><code>BnFoo.h</code><br>保存对 <code>IFoo</code> 实现的引用的类，可描述接口的 <code>HwBinder</code> 存根 <code>Stub</code> （服务器端）实现。开发者不得直接引用此类。  </li>
<li><code>FooAll.cpp</code><br>包含 <code>HwBinder</code> 代理和 <code>HwBinder</code> 存根 <code>Stub</code> 的实现的类。当客户端调用接口方法时，代理会自动从客户端封送参数，并将事务发送到绑定内核驱动程序，该内核驱动程序会将事务传送到另一端的存根 <code>Stub</code>（该存根随后会调用实际的服务器实现）。  </li>
</ul>
<p>生成的这些文件结构类似于由 <code>aidl-cpp</code> 生成的文件。独立于 <code>HIDL</code> 使用的 <code>RPC</code> 机制的自动生成的文件是 <code>IFoo.h</code> ，其他所有文件都与 <code>HIDL</code> 使用的 <code>HwBinder RPC</code> 机制相关联。因此客户端和服务器实现不得直接引用除 <code>IFoo</code> 之外的任何内容。为了满足这项要求，只包含 <code>IFoo.h</code> 并链接到生成的共享库。  </p>
<p>在直通式模式中，在编译 <code>IFoo.hal</code> 文件时，标头文件除了用于 <code>Binder</code> 通信的标头之外， <code>hidl-gen</code> 还会生成一个额外的直通标头文件 <code>BsFoo.h</code> ；此标头定义了会被执行 <code>dlopen</code> 操作的函数。由于直通式 <code>HAL</code> 在它们被调用的同一进程中运行，因此在大多数情况下，直通方法由直接函数调用（同一线程）来调用。 <code>oneway</code> 方法在各自的线程中运行，因为它们不需要等待 <code>HAL</code> 来处理它们（这意味着，在直通模式下使用 <code>oneway</code> 方法的所有 <code>HAL</code> 对于线程必须是安全的）。 <code>BsFoo.h</code> 文件类似于 <code>BpFoo.h</code> ，不过所需函数是直接调用的，并未使用 <code>Binder</code> 传递调用 <code>IPC</code> 。未来 <code>HAL</code> 的实现可能提供多种实现结果，例如 <code>FooFast HAL</code> 和 <code>FooAccurate HAL</code> 。在这种情况下，系统会针对每个额外的实现结果创建一个文件（例如 <code>PTFooFast.cpp</code> 和 <code>PTFooAccurate.cpp</code> ）。  </p>
<h3 id="hidl-gen-语法"><a href="#hidl-gen-语法" class="headerlink" title="hidl-gen 语法"></a><code>hidl-gen</code> 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">usage: hidl-gen [-p &lt;root path&gt;] -o &lt;output path&gt; -L &lt;language&gt; (-r &lt;interface root&gt;)+ [-t] fqname+</span><br><span class="line">    -h: Prints this menu.</span><br><span class="line">    -L &lt;language&gt;: The following options are available:</span><br><span class="line">       check           : Parses the interface to see if valid but doesn&apos;t write any files.</span><br><span class="line">       c++             : (internal) (deprecated) Generates C++ interface files for talking to HIDL interfaces.</span><br><span class="line">       c++-headers     : (internal) Generates C++ headers for interface files for talking to HIDL interfaces.</span><br><span class="line">       c++-sources     : (internal) Generates C++ sources for interface files for talking to HIDL interfaces.</span><br><span class="line">       export-header   : Generates a header file from @export enumerations to help maintain legacy code.</span><br><span class="line">       c++-impl        : Generates boilerplate implementation of a hidl interface in C++ (for convenience).</span><br><span class="line">       c++-impl-headers: c++-impl but headers only</span><br><span class="line">       c++-impl-sources: c++-impl but sources only</span><br><span class="line">       java            : (internal) Generates Java library for talking to HIDL interfaces in Java.</span><br><span class="line">       java-constants  : (internal) Like export-header but for Java (always created by -Lmakefile if @export exists).</span><br><span class="line">       vts             : (internal) Generates vts proto files for use in vtsd.</span><br><span class="line">       makefile        : (internal) Generates makefiles for -Ljava and -Ljava-constants.</span><br><span class="line">       androidbp       : (internal) Generates Soong bp files for -Lc++-headers and -Lc++-sources.</span><br><span class="line">       androidbp-impl  : Generates boilerplate bp files for implementation created with -Lc++-impl.</span><br><span class="line">       hash            : Prints hashes of interface in `current.txt` format to standard out.</span><br><span class="line">    -o &lt;output path&gt;: Location to output files.</span><br><span class="line">    -p &lt;root path&gt;: Android build root, defaults to $ANDROID_BUILD_TOP or pwd.</span><br><span class="line">    -r &lt;package:path root&gt;: E.g., android.hardware:hardware/interfaces.</span><br><span class="line">    -t: generate build scripts (Android.bp) for tests.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fqName</code> ： 完全限定名  </li>
<li><code>-L</code> ：指定生成的语言包  </li>
<li><code>-r</code> ： <code>hal</code> 文件路径  </li>
</ul>
<h3 id="文件路径映射"><a href="#文件路径映射" class="headerlink" title="文件路径映射"></a>文件路径映射</h3><p>每个 <code>hal</code> 文件都可以通过软件包根目录映射及其完全限定名称找到，软件包根目录以参数 <code>-r android.hardware:hardware/interfaces</code> 的形式指定给 <code>hidl-gen</code> 。例如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hidl-gen -r vendor.awesome:some/device/independent/path/interfaces vendor.awesome.foo@1.0::IFoo</span><br></pre></td></tr></table></figure>

<ul>
<li>根目录参数为 <code>vendor.awesome:some/device/independent/path/interfaces</code><br>表示 <code>vendor.awesome</code> 对应的目录路径为：<br><code>$ANDROID_BUILD_TOP/some/device/independent/path/interfaces</code> 。  </li>
<li>软件包为 <code>vendor.awesome.foo@1.0::IFoo</code><br>表示接口文件应该位于 <code>vendor.awesome</code> 目录路径下的 <code>foo</code> 接口的 <code>1.0</code> 版本下的 <code>IFoo.hal</code> 文件，即：<br><code>$ANDROID_BUILD_TOP/some/device/independent/path/interfaces/foo/1.0/IFoo.hal</code> 。  </li>
</ul>
<p>软件包路径映射不得重复，比如如果同时存在 <code>-rsome.package:$PATH_A</code> 和 <code>-rsome.package:$PATH_B</code> ，则 <code>$PATH_A</code> 必须等于 <code>$PATH_B</code> 才能实现一致的接口目录（这也能让接口版本控制起来更简单）。  </p>
<h3 id="代码文件生成"><a href="#代码文件生成" class="headerlink" title="代码文件生成"></a>代码文件生成</h3><ul>
<li><p>定义 <code>hal</code> 文件组  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filegroup &#123;</span><br><span class="line">    name: &quot;android.hardware.camera.provider@2.4_hal&quot;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;ICameraProvider.hal&quot;,</span><br><span class="line">        &quot;ICameraProviderCallback.hal&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成头文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// hardware/interfaces/camera/provider/2.4/Android.bp</span><br><span class="line">genrule &#123;</span><br><span class="line">    name: &quot;android.hardware.camera.provider@2.4_genc++_headers&quot;,</span><br><span class="line">    tools: [&quot;hidl-gen&quot;],</span><br><span class="line">    cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;:android.hardware.camera.provider@2.4_hal&quot;,    // hal 文件组</span><br><span class="line">    ],</span><br><span class="line">    out: [</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/ICameraProvider.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/IHwCameraProvider.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BnHwCameraProvider.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BpHwCameraProvider.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BsCameraProvider.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/ICameraProviderCallback.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/IHwCameraProviderCallback.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BnHwCameraProviderCallback.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BpHwCameraProviderCallback.h&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/BsCameraProviderCallback.h&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 <code>CPP</code> 文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// hardware/interfaces/camera/provider/2.4/Android.bp</span><br><span class="line">genrule &#123;</span><br><span class="line">    name: &quot;android.hardware.camera.provider@2.4_genc++&quot;,</span><br><span class="line">    tools: [&quot;hidl-gen&quot;],</span><br><span class="line">    cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-sources -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;:android.hardware.camera.provider@2.4_hal&quot;,    // hal 文件组</span><br><span class="line">    ],</span><br><span class="line">    out: [</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/CameraProviderAll.cpp&quot;,</span><br><span class="line">        &quot;android/hardware/camera/provider/2.4/CameraProviderCallbackAll.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="HIDL-服务新增函数"><a href="#HIDL-服务新增函数" class="headerlink" title="HIDL 服务新增函数"></a><code>HIDL</code> 服务新增函数</h3><p><code>HIDL</code> 服务在代码自动生成，每个服务对应的头文件中，比如 <code>IFoo.h</code> 都会自动添加如下几个函数：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务</span></span><br><span class="line"><span class="keyword">static</span> ::android::sp&lt;IFoo&gt; getService(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">"default"</span>, <span class="keyword">bool</span> getStub=<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">::android::<span class="keyword">status_t</span> registerAsService(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">"default"</span>);</span><br><span class="line"><span class="comment">// 服务注册成功后的通知</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">registerForNotifications</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> ::android::sp&lt;IServiceNotification&gt; &amp;notification)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getService</code> ：获取服务  </li>
<li><code>registerAsService</code> ：注册服务  </li>
<li><code>registerForNotifications</code> ：注册通知监听事件，服务注册成功后会发出通知   </li>
</ul>
<h2 id="服务注册与获取"><a href="#服务注册与获取" class="headerlink" title="服务注册与获取"></a>服务注册与获取</h2><h3 id="服务端注册-Binder-服务"><a href="#服务端注册-Binder-服务" class="headerlink" title="服务端注册 Binder 服务"></a>服务端注册 <code>Binder</code> 服务</h3><p><code>HIDL</code> 接口使用 <code>IInterface::registerAsService</code> 来注册 <code>Binder</code> 服务，注册的名称不需要与接口或软件包名称相关。如果没有指定名称，则默认为 <code>default</code> ； <code>HIDL</code> 接口调用 <code>android::hardware::IInterface::getInterfaceVersion</code> 可以查看当前接口的版本。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IFoo&gt; myFoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">status_t</span> status = myFoo-&gt;registerAsService();               <span class="comment">// 默认值为 "default"</span></span><br><span class="line">sp&lt;IFoo&gt; anotherFoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">status_t</span> anotherStatus = </span><br><span class="line">    anotherFoo-&gt;registerAsService(<span class="string">"another_foo_service"</span>);   <span class="comment">// 显示指定服务名称</span></span><br></pre></td></tr></table></figure>

<h3 id="Binder-化直通式"><a href="#Binder-化直通式" class="headerlink" title="Binder 化直通式"></a><code>Binder</code> 化直通式</h3><p>首先要理解 <code>Binder</code> 化直通式 <code>HAL</code> ，指的是 <code>HAL</code> 服务端注册的方式：以直通的方式加载服务端，并向 <code>hwservicemanager</code> 注册该服务；通过函数 <code>defaultPassthroughServiceImplementation&lt;IFoo&gt;</code> 来注册：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaultPassthroughServiceImplementation&lt;ICameraProvider&gt;(</span><br><span class="line">    <span class="string">"legacy/0"</span>, <span class="comment">/*maxThreads*/</span> <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>下面是源码分析：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LegacySupport.h</span></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers passthrough service implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">"default"</span>) &#123;</span><br><span class="line">    <span class="comment">// 直通式加载服务端</span></span><br><span class="line">    sp&lt;Interface&gt; service = </span><br><span class="line">        Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(...);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_FATAL_IF(...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 hwservicemanager 注册服务</span></span><br><span class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == OK) &#123;</span><br><span class="line">        ALOGI(...);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">std</span>:</span>:<span class="built_in">string</span> name,</span><br><span class="line">                                            <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = </span><br><span class="line">        registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(</span><br><span class="line">        <span class="string">"default"</span>, maxThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registerPassthroughServiceImplementation</code> 函数中，在 <code>getService</code> 时，参数 <code>getStub</code> 为 <code>ture</code> ，即通过直通式加载服务端；拿到直通式服务端 <code>Interface</code> 后，又通过 <code>registerAsService</code> 向 <code>hwservicemanager</code> 注册该服务。<br>即加载服务端的当前进程，作为服务进程；客户端从 <code>hwservicemanager</code> 可以查到服务端，并通过 <code>Binder</code> 和服务进程通信。  </p>
<h3 id="客户端获取服务"><a href="#客户端获取服务" class="headerlink" title="客户端获取服务"></a>客户端获取服务</h3><p><code>HIDL</code> 接口因为有版本区分，所以每个接口文件都可以被认为是单独的、唯一的。因此 <code>IFooService</code> 版本 1.1 和 <code>IFooService</code> 版本 2.2 都可以注册为 <code>foo_service</code> ，并且两个接口上的 <code>getService(&quot;foo_service&quot;)</code> 都可获取该接口的已注册服务。因此在大多数情况下，注册或发现服务均无需提供名称参数（也就是说名称为 <code>default</code> ）。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line">sp&lt;V1_1::IFooService&gt; service = V1_1::IFooService::getService();</span><br><span class="line">sp&lt;V1_1::IFooService&gt; alternateService = </span><br><span class="line">    V1_1::IFooService::getService(&quot;another_foo_service&quot;);</span><br><span class="line">// Java</span><br><span class="line">V1_1.IFooService service = V1_1.IFooService.getService(true /* retry */);</span><br><span class="line">V1_1.IFooService alternateService = </span><br><span class="line">    V1_1.IFooService.getService(&quot;another&quot;, true /* retry */);</span><br></pre></td></tr></table></figure>

<p>客户端通过 <code>getService</code> 来获取服务端，而 <code>getService</code> 是每个 <code>.hal</code> 文件在自动生成源码时，都会自动添加的函数，函数原型为（这里以 <code>IServiceManager.hal</code> 为例）：<br><code>static ::android::sp&lt;IServiceManager&gt; getService(const std::string &amp;serviceName=&quot;default&quot;, bool getStub=false);</code><br>除了 <code>&lt;&gt;</code> 里的接口文件类型不一样，所有的 <code>.hal</code> 文件都会生成同样的代码；而它的实现则是在对应的 <code>.cpp</code> 文件中：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManagerAll.cpp</span></span><br><span class="line">::android::sp&lt;IServiceManager&gt; IServiceManager::getService(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sp&lt;IServiceManager&gt; iface = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 获取绑定式 IServiceManager</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"getService: defaultServiceManager() is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; </span><br><span class="line">            (vintfHwbinder || (vintfLegacy &amp;&amp; tries == <span class="number">0</span>)); tries++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过绑定式 IServiceManager 获取服务端</span></span><br><span class="line">        Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret =</span><br><span class="line">                sm-&gt;get(IServiceManager::descriptor, serviceName);</span><br><span class="line">        ...</span><br><span class="line">        sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 强制转换为服务端对应类型，这里以 IServiceManager 为例</span></span><br><span class="line">        Return&lt;sp&lt;IServiceManager&gt;&gt; castRet = </span><br><span class="line">            IServiceManager::castFrom(base, <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line">        ...</span><br><span class="line">        iface = castRet;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> iface;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="comment">// 获取直通式 IServiceManager</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过直通式 IServiceManager 获取服务端</span></span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret =</span><br><span class="line">                    pm-&gt;get(IServiceManager::descriptor, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 强制转换为服务端对应类型，这里以 IServiceManager 为例</span></span><br><span class="line">                    iface = IServiceManager::castFrom(baseInterface);</span><br><span class="line">                    <span class="comment">// 直通模式中如果 getStub 为 false，返回的是 BsServiceManager</span></span><br><span class="line">                    <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = <span class="keyword">new</span> BsServiceManager(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getService</code> 主要是根据参数 <code>getStub</code> 的值来决定采用哪种方式获取服务端：  </p>
<ul>
<li>为 <code>false</code> 时<br>通过 <code>defaultServiceManager</code> 获取服务端，即<strong>绑定式</strong>。  </li>
<li>为 <code>true</code> 时<br>通过 <code>getPassthroughServiceManager</code> 获取服务端，即<strong>直通式</strong>。  </li>
</ul>
<p>这两个函数下面会详细介绍。  </p>
<h3 id="服务死亡通知"><a href="#服务死亡通知" class="headerlink" title="服务死亡通知"></a>服务死亡通知</h3><p>客户端需要注册服务终止通知接收器，当服务终止时，客户端收到通知；接收器需要继承 <code>hidl_death_recipient</code> 子类，并实现对应的方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class IMyDeathReceiver : hidl_death_recipient &#123;</span><br><span class="line">  virtual void serviceDied(uint64_t cookie,</span><br><span class="line">                           wp&lt;IBase&gt;&amp; service) override &#123;</span><br><span class="line">    log(&quot;RIP service %d!&quot;, cookie);  // Cookie should be 42</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">....</span><br><span class="line">IMyDeathReceiver deathReceiver = new IMyDeathReceiver();</span><br><span class="line">m_importantService-&gt;linkToDeath(deathReceiver, 42);</span><br></pre></td></tr></table></figure>

<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><h3 id="源码目录速查表"><a href="#源码目录速查表" class="headerlink" title="源码目录速查表"></a>源码目录速查表</h3><p>实现源码路径为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system/libhidl</span><br><span class="line">system/libhwbinder</span><br><span class="line">system/hwservicemanager</span><br></pre></td></tr></table></figure>

<h3 id="libhidl"><a href="#libhidl" class="headerlink" title="libhidl"></a><code>libhidl</code></h3><p>主要包含三个动态库： <code>libhidlbase, libhidltransport, libhidlmemory</code> ；其中 <code>libhidlbase</code> 主要是 <code>hidl</code> 的基本类型相关； <code>libhidlmemory</code> 是封装了 <code>memory</code> 通过 <code>IMapper</code> 来映射；<code>libhidltransport</code> 包含直通式 <code>IServiceManager.hal</code> 的实现。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">libhidl/</span><br><span class="line">├── base</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   ├── HidlInternal.cpp</span><br><span class="line">│   ├── HidlSupport.cpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   ├── Status.cpp</span><br><span class="line">│   └── TaskRunner.cpp</span><br><span class="line">├── libhidlmemory</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   ├── include</span><br><span class="line">│   └── mapping.cpp</span><br><span class="line">├── transport</span><br><span class="line">│   ├── allocator</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   ├── base</span><br><span class="line">│   ├── current.txt</span><br><span class="line">│   ├── HidlBinderSupport.cpp</span><br><span class="line">│   ├── HidlTransportSupport.cpp</span><br><span class="line">│   ├── HidlTransportUtils.cpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   ├── manager</span><br><span class="line">│   ├── memory</span><br><span class="line">│   ├── ServiceManagement.cpp</span><br><span class="line">│   ├── Static.cpp</span><br><span class="line">│   └── token</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>

<h3 id="libhwbinder"><a href="#libhwbinder" class="headerlink" title="libhwbinder"></a><code>libhwbinder</code></h3><p>对应生成 <code>libhwbinder</code> 库，是 <code>.hal</code> 文件 <code>Binder</code> 通信相关库。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">libhwbinder/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── Binder.cpp</span><br><span class="line">├── BpHwBinder.cpp</span><br><span class="line">├── BufferedTextOutput.cpp</span><br><span class="line">├── Debug.cpp</span><br><span class="line">├── IInterface.cpp</span><br><span class="line">├── include</span><br><span class="line">│   └── hwbinder</span><br><span class="line">├── IPCThreadState.cpp</span><br><span class="line">├── MODULE_LICENSE_APACHE2</span><br><span class="line">├── NOTICE</span><br><span class="line">├── OWNERS</span><br><span class="line">├── Parcel.cpp</span><br><span class="line">├── PREUPLOAD.cfg</span><br><span class="line">├── ProcessState.cpp</span><br><span class="line">├── Static.cpp</span><br><span class="line">├── TextOutput.cpp</span><br><span class="line">└── vts</span><br><span class="line">    ├── OWNERS</span><br><span class="line">    └── performance</span><br></pre></td></tr></table></figure>

<h3 id="hwservicemanager"><a href="#hwservicemanager" class="headerlink" title="hwservicemanager"></a><code>hwservicemanager</code></h3><p>生成可执行文件 <code>hwservicemanager</code> ，是 <code>HIDL</code> 绑定式服务的大管家。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hwservicemanager/</span><br><span class="line">├── AccessControl.cpp</span><br><span class="line">├── AccessControl.h</span><br><span class="line">├── Android.bp</span><br><span class="line">├── HidlService.cpp</span><br><span class="line">├── HidlService.h</span><br><span class="line">├── hwservicemanager.rc</span><br><span class="line">├── hwservicemanagerTest.cpp</span><br><span class="line">├── MODULE_LICENSE_APACHE2</span><br><span class="line">├── NOTICE</span><br><span class="line">├── OWNERS</span><br><span class="line">├── service.cpp</span><br><span class="line">├── ServiceManager.cpp</span><br><span class="line">├── ServiceManager.h</span><br><span class="line">├── TokenManager.cpp</span><br><span class="line">├── TokenManager.h</span><br><span class="line">├── Vintf.cpp</span><br><span class="line">└── Vintf.h</span><br></pre></td></tr></table></figure>

<h2 id="libhidl-目录"><a href="#libhidl-目录" class="headerlink" title="libhidl 目录"></a><code>libhidl</code> 目录</h2><h3 id="libhidlbase-库"><a href="#libhidlbase-库" class="headerlink" title="libhidlbase 库"></a><code>libhidlbase</code> 库</h3><p><code>libhidlbase</code> 库对应的源码列表如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">base/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── HidlInternal.cpp</span><br><span class="line">├── HidlSupport.cpp</span><br><span class="line">├── include</span><br><span class="line">│   └── hidl</span><br><span class="line">│       ├── HidlInternal.h</span><br><span class="line">│       ├── HidlSupport.h</span><br><span class="line">│       ├── MQDescriptor.h</span><br><span class="line">│       ├── Status.h</span><br><span class="line">│       ├── SynchronizedQueue.h</span><br><span class="line">│       └── TaskRunner.h</span><br><span class="line">├── Status.cpp</span><br><span class="line">└── TaskRunner.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HidlInternal</code><br><code>hidl</code> 内部使用的一些类、字符串定义等等。 <code>hal</code> 客户端/服务端都不会使用。  </li>
<li><code>HidlSupport</code><br><code>hidl</code> 支持的基本数据类型（不包含 <code>C++, Java</code> 类型）。  </li>
<li><code>MQDescripto</code><br>快速消息队列 <code>fmq</code> 中相关类型。  </li>
<li><code>Status</code><br>表示 <code>hidl</code> 通信的状态和返回值，比如成功、失败、异常等等。  </li>
<li><code>SynchronizedQueue</code><br>同步队列。  </li>
<li><code>TaskRunner</code><br>后台无限循环的任务，使用 <code>SynchronizedQueue</code> 队列保存任务。  </li>
</ul>
<h3 id="libhidlmemory-库"><a href="#libhidlmemory-库" class="headerlink" title="libhidlmemory 库"></a><code>libhidlmemory</code> 库</h3><p><code>libhidlmemory</code> 库对应的源码列表如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libhidlmemory/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── include</span><br><span class="line">│   └── hidlmemory</span><br><span class="line">│       └── mapping.h</span><br><span class="line">└── mapping.cpp</span><br></pre></td></tr></table></figure>

<p>就一个有效文件 <code>mapping</code> ，对应头文件：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapping.h</span></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the IMemory instance corresponding to a hidl_memory object.</span></span><br><span class="line"><span class="comment"> * If the shared memory cannot be fetched, this returns nullptr.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sp&lt;android::hidl::memory::V1_0::IMemory&gt; mapMemory(</span><br><span class="line">    <span class="keyword">const</span> hidl_memory &amp;memory);</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace hardware</span></span><br><span class="line">&#125;  <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>

<p>只包含一个功能函数：将 <code>hidl_memory</code> 内存映射后，返回对应的 <code>IMemory</code> 。 <code>libhidlmemory</code> 库是对 <code>system/libhidl/transport/memory</code> 的封装，而 <code>transport/memory</code> 则是具体的实现。  </p>
<h3 id="android-hidl-软件包"><a href="#android-hidl-软件包" class="headerlink" title="android.hidl.* 软件包"></a><code>android.hidl.*</code> 软件包</h3><p><code>system/libhidl/transport/*</code> 目录下包含 5 个软件包，这些软件包以 <code>android.hidl.*</code> 开头，它们是 <code>hidl</code> 的基础软件包：  </p>
<ul>
<li><code>base</code><br>定义了 <code>IBase.hal</code> ，它的功能类似 <code>Java Object</code> ，也就是说 <code>Ibase.hal</code> 是所有 <code>hal</code> 文件的父类。每个 <code>hal</code> 文件在自动生成源码时，都会自动添加 <code>IBase</code> 中的函数及其默认实现。  </li>
<li><code>allocator</code><br>定义了内存分配接口 <code>IAllocator.hal</code> ，内存分配的具体实现为 <code>AshmemAllocator</code> 。  </li>
<li><code>memory</code><br>定义了内存映射接口 <code>IMapper.hal</code> 以及内存接口 <code>IMemory.hal</code> ；而内存映射的具体实现为 <code>AshmemMapper</code> ，内存块 <code>IMemory</code> 的具体实现为 <code>AshmemMemory</code> 。  </li>
<li><code>manager</code><br>定义了 <code>IServiceManager.hal</code> 相关功能接口；它有两个实现：直通式是在 <code>system/libhidl/ServiceManagement.cpp</code> 中实现的，对应 <code>libhidltransport</code> 库；绑定式是在 <code>system/hwservicemanager/ServiceManager.cpp</code> 中实现的，对应 <code>hwservicemanager</code> 可执行文件。  </li>
<li><code>token</code><br>定义了接口 <code>ITokenManager.hal</code> ，它可以将 <code>hidl</code> 接口转换为 <code>token</code> 方便跨进程传输；该接口是在 <code>hwservicemanager</code> 中实现的。  </li>
</ul>
<blockquote>
<p><code>hidl</code> 相关的内存分配和映射，都是使用的匿名共享内存机制 <code>Ashmem</code> ； <code>IServiceManager</code> 服务管理分为直通式和绑定式，是在不同文件中实现的。  </p>
</blockquote>
<p><code>IBase</code> 文件路径为 <code>system/libhidl/transport/base/1.0/IBase.hal</code> ，是所有 <code>hal</code> 的基础接口，类似 <code>Java</code> 中的 <code>Object</code> 类；因为 <code>hidl</code> 中不存在重写和重载，所以自定义的 <code>hal</code> 文件中函数名不能和下面的重复：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package android.hidl.base@1.0;</span><br><span class="line"></span><br><span class="line">interface IBase &#123;</span><br><span class="line"></span><br><span class="line">    // 测试服务是否正在运行</span><br><span class="line">    ping();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Provides run-time type information for this object.</span><br><span class="line">     * For example, for the following interface definition:</span><br><span class="line">     *     package android.hardware.foo@1.0;</span><br><span class="line">     *     interface IParent &#123;&#125;;</span><br><span class="line">     *     interface IChild extends IParent &#123;&#125;;</span><br><span class="line">     * return:interfaceChain on an IChild object must yield the following</span><br><span class="line">     *     [&quot;android.hardware.foo@1.0::IChild&quot;,</span><br><span class="line">     *      &quot;android.hardware.foo@1.0::IParent&quot;</span><br><span class="line">     *      &quot;android.hidl.base@1.0::IBase&quot;]</span><br><span class="line">     */</span><br><span class="line">    interfaceChain() generates (vec&lt;string&gt; descriptors);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Provides run-time type information for this object.</span><br><span class="line">     * For example, for the following interface definition:</span><br><span class="line">     *     package android.hardware.foo@1.0;</span><br><span class="line">     *     interface IParent &#123;&#125;;</span><br><span class="line">     *     interface IChild extends IParent &#123;&#125;;</span><br><span class="line">     * Calling interfaceDescriptor on an IChild object must yield</span><br><span class="line">     *     &quot;android.hardware.foo@1.0::IChild&quot;</span><br><span class="line">     *</span><br><span class="line">     * @return descriptor a descriptor of the run-time type of the</span><br><span class="line">     *         object (the first element of the vector returned by</span><br><span class="line">     *         interfaceChain())</span><br><span class="line">     */</span><br><span class="line">    interfaceDescriptor() generates (string descriptor);</span><br><span class="line"></span><br><span class="line">    oneway notifySyspropsChanged();</span><br><span class="line">    linkToDeath(death_recipient recipient, uint64_t cookie) </span><br><span class="line">        generates (bool success);</span><br><span class="line">    unlinkToDeath(death_recipient recipient) </span><br><span class="line">        generates (bool success);</span><br><span class="line">    oneway setHALInstrumentation();</span><br><span class="line">    getDebugInfo() generates (DebugInfo info);</span><br><span class="line">    debug(handle fd, vec&lt;string&gt; options);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * For example, for the following interface definition:</span><br><span class="line">     *     package android.hardware.foo@1.0;</span><br><span class="line">     *     interface IParent &#123;&#125;;</span><br><span class="line">     *     interface IChild extends IParent &#123;&#125;;</span><br><span class="line">     * return:interfaceChain on an IChild object must yield the following</span><br><span class="line">     *     [(hash of IChild.hal),</span><br><span class="line">     *      (hash of IParent.hal)</span><br><span class="line">     *      (hash of IBase.hal)].</span><br><span class="line">     *</span><br><span class="line">     * SHA-256 is used as the hashing algorithm. Each hash has 32 bytes</span><br><span class="line">     * according to SHA-256 standard.</span><br><span class="line">     *</span><br><span class="line">     * @return hashchain a vector of SHA-1 digests</span><br><span class="line">     */</span><br><span class="line">    getHashChain() generates (vec&lt;uint8_t[32]&gt; hashchain);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="libhidltransport-库"><a href="#libhidltransport-库" class="headerlink" title="libhidltransport 库"></a><code>libhidltransport</code> 库</h3><p><code>libhidltransport</code> 库中的头文件 <code>#include &lt;hidl/ServiceManagement.h&gt;</code> ，包含了几组重要函数，用来区分当前是客户端采用绑定式还是直通式来获取服务端：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManagement.h</span></span><br><span class="line"><span class="comment">// These functions are for internal use by hidl. If you want to get ahold</span></span><br><span class="line"><span class="comment">// of an interface, the best way to do this is by calling IFoo::getService()</span></span><br><span class="line">sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; defaultServiceManager();</span><br><span class="line">sp&lt;::android::hidl::manager::V1_1::IServiceManager&gt; defaultServiceManager1_1();</span><br><span class="line">sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; getPassthroughServiceManager();</span><br><span class="line">sp&lt;::android::hidl::manager::V1_1::IServiceManager&gt; getPassthroughServiceManager1_1();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>defaultServiceManager</code> ：绑定式服务管理 <code>IServiceManager</code>  </li>
<li><code>getPassthroughServiceManager</code> ：直通式服务管理 <code>IServiceManager</code>  </li>
</ul>
<p>它们都是在 <code>ServiceManagement.cpp</code> 中实现的，先看绑定式源码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManagement.cpp</span></span><br><span class="line">sp&lt;IServiceManager1_0&gt; defaultServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IServiceManager1_1&gt; defaultServiceManager1_1() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(details::gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (details::gDefaultServiceManager != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access(<span class="string">"/dev/hwbinder"</span>, F_OK|R_OK|W_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// HwBinder not available on this device or not accessible to</span></span><br><span class="line">            <span class="comment">// this process.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForHwServiceManager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            details::gDefaultServiceManager =</span><br><span class="line">                fromBinder&lt;IServiceManager1_1, BpHwServiceManager, </span><br><span class="line">                        BnHwServiceManager&gt;(</span><br><span class="line">                    ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的核心代码是 <code>fromBinder</code> 这个模板函数，这里需要注意 <code>ProcessState::self()-&gt;getContextObject(NULL)</code> 这句代码的含义是：获取 <code>handle</code> 为 0 的 <code>IBinder</code> ，而 <code>handle</code> 为 0 表示是 <code>hwservicemanager</code> 守护进程，后续在 <code>hwservicemanager</code> 进程中做详细介绍。这里 <code>ProcessState, IPCThreadState</code> 等，虽然都是在 <code>libhwbinder</code> 库中，实际上和 <code>Framework Binder</code> 中代码很多都是相同，实现的功能也大致相同。<br><code>fromBinder</code> 是在 <code>HidlBinderSupport.h</code> 头文件中定义的：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HidlBinderSupport.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IType, <span class="keyword">typename</span> ProxyType, <span class="keyword">typename</span> StubType&gt;</span><br><span class="line">sp&lt;IType&gt; fromBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binderIface) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::BnHwBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binderIface.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binderIface-&gt;localBinder() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyType(binderIface);</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="keyword">static_cast</span>&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</span><br><span class="line">    <span class="keyword">if</span> (details::canCastInterface(base.get(), IType::descriptor)) &#123;</span><br><span class="line">        StubType* stub = <span class="keyword">static_cast</span>&lt;StubType*&gt;(binderIface.get());</span><br><span class="line">        <span class="keyword">return</span> stub-&gt;getImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板代码表示，如果是远程访问，则新建代理对象即 <code>BpHwServiceManager</code> ，即客户端持有服务端的代理；如果是本地调用，则直接转换为 <code>BnHwServiceManager</code> ，换句话说这里客户端就是服务端自己。<br>当是远程访问时，实际的 <code>IServiceManager</code> 是由 <code>hwservicemanager</code> 进程中 <code>ServiceManager</code> 实现的。  </p>
<p>再看直通式源码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManagement.cpp</span></span><br><span class="line">sp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> getPassthroughServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123;</span><br><span class="line">    <span class="keyword">static</span> sp&lt;PassthroughServiceManager&gt; manager(</span><br><span class="line">        <span class="keyword">new</span> PassthroughServiceManager());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直通模式获取服务端时，直接返回的 <code>PassthroughServiceManager</code> 对象，通过它获取服务端 <code>get</code> 方法源码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">struct PassthroughServiceManager : IServiceManager1_1 &#123;</span><br><span class="line"></span><br><span class="line">    static void openLibs(</span><br><span class="line">        const std::string&amp; fqName,</span><br><span class="line">        std::function&lt;bool /* continue */</span><br><span class="line">            (void* /* handle */, const std::string&amp; /* lib */, </span><br><span class="line">                const std::string&amp; /* sym */)&gt; eachLib) &#123;</span><br><span class="line">        //fqName looks like android.hardware.foo@1.0::IFoo</span><br><span class="line">        size_t idx = fqName.find(&quot;::&quot;);</span><br><span class="line">        ...</span><br><span class="line">        std::string packageAndVersion = fqName.substr(0, idx);</span><br><span class="line">        std::string ifaceName = fqName.substr(idx + strlen(&quot;::&quot;));</span><br><span class="line">        const std::string prefix = packageAndVersion + &quot;-impl&quot;;</span><br><span class="line">        // hardcode 服务端必须包含一个 HIDL_FETCH_ 开头的函数</span><br><span class="line">        const std::string sym = &quot;HIDL_FETCH_&quot; + ifaceName;</span><br><span class="line">        const int dlMode = RTLD_LAZY;</span><br><span class="line">        void *handle = nullptr;</span><br><span class="line">        ...</span><br><span class="line">        std::vector&lt;std::string&gt; paths = </span><br><span class="line">            &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR,</span><br><span class="line">             HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;;</span><br><span class="line">        ...</span><br><span class="line">        for (const std::string&amp; path : paths) &#123;</span><br><span class="line">            std::vector&lt;std::string&gt; libs = search(path, prefix, &quot;.so&quot;);</span><br><span class="line"></span><br><span class="line">            for (const std::string &amp;lib : libs) &#123;</span><br><span class="line">                const std::string fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                // 找到库文件，打开后返回句柄</span><br><span class="line">                if (path != HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = android_load_sphal_library(</span><br><span class="line">                        fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125;</span><br><span class="line">                // 没有找到则继续循环查找</span><br><span class="line">                if (handle == nullptr) &#123;</span><br><span class="line">                    const char* error = dlerror();</span><br><span class="line">                    LOG(ERROR)...;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 回调传入的函数</span><br><span class="line">                if (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Return&lt;sp&lt;IBase&gt;&gt; get(const hidl_string&amp; fqName,</span><br><span class="line">                          const hidl_string&amp; name) override &#123;</span><br><span class="line">        sp&lt;IBase&gt; ret = nullptr;</span><br><span class="line"></span><br><span class="line">        openLibs(fqName, [&amp;](void* handle, </span><br><span class="line">            const std::string &amp;lib, const std::string &amp;sym) &#123;</span><br><span class="line">            IBase* (*generator)(const char* name);</span><br><span class="line">            *(void **)(&amp;generator) = dlsym(handle, sym.c_str());</span><br><span class="line">            if(!generator) &#123;</span><br><span class="line">                const char* error = dlerror();</span><br><span class="line">                LOG(ERROR)...;</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = (*generator)(name.c_str());</span><br><span class="line"></span><br><span class="line">            if (ret == nullptr) &#123;</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                return true; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            registerReference(fqName, name);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>openLibs</code> 首先根据全限定名解析出版本号，以及 <code>.hal</code> 接口名称，再查找其实现库即 <code>IFoo-impl.so</code> 库，查找路径为 <code>HAL_LIBRARY_PATH_SYSTEM</code> 等等，它们的定义如下：  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HidlInternal.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_SYSTEM_64BIT <span class="meta-string">"/system/lib64/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VNDK_SP_64BIT <span class="meta-string">"/system/lib64/vndk-sp/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VENDOR_64BIT <span class="meta-string">"/vendor/lib64/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_ODM_64BIT    <span class="meta-string">"/odm/lib64/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_SYSTEM_32BIT <span class="meta-string">"/system/lib/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VNDK_SP_32BIT <span class="meta-string">"/system/lib/vndk-sp/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VENDOR_32BIT <span class="meta-string">"/vendor/lib/hw/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_ODM_32BIT    <span class="meta-string">"/odm/lib/hw/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_SYSTEM HAL_LIBRARY_PATH_SYSTEM_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VNDK_SP HAL_LIBRARY_PATH_VNDK_SP_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VENDOR HAL_LIBRARY_PATH_VENDOR_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_ODM    HAL_LIBRARY_PATH_ODM_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_SYSTEM HAL_LIBRARY_PATH_SYSTEM_32BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VNDK_SP HAL_LIBRARY_PATH_VNDK_SP_32BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_VENDOR HAL_LIBRARY_PATH_VENDOR_32BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH_ODM    HAL_LIBRARY_PATH_ODM_32BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说在这些路径中搜索 <code>IFoo-impl.so</code> 库文件，直到找到为止。  </p>
<blockquote>
<p><code>IFoo.hal</code> 的实现文件 <code>Foo.cpp</code> 中，必须包含 <code>HIDL_FETCH_IFoo</code> 的函数，这个是在 <code>openLibs</code> 中代码写死的。通常在 <code>HIDL_FETCH_IFoo</code> 中， <code>new Foo()</code> 来新建 <code>Foo</code> 对象。  </p>
</blockquote>
<p>直通式中获取服务端的流程：先通过 <code>openLibs</code> 加载实现库 <code>IFoo-impl.so</code> ，再调用 <code>HIDL_FETCH_IFoo</code> 方法，得到 <code>Foo</code> 对象（即服务端）。<br>也就是说，直通式 <code>Passthrough HAL</code> 中客户端直接将服务端的代码库加载到当前进程中，这也是 <code>Treble</code> 架构中对老版本 <code>HAL</code> 的兼容：在 <code>HIDL</code> 之前， <code>HAL</code> 都是通过 <code>dlopen</code> 来直接加载的。  </p>
<h2 id="libhwbinder-目录"><a href="#libhwbinder-目录" class="headerlink" title="libhwbinder 目录"></a><code>libhwbinder</code> 目录</h2><p><code>libhwbinder</code> 库目录，主要是实现了 <code>hwbinder</code> 通信，它的实现方式绝大部分都和 <code>Framework Binder</code> 中一致，参考<a href="https://redspider110.github.io/2017/12/21/0041-android-binder/">Android Binder 机制</a> 。<br><code>libhwbinder</code> 目录的代码基本是从 <code>Framework Binder</code> 代码拷贝过来，修改了部分 <code>Bp, Bn Binder</code> 的名称，以及 <code>/dev/hwbinder</code> 驱动设备文件。  </p>
<h3 id="hwBinder-类图结构"><a href="#hwBinder-类图结构" class="headerlink" title="hwBinder 类图结构"></a><code>hwBinder</code> 类图结构</h3><p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-hwbinder.png" alt="0110-android-hidl-class-uml-hwbinder.png"></p>
<ul>
<li><code>BpHwRefBase</code> 中的 <code>mRemote</code> 指向了 <code>BpHwBinder</code>  </li>
<li><code>BpHwBinder</code> 中的 <code>mHandle</code> 是一个句柄，指向 <code>BHwBinder</code> ，它们两个之间通过 <code>Binder Driver</code> 来通信  </li>
</ul>
<h3 id="IBase-类图结构"><a href="#IBase-类图结构" class="headerlink" title="IBase 类图结构"></a><code>IBase</code> 类图结构</h3><p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-IBase.png" alt="0110-android-hidl-class-uml-IBase.png"></p>
<p><code>IBase</code> 是所有 <code>HIDL</code> 服务的基类， <code>BnHwBase</code> 中的 <code>_hidl_mImpl</code> 指向了 <code>HIDL</code> 服务的具体实现类。  </p>
<h3 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a><code>ProcessState</code></h3><p>这里主要介绍 <code>ProcessState</code> 中两个函数：构造函数和 <code>getContextObject</code>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大约 1 M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 0        <span class="comment">// 默认最大线程数为 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开驱动文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/hwbinder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 设置默认最大线程数</span></span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"...);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        ALOGW(...);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return fd;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ProcessState::ProcessState()</span></span><br><span class="line"><span class="string">    : mDriverFD(open_driver())</span></span><br><span class="line"><span class="string">    , mVMStart(MAP_FAILED)</span></span><br><span class="line"><span class="string">    , ...</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    if (mDriverFD &gt;= 0) &#123;</span></span><br><span class="line"><span class="string">        // mmap the binder, providing a chunk of virtual </span></span><br><span class="line"><span class="string">        // address space to receive transactions.</span></span><br><span class="line"><span class="string">        // 映射内存空间</span></span><br><span class="line"><span class="string">        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, </span></span><br><span class="line"><span class="string">            MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span></span><br><span class="line"><span class="string">        if (mVMStart == MAP_FAILED) &#123;</span></span><br><span class="line"><span class="string">            // *sigh*</span></span><br><span class="line"><span class="string">            ALOGE("</span>Using /dev/hwbinder failed...\n<span class="string">");</span></span><br><span class="line"><span class="string">            close(mDriverFD);</span></span><br><span class="line"><span class="string">            mDriverFD = -1;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">        ALOGE("</span>...<span class="string">");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>ProcessState</code> 构造函数中实现了如下功能：  </p>
<ul>
<li>打开 <code>/dev/hwbinder</code> 设备，该文件节点和 <code>Binder</code> 通信  </li>
<li>初始配置驱动的最大线程数为 0 ，后续可以通过 <code>setThreadPoolConfiguration</code> 来修改  </li>
<li><code>mmap</code> 映射内存空间，大概 <code>1MB</code>  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpHwBinder if there isn't currently </span></span><br><span class="line">        <span class="comment">// one, OR we are unable to acquire a weak reference on this </span></span><br><span class="line">        <span class="comment">// current one.  See comment in getWeakProxyForHandle() </span></span><br><span class="line">        <span class="comment">// for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpHwBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a </span></span><br><span class="line">            <span class="comment">// primary reference to the remote proxy when this </span></span><br><span class="line">            <span class="comment">// team doesn't have one but another team is </span></span><br><span class="line">            <span class="comment">// sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getContextObject</code> 函数中调用 <code>getStrongProxyForHandle(0)</code> ，即返回句柄为 0 的代理，而句柄为 0 表示是服务大管家，后面 <code>hwservicemanager</code> 中会详细介绍。<br>当查到句柄存在时，新建 <code>BpHwBinder</code> ，它是所有 <code>Bp***Binder</code> 的父类。  </p>
<h2 id="hwservicemanager-进程"><a href="#hwservicemanager-进程" class="headerlink" title="hwservicemanager 进程"></a><code>hwservicemanager</code> 进程</h2><p><code>hwservicemanager</code> 是 <code>HIDL</code> 服务大管家，负责管理系统中的所有 <code>HIDL</code> 注册的绑定式服务，由 <code>init</code> 进程启动。  </p>
<h3 id="Binder-通信基础知识"><a href="#Binder-通信基础知识" class="headerlink" title="Binder 通信基础知识"></a><code>Binder</code> 通信基础知识</h3><p>先复习下 <code>Framework Binder</code> 通信的基础知识：  </p>
<ul>
<li><code>IInterface</code> 表示服务端能够提供的服务  </li>
<li><code>IBinder</code> 用来实现跨进程通信，分为 <code>BnBinder, BpBinder</code>  </li>
</ul>
<p>客户端和服务端通信过程：  </p>
<ul>
<li>服务端通过 <code>BnBinder</code> 实现 <code>IInterface</code> 对应功能  </li>
<li>客户端通过 <code>BpBinder</code> 调用 <code>IInterface</code> 对应功能； <code>BpBinder</code> 是 <code>BnBinder</code> 的代理，代理的实现过程为通过 <code>Binder Driver</code> 转发  </li>
</ul>
<p><code>Framework Binder</code> 中两个重要概念：  </p>
<ul>
<li><code>service_manager</code> 进程：它是服务大管家，负责保存注册的服务  </li>
<li><code>IServiceManager</code> 供客户端和服务端查询和注册服务，它和 <code>service_manager</code> 是跨进程通信  </li>
</ul>
<p><code>IServiceManager.cpp</code> 作为客户端和服务大管家 <code>service_manager</code> 进程通过 <code>Binder</code> 来通信；其他 <code>aidl</code> 服务进程作为客户端，通过 <code>IServiceManager.cpp</code> 注册服务；其他 <code>app</code> 进程作为客户端，通过 <code>IServiceManager.cpp</code> 查询服务。  </p>
<h3 id="IServiceManager-类图结构"><a href="#IServiceManager-类图结构" class="headerlink" title="IServiceManager 类图结构"></a><code>IServiceManager</code> 类图结构</h3><p><a href="https://upload-images.jianshu.io/upload_images/606437-b97e7bb40e26ac70.png" target="_blank" rel="noopener">IServiceManager 类图结构，查看大图</a>  </p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0110-android-hidl-class-uml-IServiceManager.png" alt="0110-android-hidl-class-uml-IServiceManager.png"></p>
<p>这个类图体现了一般的 <code>HIDL</code> 服务的类结构：  </p>
<ul>
<li><code>IServiceManager</code> 可以看做一个标准的 <code>HIDL</code> 服务，默认继承 <code>IBase</code>  </li>
<li><code>IServiceManager</code> 服务的实现类有两个： <code>PassthroughServiceManager, ServiceManager</code>  </li>
<li><code>BnHwServiceManager</code> 中 <code>_hidl_mImpl</code> 指向 <code>IServiceManager</code> 的具体实现类，这里具体是 <code>ServiceManager</code>  </li>
<li><code>BpHwServiceManager</code> 是代理类，父类 <code>BpHwRefBase</code> 中的 <code>mRemote</code> 指向了 <code>BpHwBinder</code> ，而 <code>BpHwBinder</code> 中的 <code>mHandle</code> 是指向 <code>BHwBinder</code> 的句柄，这里实际指向的是它的子类 <code>BnHwServiceManager</code>  </li>
<li><code>Bp**</code> 和 <code>Bn**</code> 是通过 <code>Binder</code> 驱动来通信的，设备名 <code>/dev/hwbinder</code>  </li>
</ul>
<h3 id="hwBinder-简述"><a href="#hwBinder-简述" class="headerlink" title="hwBinder 简述"></a><code>hwBinder</code> 简述</h3><p><code>hwBinder</code> 和 <code>Binder</code> 模型基本一样，而且是共用 <code>Binder Driver</code> ，仅仅是设备关键字不一样。 <code>hwBinder</code> 中，服务端持有 <code>BnHw</code> 并实现 <code>IInterface</code> 的具体功能；客户端持有 <code>BpHw</code> 调用 <code>IInterface</code> 对应功能， <code>BpHw</code> 是 <code>BnHw</code> 的代理，通过 <code>Binder Driver</code> 来通信。 <code>BpHw, BnHw</code> 的通信过程（读写 <code>Parcel</code> ），都是在自动生成的 <code>IFooAll.cpp</code> 中实现的。<br><code>hwservicemanager</code> 进程功能和 <code>Framework Binder</code> 中的 <code>service_manager</code> 进程相同，它是 <code>HIDL</code> 的服务大管家；但具体由 <code>ServiceManager.cpp</code> 来保存注册的服务， <code>ServiceManager</code> 属于 <code>hwservicemanager</code> 进程，所以通信过程是函数直接调用。<br>客户端和服务端通过 <code>ServiceManagement.cpp</code> 来和 <code>hwservicemanager</code> 通信。 <code>ServiceManagement</code> 会根据绑定式或是直通式来返回 <code>IServiceManager</code> 的具体实现：如果是绑定式，则 <code>ServiceManagement</code> 持有 <code>BpHwServiceManager</code> （即 <code>BnHwServiceManager</code> 的代理），它会和 <code>hwservicemanager</code> 通过 <code>Binder</code> 通信，查询并返回服务接口。  </p>
<h3 id="rc-文件"><a href="#rc-文件" class="headerlink" title="rc 文件"></a><code>rc</code> 文件</h3><p><code>hwservicemanager.rc</code> 文件定义了 <code>hwservicemanager</code> 进程的启动方式：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service hwservicemanager /system/bin/hwservicemanager</span><br><span class="line">    user system</span><br><span class="line">    disabled</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart setprop hwservicemanager.ready false</span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    class animation</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a><code>main</code> 方法</h3><p>主进程文件为 <code>service.cpp</code> ，对应的 <code>main</code> 方法为：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line"></span><br><span class="line">    ServiceManager *manager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, manager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register hwservicemanager with itself."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TokenManager *tokenManager = <span class="keyword">new</span> TokenManager();</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, tokenManager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register ITokenManager with hwservicemanager."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper(Looper::prepare(<span class="number">0</span> <span class="comment">/* opts */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">    IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">    <span class="keyword">if</span> (binder_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to aquire binder FD. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">    <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, </span><br><span class="line">        Looper::EVENT_INPUT, cb, <span class="literal">nullptr</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to add hwbinder FD to Looper. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell IPCThreadState we're the service manager</span></span><br><span class="line">    sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line">    <span class="comment">// Then tell binder kernel</span></span><br><span class="line">    ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 中主要实现了这些功能：  </p>
<ul>
<li>新建 <code>ServiceManager</code> 对象，并将它注册到 <code>hwservicemanager</code> 中（注册过程实际是存储到一个 <code>map</code> 中）  </li>
<li>新建 <code>TokenManager</code> 对象，并将它注册为服务  </li>
<li>轮询 <code>/dev/hwbinder</code> 设备文件，监听事件  </li>
<li>新建 <code>BnHwServiceManager</code> 对象，并将 <code>ServiceManager</code> 传入作为 <code>IServiceManager</code> 的实现  </li>
<li><code>ioctl</code> 向驱动发送消息，将 <code>hwservicemanager</code> 进程，以句柄 0 向驱动注册为服务大管家 <code>BINDER_SET_CONTEXT_MGR</code> （这就是为什么拿到句柄 0 ，即表示为 <code>hwservicemanager</code> ）  </li>
</ul>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a><code>ServiceManager</code></h3><p><code>ServiceManager</code> 用于管理服务的注册和查询， <code>mServiceMap</code> 中保存了服务端相关信息，以全限定名称作为 <code>key</code> 保存。  </p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ServiceManager</span> :</span> <span class="keyword">public</span> IServiceManager, hidl_death_recipient &#123;</span><br><span class="line">    <span class="comment">//Methods from::android::hidl::manager::V1_0::IServiceManager follow</span></span><br><span class="line">    Return&lt;sp&lt;IBase&gt;&gt; get(<span class="keyword">const</span> hidl_string&amp; fqName,</span><br><span class="line">                          <span class="keyword">const</span> hidl_string&amp; name) override;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; add(<span class="keyword">const</span> hidl_string&amp; name,</span><br><span class="line">                     <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service) override;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> InstanceMap = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">// instance name e.x. "manager"</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;HidlService&gt;</span><br><span class="line">        &gt;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PackageInterfaceMap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        InstanceMap mInstanceMap&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Access to this map doesn't need to be locked, since hwservicemanager</span></span><br><span class="line"><span class="comment">     * is single-threaded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * e.x.</span></span><br><span class="line"><span class="comment">     * mServiceMap["android.hidl.manager@1.0::IServiceManager"]["manager"]</span></span><br><span class="line"><span class="comment">     *     -&gt; HidlService object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>, // package::interface </span><br><span class="line">                     // e.x. "android.hidl.manager@1.0::IServiceManager"</span><br><span class="line">        PackageInterfaceMap</span><br><span class="line">    &gt; mServiceMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mServiceMap</code><br>关键字为全限定名： <code>package::interface</code> ，比如：<br><code>android.hidl.manager@1.0::IServiceManager</code> 。  </li>
<li><code>mInstanceMap</code><br>关键字为服务名称，默认为 <code>default</code> ；服务端也可以在注册时，指定服务名称；比如 <code>CameraProvider</code> 中注册时，指定为 <code>&quot;legacy/0&quot;</code> 。  </li>
</ul>
<p>因为先通过全限定从 <code>mServiceMap</code> 中取 <code>mInstanceMap</code> ，而全限定名称包含软件包、主次版本号、接口名称，全限定名称一定不会重复，所以拿到的是唯一的 <code>mInstanceMap</code> ；此时再根据服务名称获取服务端接口时，服务名已经不是很重要，所以通常服务名称使用的默认的 <code>default</code> 。  </p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务端通过 <code>Binder</code> 注册，最终是在 <code>ServiceManager</code> 中实现的，并保存在 <code>mServiceMap</code> 中。<br>注意： <code>add</code> 来注册服务，是 <code>hwbinder</code> 机制内部使用的；服务端应该使用 <code>registerAsService</code> 来注册，而自动生成代码 <code>IFooAll.cpp</code> 中在实现 <code>registerAsService</code> 时，会调用 <code>add</code> 来完成注册。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManager.cpp</span></span><br><span class="line">Return&lt;<span class="keyword">bool</span>&gt; ServiceManager::add(<span class="keyword">const</span> hidl_string&amp; name,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> ret = service-&gt;interfaceChain(</span><br><span class="line">        [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;interfaceChain) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; interfaceChain.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 拿到全限定名</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> fqName = interfaceChain[i];</span><br><span class="line">            <span class="comment">// 根据全限定名查找 mInstanceMap</span></span><br><span class="line">            PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName];</span><br><span class="line">            <span class="comment">// 根据服务名称查找对应服务 </span></span><br><span class="line">            HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有找到或找到为空，则添加或更新</span></span><br><span class="line">            <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ifaceMap.insertService(<span class="built_in">std</span>::make_unique&lt;HidlService&gt;(</span><br><span class="line">                    fqName, name, service, pid));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                hidlService-&gt;setService(service, pid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifaceMap.sendPackageRegistrationNotification(fqName, name);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册的过程为：  </p>
<ul>
<li>先根据全限定名和服务名，查找服务是否存在  </li>
<li>如果不存在，则添加并保存；如果存在则更新  </li>
</ul>
<h3 id="服务查询"><a href="#服务查询" class="headerlink" title="服务查询"></a>服务查询</h3><p>查询 <code>Binder</code> 服务，最终是在 <code>ServiceManager</code> 中实现的，也就是从 <code>mServiceMap</code> 中查找。<br>注意： <code>get</code> 来查询服务，是 <code>hwbinder</code> 机制内部使用的；客户端应该通过接口 <code>Interface::getService</code> 获取：它会先使用 <code>defaultServiceManager</code> 来获取 <code>IServiceManager</code> ，然后再调用 <code>get</code> 方法。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManager.cpp</span></span><br><span class="line">Return&lt;sp&lt;IBase&gt;&gt; ServiceManager::get(<span class="keyword">const</span> hidl_string&amp; fqName,</span><br><span class="line">                                      <span class="keyword">const</span> hidl_string&amp; name) &#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = IPCThreadState::self()-&gt;getCallingPid();</span><br><span class="line">    <span class="keyword">if</span> (!mAcl.canGet(fqName, pid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ifaceIt = mServiceMap.find(fqName);</span><br><span class="line">    <span class="keyword">if</span> (ifaceIt == mServiceMap.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PackageInterfaceMap &amp;ifaceMap = ifaceIt-&gt;second;</span><br><span class="line">    <span class="keyword">const</span> HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hidlService-&gt;getService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询过程很简单：就是从 <code>mServiceMap</code> 中根据全限定名和服务名查找。  </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>hardware/interfaces/tests</code> 中有简单的 <code>HIDL</code> 服务示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tests/</span><br><span class="line">├── Android.bp</span><br><span class="line">├── bar</span><br><span class="line">├── baz</span><br><span class="line">├── expression</span><br><span class="line">├── extension</span><br><span class="line">├── foo</span><br><span class="line">├── hash</span><br><span class="line">├── inheritance</span><br><span class="line">├── libhwbinder</span><br><span class="line">├── memory</span><br><span class="line">├── msgq</span><br><span class="line">├── multithread</span><br><span class="line">├── myintere</span><br><span class="line">└── pointer</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="Binder-总结"><a href="#Binder-总结" class="headerlink" title="Binder 总结"></a><code>Binder</code> 总结</h3><p><code>Binder</code> 域有三个，但它们都是共用了 <code>Binder Driver</code> ，只是设备文件名称不一样（在 <code>kernel</code> 编译配置中设定 <code>CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot;</code> ）：  </p>
<ul>
<li><code>/dev/binder</code><br>标准的 <code>Framework Binder</code> ，使用 <code>AIDL</code> 接口；服务大管家对应的是 <code>servicemanager</code> 进程。  </li>
<li><code>/dev/hwbinder</code><br><code>HIDL</code> 服务相关，使用 <code>HIDL</code> 接口；服务大管家对应的是 <code>hwservicemanager</code> 进程。  </li>
<li><code>/dev/vndbinder</code><br>供应商之间的通信，使用 <code>AIDL</code> 接口；服务大管家对应的是 <code>vndservicemanager</code> 进程。  </li>
</ul>
<p>在 <code>HIDL</code> 服务中，除了使用 <code>/dev/hwbinder</code> 和 <code>Framework</code> 通信外；还可以同时使用 <code>/dev/vndbinder</code> 和 <code>vendor</code> 通信：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hardware/interfaces</span><br><span class="line">camera/provider/2.4/default/service.cpp:32:    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">cas/1.0/default/service.cpp:37:    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">drm/1.0/default/service.cpp:38:    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">gnss/1.0/default/service.cpp:15:    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">graphics/composer/2.1/default/service.cpp:31:    android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br><span class="line">hal-server/hal-server.cpp:107:android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);</span><br></pre></td></tr></table></figure>

<p>这里 <code>vndservicemanager, servicemanager</code> 进程对应的源码文件都是 <code>service-manager.c</code> 文件，只是在 <code>Android.bp</code> 中做了编译区分。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// frameworks/native/cmds/servicemanager/Android.bp</span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;servicemanager&quot;,</span><br><span class="line">    defaults: [&quot;servicemanager_flags&quot;],</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;service_manager.c&quot;,</span><br><span class="line">        &quot;binder.c&quot;,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [&quot;libcutils&quot;, &quot;libselinux&quot;],</span><br><span class="line">    init_rc: [&quot;servicemanager.rc&quot;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;vndservicemanager&quot;,</span><br><span class="line">    defaults: [&quot;servicemanager_flags&quot;],</span><br><span class="line">    vendor: true,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;service_manager.c&quot;,</span><br><span class="line">        &quot;binder.c&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">        &quot;-DVENDORSERVICEMANAGER=1&quot;,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [&quot;libcutils&quot;, &quot;libselinux_vendor&quot;],</span><br><span class="line">    init_rc: [&quot;vndservicemanager.rc&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul>
<li><code>HIDL</code> 分别用 <code>cpp, java</code> 实现两个示例  </li>
<li><code>vts</code> 相关  <ul>
<li><a href="https://source.android.google.cn/compatibility/vts" target="_blank" rel="noopener">供应商测试套件 (VTS) 和基础架构</a>  </li>
<li><a href="https://source.android.google.cn/devices/tech/test_infra/tradefed/fundamentals/vts.html?hl=zh-cn" target="_blank" rel="noopener">使用 VTS 进行系统测试</a>  </li>
</ul>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://source.android.google.cn/devices/architecture/hidl" target="_blank" rel="noopener">官网 HIDL</a>  </li>
<li><a href="https://source.android.google.cn/devices/architecture" target="_blank" rel="noopener">Android 架构</a>  </li>
<li><a href="https://source.android.google.cn/devices/architecture/hidl/code-style" target="_blank" rel="noopener">HIDL 代码规范</a>  </li>
<li><a href="https://source.android.google.cn/devices/architecture/hidl-cpp" target="_blank" rel="noopener">HIDL CPP 示例</a>  </li>
<li><strong><a href="https://blog.csdn.net/yangwen123/article/details/79866249" target="_blank" rel="noopener">hwservicemanager 启动过程</a></strong>  </li>
<li><a href="https://blog.csdn.net/yangwen123/article/details/79868548" target="_blank" rel="noopener">HIDL服务查询过程</a>  </li>
<li><a href="https://blog.csdn.net/yangwen123/article/details/79854267" target="_blank" rel="noopener">HIDL服务注册过程</a>  </li>
<li><a href="https://blog.csdn.net/whshiyun/article/details/88238936" target="_blank" rel="noopener">Android O Treble框架笔记</a>  </li>
<li><a href="https://blog.csdn.net/sinat_20059415/article/details/81808212" target="_blank" rel="noopener">探索 hidl-gen 使用</a>  </li>
<li><a href="https://blog.csdn.net/xiaosayidao/article/details/75577940" target="_blank" rel="noopener">Android Treble架构解析</a>  </li>
<li><a href="https://www.jianshu.com/p/ca6823b897b5" target="_blank" rel="noopener">C++ HIDL 示例 helloworld</a>  </li>
<li><a href="https://blog.csdn.net/u013082948/article/details/80529419" target="_blank" rel="noopener">HAL层开发示例</a>  </li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    redspider110
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://redspider110.github.io/2018/12/27/0110-android-hidl/" title="Android HIDL">http://redspider110.github.io/2018/12/27/0110-android-hidl/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/15/0109-android-camera-6-extras/" rel="next" title="Camera 其他">
                <i class="fa fa-chevron-left"></i> Camera 其他
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/02/0111-android-seandroid/" rel="prev" title="seAndroid 安全机制">
                seAndroid 安全机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="redspider110">
            
              <p class="site-author-name" itemprop="name">redspider110</p>
              <p class="site-description motion-element" itemprop="description">地球卫士</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">124</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HAL-类型"><span class="nav-number">1.1.</span> <span class="nav-text">HAL 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder-HAL"><span class="nav-number">1.2.</span> <span class="nav-text">Binder HAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder-化直通式-HAL"><span class="nav-number">1.3.</span> <span class="nav-text">Binder 化直通式 HAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络配置工具"><span class="nav-number">1.4.</span> <span class="nav-text">网络配置工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换工具"><span class="nav-number">1.5.</span> <span class="nav-text">转换工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#术语"><span class="nav-number">1.6.</span> <span class="nav-text">术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础语法"><span class="nav-number">2.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#规则"><span class="nav-number">2.1.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件包"><span class="nav-number">2.2.</span> <span class="nav-text">软件包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本编号"><span class="nav-number">2.3.</span> <span class="nav-text">版本编号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的注解"><span class="nav-number">2.4.</span> <span class="nav-text">支持的注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hal-定义"><span class="nav-number">2.5.</span> <span class="nav-text">hal 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import-导入"><span class="nav-number">2.6.</span> <span class="nav-text">import 导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口哈希-Hash-和版本控制文件-current-txt"><span class="nav-number">2.7.</span> <span class="nav-text">接口哈希 Hash 和版本控制文件 current.txt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据传递"><span class="nav-number">3.</span> <span class="nav-text">数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#快速消息队列-FMQ"><span class="nav-number">3.1.</span> <span class="nav-text">快速消息队列 FMQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存共享"><span class="nav-number">3.2.</span> <span class="nav-text">内存共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型"><span class="nav-number">4.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-death-recipient"><span class="nav-number">4.1.</span> <span class="nav-text">hidl_death_recipient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-handle"><span class="nav-number">4.2.</span> <span class="nav-text">hidl_handle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-string"><span class="nav-number">4.3.</span> <span class="nav-text">hidl_string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-memory"><span class="nav-number">4.4.</span> <span class="nav-text">hidl_memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-vec"><span class="nav-number">4.5.</span> <span class="nav-text">hidl_vec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-array"><span class="nav-number">4.6.</span> <span class="nav-text">hidl_array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-version"><span class="nav-number">4.7.</span> <span class="nav-text">hidl_version</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hal-文件自动生成代码"><span class="nav-number">5.</span> <span class="nav-text">.hal 文件自动生成代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本步骤"><span class="nav-number">5.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-gen-规则"><span class="nav-number">5.2.</span> <span class="nav-text">hidl-gen 规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hidl-gen-语法"><span class="nav-number">5.3.</span> <span class="nav-text">hidl-gen 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件路径映射"><span class="nav-number">5.4.</span> <span class="nav-text">文件路径映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码文件生成"><span class="nav-number">5.5.</span> <span class="nav-text">代码文件生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HIDL-服务新增函数"><span class="nav-number">5.6.</span> <span class="nav-text">HIDL 服务新增函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务注册与获取"><span class="nav-number">6.</span> <span class="nav-text">服务注册与获取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端注册-Binder-服务"><span class="nav-number">6.1.</span> <span class="nav-text">服务端注册 Binder 服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder-化直通式"><span class="nav-number">6.2.</span> <span class="nav-text">Binder 化直通式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端获取服务"><span class="nav-number">6.3.</span> <span class="nav-text">客户端获取服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务死亡通知"><span class="nav-number">6.4.</span> <span class="nav-text">服务死亡通知</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码结构"><span class="nav-number">7.</span> <span class="nav-text">源码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码目录速查表"><span class="nav-number">7.1.</span> <span class="nav-text">源码目录速查表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libhidl"><span class="nav-number">7.2.</span> <span class="nav-text">libhidl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libhwbinder"><span class="nav-number">7.3.</span> <span class="nav-text">libhwbinder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hwservicemanager"><span class="nav-number">7.4.</span> <span class="nav-text">hwservicemanager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libhidl-目录"><span class="nav-number">8.</span> <span class="nav-text">libhidl 目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libhidlbase-库"><span class="nav-number">8.1.</span> <span class="nav-text">libhidlbase 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libhidlmemory-库"><span class="nav-number">8.2.</span> <span class="nav-text">libhidlmemory 库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-hidl-软件包"><span class="nav-number">8.3.</span> <span class="nav-text">android.hidl.* 软件包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libhidltransport-库"><span class="nav-number">8.4.</span> <span class="nav-text">libhidltransport 库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libhwbinder-目录"><span class="nav-number">9.</span> <span class="nav-text">libhwbinder 目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hwBinder-类图结构"><span class="nav-number">9.1.</span> <span class="nav-text">hwBinder 类图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IBase-类图结构"><span class="nav-number">9.2.</span> <span class="nav-text">IBase 类图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessState"><span class="nav-number">9.3.</span> <span class="nav-text">ProcessState</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hwservicemanager-进程"><span class="nav-number">10.</span> <span class="nav-text">hwservicemanager 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder-通信基础知识"><span class="nav-number">10.1.</span> <span class="nav-text">Binder 通信基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IServiceManager-类图结构"><span class="nav-number">10.2.</span> <span class="nav-text">IServiceManager 类图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hwBinder-简述"><span class="nav-number">10.3.</span> <span class="nav-text">hwBinder 简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rc-文件"><span class="nav-number">10.4.</span> <span class="nav-text">rc 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-方法"><span class="nav-number">10.5.</span> <span class="nav-text">main 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceManager"><span class="nav-number">10.6.</span> <span class="nav-text">ServiceManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务注册"><span class="nav-number">10.7.</span> <span class="nav-text">服务注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务查询"><span class="nav-number">10.8.</span> <span class="nav-text">服务查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">11.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">12.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder-总结"><span class="nav-number">12.1.</span> <span class="nav-text">Binder 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后续"><span class="nav-number">13.</span> <span class="nav-text">后续</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">14.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">redspider110</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
